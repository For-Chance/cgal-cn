<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Hyperbolic_Triangulations"/><anchor id="index_1ChapterHTriangulation2"/> <htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="author"><para>Mikhail Bogdanov, Iordan Iordanov, and Monique Teillaud</para>
</simplesect>
<center> <image type="html" name="header.png" inline="yes"></image>
 </center></para>
<para>This package enables the computation of Delaunay triangulations of point sets in the Poincar<eacute/> disk model of the hyperbolic plane.</para>
<sect1 id="index_1HT2_Poincare_model">
<title>The Poincar√© Disk Model of the Hyperbolic Plane</title>
<para>The Poincar<eacute/> disk model represents the hyperbolic plane <formula id="0">$\mathbb H^2$</formula> in the unit disk centered at the origin in the Euclidean plane: points of <formula id="0">$\mathbb H^2$</formula> lie in the interior of the disk, while its boundary, the unit circle, represents the set <formula id="1">$\mathcal
H_\infty$</formula> of points at infinity.</para>
<para>In this model, a hyperbolic line is either an arc of circle perpendicular to the unit circle or, if it passes through the origin, a diameter of the unit disk. A hyperbolic circle is a Euclidean circle contained in the unit disk; however, its hyperbolic center and radius are not the same as its Euclidean center and radius.</para>
<para><anchor id="index_1fig__Hyperbolic_triangulation_2Poincare_disk"/><center> <image type="html" name="poincare-disk.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__Hyperbolic_triangulation_2Poincare_disk" kindref="member">fig__Hyperbolic_triangulation_2Poincare_disk</ref> The Poincar<eacute/> disk model for the hyperbolic plane. The figure shows two hyperbolic lines and three concentric hyperbolic circles with different radii. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1HT2_Euclidean_and_hyperbolic_Delaunay_triangulations">
<title>Euclidean and Hyperbolic Delaunay Triangulations</title>
<para>As hyperbolic circles coincide with Euclidean circles contained in the unit disk, the combinatorial structure of the hyperbolic Delaunay triangulation of a set <formula id="2">$\mathcal P$</formula> of points in <formula id="0">$\mathbb H^2$</formula> is a subset of the Euclidean Delaunay triangulation of <formula id="3">$\mathcal
P$</formula> (see <ref refid="index_1fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic" kindref="member">fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic</ref> - Left). More precisely, the hyperbolic Delaunay triangulation of <formula id="2">$\mathcal P$</formula> only contains the simplices of the Euclidean Delaunay triangulation that are <emphasis>hyperbolic</emphasis>: <itemizedlist>
<listitem>
<para>A Euclidean Delaunay face is hyperbolic if its circumscribing circle is contained in <formula id="0">$\mathbb H^2$</formula>. </para>
</listitem>
<listitem>
<para>A Euclidean Delaunay edge is hyperbolic if one of the empty disks (i.e., not containing any point of <formula id="4">$\mathcal
        P$</formula>) passing through its endpoints is contained in <formula id="5">$\mathbb
        H^2$</formula>. </para>
</listitem>
</itemizedlist>
</para>
<para>In the Euclidean Delaunay triangulation, there is a bijection between non-hyperbolic faces and non-hyperbolic edges<nonbreakablespace/><ref refid="citelist_1CITEREF_cgal:bdt-hdcvd-14" kindref="member">[1]</ref>, illustrated by <ref refid="index_1fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic" kindref="member">fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic</ref> - Right.</para>
<para><anchor id="index_1fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic"/><center> <image type="html" name="hyperbolic-vs-euclidean.svg" inline="yes"></image>
 <image type="html" name="ht-empty-disks.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic" kindref="member">fig__Hyperbolic_triangulation_2Euclidean_vs_hyperbolic</ref> <bold>Left:</bold> The Euclidean (red) and hyperbolic (black) Delaunay triangulations of a given set of points in the unit disk. Only the colored faces are faces of the hyperbolic Delaunay triangulation. The hyperbolic and Euclidean geometric embeddings of a Delaunay face that exists in both triangulations are different. <bold>Right:</bold> The shaded face is non-hyperbolic. Its dashed edge is non-hyperbolic, as no empty circle through its endpoints is contained in <formula id="0">$\mathbb H^2$</formula>. Its other two edges are hyperbolic. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The hyperbolic Delaunay triangulation is a simplicial complex, i.e., a set of simplices such that <itemizedlist>
<listitem>
<para>any face of a simplex is a simplex, </para>
</listitem>
<listitem>
<para>two simplices either are disjoint or share a common face. </para>
</listitem>
</itemizedlist>
Moreover, it is connected<nonbreakablespace/><ref refid="citelist_1CITEREF_cgal:bdt-hdcvd-14" kindref="member">[1]</ref>.</para>
</sect1>
<sect1 id="index_1HT2_Software_design">
<title>Software Design</title>
<para>From what was said above, it is natural that the class <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__2" kindref="compound">Hyperbolic_Delaunay_triangulation_2</ref></computeroutput> privately inherits from the class <computeroutput><ref refid="classCGAL_1_1Delaunay__triangulation__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">Delaunay_triangulation_2</ref></computeroutput>. Consequently, users are encouraged to look at Chapter <ref refid="index_1Chapter_2D_Triangulations" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">2D Triangulation</ref> of the CGAL manual to know more in particular about the representation of triangulations in <ref refid="namespaceCGAL" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL</ref> and the flexibility of the design.</para>
<para>The class <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__2" kindref="compound">Hyperbolic_Delaunay_triangulation_2</ref></computeroutput> has two template parameters: <itemizedlist>
<listitem>
<para>A <bold>geometric traits</bold> class <computeroutput>Gt</computeroutput>, which provides geometric primitives. The requirements on this first template parameter are described by the concept <computeroutput><ref refid="classHyperbolicDelaunayTriangulationTraits__2" kindref="compound">HyperbolicDelaunayTriangulationTraits_2</ref></computeroutput>, which refines <computeroutput><ref refid="classDelaunayTriangulationTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">DelaunayTriangulationTraits_2</ref></computeroutput>. </para>
</listitem>
<listitem>
<para>A <bold>triangulation data structure</bold> parameter, for which the requirements are described by the concept <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput>. The vertex and face of this triangulation data structure must be models of the concepts <computeroutput><ref refid="classTriangulationVertexBase__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">TriangulationVertexBase_2</ref></computeroutput> and <computeroutput><ref refid="classHyperbolicTriangulationFaceBase__2" kindref="compound">HyperbolicTriangulationFaceBase_2</ref></computeroutput>, respectively. </para>
</listitem>
</itemizedlist>
</para>
<para>Two models of the concept <computeroutput><ref refid="classHyperbolicDelaunayTriangulationTraits__2" kindref="compound">HyperbolicDelaunayTriangulationTraits_2</ref></computeroutput> are proposed for the geometric traits class. The first one, <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__CK__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_CK_traits_2</ref></computeroutput>, is based upon <computeroutput><ref refid="structCGAL_1_1Circular__kernel__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Circular_kernel_2.tag">CGAL::Circular_kernel_2</ref></computeroutput> and guarantees exact constructions of Delaunay triangulations and dual objects when the input points have rational coordinates. The second one, <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_traits_2</ref></computeroutput>, is more general, as it guarantees exact constructions even for input points with algebraic coordinates; however the first model is more efficient for rational points.</para>
</sect1>
<sect1 id="index_1Examples">
<title>Examples</title>
<para>The example below shows insertion of random points in a hyperbolic Delaunay triangulation. The same set of points is inserted twice. The first time points are inserted one by one, which causes Euclidean faces to be filtered at each insertion. The second time, all points are inserted and the filtering is done once at the end. <linebreak/>
<bold>File</bold> <ref refid="Hyperbolic_triangulation_2_2ht2_example_8cpp-example" kindref="compound">Hyperbolic_triangulation_2/ht2_example.cpp</ref> <programlisting filename="Hyperbolic_triangulation_2/ht2_example.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_traits_2&lt;&gt;</ref><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::Circle_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Circle__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Circle_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Gt::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;FT, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(argc<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[number_of_points]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Defaulting<sp/>to<sp/>100k<sp/>points...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>100000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_disc_2&lt;Point_2,<sp/>Creator&gt;<sp/>in_disc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;::iterator<sp/>ip;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;N;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pts.push_back(*(in_disc++));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dt<sp/>dt_during;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Insertion<sp/>of<sp/>points<sp/>one<sp/>by<sp/>one<sp/>(hyperbolic<sp/>filtering<sp/>at<sp/>each<sp/>step)&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;===================================================================&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(ip<sp/>=<sp/>pts.begin();<sp/>ip<sp/>!=<sp/>pts.end();<sp/>++ip)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dt_during.insert(*ip);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_during.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>hyperbolic<sp/>faces:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_during.number_of_hyperbolic_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>hyperbolic<sp/>edges:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_during.number_of_hyperbolic_edges()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Time:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dt<sp/>dt_end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Insertion<sp/>of<sp/>point<sp/>set<sp/>(hyperbolic<sp/>filtering<sp/>only<sp/>once<sp/>at<sp/>the<sp/>end)&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;===================================================================&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>dt_end.insert(pts.begin(),pts.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>timer.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_end.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>hyperbolic<sp/>faces:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_end.number_of_hyperbolic_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>hyperbolic<sp/>edges:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt_end.number_of_hyperbolic_edges()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Time:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>timer.time()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The example below shows how user-defined info can be added to the hyperbolic faces. <linebreak/>
<bold>File</bold> <ref refid="Hyperbolic_triangulation_2_2ht2_example_color_8cpp-example" kindref="compound">Hyperbolic_triangulation_2/ht2_example_color.cpp</ref> <programlisting filename="Hyperbolic_triangulation_2/ht2_example_color.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_triangulation_face_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_Delaunay_triangulation_CK_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Triangulation_vertex_base_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Color.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__CK__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_CK_traits_2&lt;&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Hyperbolic__triangulation__face__base__2" kindref="compound">CGAL::Hyperbolic_triangulation_face_base_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hyperbolic_face_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__face__base__with__info__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_face_base_with_info_2</ref>&lt;<ref refid="classCGAL_1_1IO_1_1Color" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::Color</ref>,<sp/>Gt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hyperbolic_face_base&gt;<sp/>Face_base_with_info;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__vertex__base__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">CGAL::Triangulation_vertex_base_2&lt;Gt&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_base;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2</ref>&lt;Vertex_base,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_base_with_info&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>TDS;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_2&lt;Gt, TDS&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Dt::Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;Gt::FT, Point_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(argc<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[number_of_points]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Defaulting<sp/>to<sp/>100k<sp/>points...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>100000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_disc_2&lt;Point_2,<sp/>Creator&gt;<sp/>in_disc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;N;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pts.push_back(*(in_disc++));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dt<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>dt.insert(pts.begin(),<sp/>pts.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dt::Vertex_handle<sp/>vo<sp/>=<sp/>dt.insert(Point_2(0,0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>origin_faces<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Dt::Hyperbolic_faces_iterator<sp/>fit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(fit<sp/>=<sp/>dt.hyperbolic_faces_begin();<sp/>fit<sp/>!=<sp/>dt.hyperbolic_faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(fit-&gt;has_vertex(vo))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>fit-&gt;info()<sp/>=<sp/>CGAL::IO::red();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>origin_faces++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>red_faces<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(fit<sp/>=<sp/>dt.hyperbolic_faces_begin();<sp/>fit<sp/>!=<sp/>dt.hyperbolic_faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(fit-&gt;info()<sp/>==<sp/>CGAL::IO::red())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>red_faces++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(red_faces<sp/>==<sp/>origin_faces);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>points<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt.number_of_vertices()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>hyperbolic<sp/>faces:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>dt.number_of_hyperbolic_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>faces<sp/>incident<sp/>to<sp/>the<sp/>origin:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>origin_faces<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1HT2_Performance">
<title>Performance</title>
<para>We have measured the insertion execution time of our implementation with both traits classes <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__CK__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_CK_traits_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_traits_2</ref></computeroutput> with their default template parameters against the insertion time in a Euclidean CGAL triangulation. We generate 1 million random points, uniformly distributed in the unit disk with respect to the Euclidean metric. We insert the same set of points in three triangulations: <itemizedlist>
<listitem>
<para>a hyperbolic Delaunay triangulation with <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_traits_2</ref></computeroutput> (CORE traits) as traits class; </para>
</listitem>
<listitem>
<para>a hyperbolic Delaunay triangulation with <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__CK__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_CK_traits_2</ref></computeroutput> (CK traits) as traits class; </para>
</listitem>
<listitem>
<para>a Euclidean Delaunay triangulation with <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref></computeroutput> (EPICK) as traits class. </para>
</listitem>
</itemizedlist>
We create two instances of each type of triangulation. In one instance we insert the points one by one, which causes non-hyperbolic faces to be filtered out at each insertion. In the other instance we insert the points via iterator input, which causes non-hyperbolic faces to be filtered only once, after all points have been inserted. We report results averaged over 10 executions of this experiment in <ref refid="index_1HT2_Table_1" kindref="member">Table 1</ref> below. The experiments have been executed on two machines: <itemizedlist>
<listitem>
<para><bold>Machine 1:</bold> MacBook Pro (2015), CPU: Intel Core i5 @ 2.9 GHz, RAM: 16 GB @ 1867 MHz, OS: Mac OS X (10.10.5), Compiler: gcc version 7.3.0; </para>
</listitem>
<listitem>
<para><bold>Machine 2:</bold> Dell Vostro 5471 (2018), CPU: Intel Core i5 @ 1.6 GHZ (up to 3.4 GHz in TurboMode), RAM: 8GB @ 2400 MHz, OS: Ubuntu 18.04 (kernel 4.15.0), Compiler: gcc version 7.3.0. </para>
</listitem>
</itemizedlist>
</para>
<para><center> <anchor id="index_1HT2_Table_1"/><table rows="5" cols="5"><caption>Table 1: Comparison of insertion times of 1 million random points</caption>
<row>
<entry thead="yes"><para>Triangulation type </para>
</entry><entry thead="yes" colspan="2"><para>Machine 1 </para>
</entry><entry thead="yes" colspan="2"><para>Machine 2 </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>Sequential insertion </para>
</entry><entry thead="no"><para>Iterator insertion </para>
</entry><entry thead="no"><para>Sequential insertion </para>
</entry><entry thead="no"><para>Iterator insertion </para>
</entry></row>
<row>
<entry thead="no"><para>Hyperbolic (CORE traits) </para>
</entry><entry thead="no"><para>955 sec. </para>
</entry><entry thead="no"><para>23 sec. </para>
</entry><entry thead="no"><para>884 sec. </para>
</entry><entry thead="no"><para>20 sec. </para>
</entry></row>
<row>
<entry thead="no"><para>Hyperbolic (CK traits) </para>
</entry><entry thead="no"><para>330 sec. </para>
</entry><entry thead="no"><para>1 sec. </para>
</entry><entry thead="no"><para>289 sec. </para>
</entry><entry thead="no"><para>1 sec. </para>
</entry></row>
<row>
<entry thead="no"><para>Euclidean (EPICK) </para>
</entry><entry thead="no"><para>131 sec. </para>
</entry><entry thead="no"><para>0.71 sec. </para>
</entry><entry thead="no"><para>114 sec. </para>
</entry><entry thead="no"><para>0.68 sec. </para>
</entry></row>
</table>
</center></para>
</sect1>
<sect1 id="index_1HT2_Design">
<title>Design and Implementation History</title>
<para>This package implements the algorithms for computing Delaunay complexes in the hyperbolic plane, described by Mikhail Bogdanov, Olivier Devillers, and Monique Teillaud <ref refid="citelist_1CITEREF_cgal:bdt-hdcvd-14" kindref="member">[1]</ref>.</para>
<para>Mikhail Bogdanov wrote most of the code. Iordan Iordanov added the traits class <computeroutput><ref refid="classCGAL_1_1Hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Hyperbolic_Delaunay_triangulation_traits_2</ref></computeroutput> and worked on the documentations. Both were PhD candidates advised by Monique Teillaud.</para>
<para>Authors acknowledge partial support from <ulink url="https://members.loria.fr/Monique.Teillaud/collab/SoS/">ANR SoS</ulink>. </para>
</sect1>
    </detaileddescription>
    <location file="Hyperbolic_triangulation_2.txt"/>
  </compounddef>
</doxygen>
