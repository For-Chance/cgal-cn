<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/tutorial_hello_world.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0.1 - Manual: Hello World</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> </span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0.1 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tutorial_hello_world.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Hello World </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Author</dt><dd>CGAL编辑委员会</dd></dl>
<p>本教程面向了解C++并具备基本几何算法知识的CGAL新手。第一部分展示如何定义点和线段类，以及如何对它们应用几何谓词。该部分还会提醒读者在使用浮点数作为坐标时存在的严重问题。第二部分将介绍一个典型的CGAL函数，用于计算二维凸包。第三部分解释我们所说的特征类（Traits class）的含义，第四部分则阐述概念（concept）和模型（model）的概念。</p>
<h1><a class="anchor" id="intro_Three"></a>
三个点和一条线段</h1>
<p>在这个第一个示例中，我们将演示如何构造一些点和线段，并对它们执行一些基本操作。</p>
<p>所有CGAL头文件都位于<code>include/CGAL</code>子目录中。所有CGAL类和函数都在<code><a class="elRef" href="../Algebraic_foundations/namespaceCGAL.html">CGAL</a></code>命名空间中。类名以大写字母开头，全局函数以小写字母开头，常量则全部大写。对象的维度通过后缀表示。</p>
<p>几何基元（如点类型）在核（kernel）中定义。在这个第一个示例中，我们选择的核使用双精度浮点数来表示点的笛卡尔坐标。</p>
<p>除了类型之外，我们还会看到谓词（predicates），如三点方向测试，以及构造（constructions），如距离和中点计算。谓词具有有限的可能结果集，而构造则产生数值或其他几何实体。</p>
<p><br>
<b>File</b> <a class="el" href="Kernel_23_2points_and_segment_8cpp-example.html">Kernel_23/points_and_segment.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a> Segment_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Point_2 p(1,1), q(10,10);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"p = "</span> &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"q = "</span> &lt;&lt; q.x() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; q.y() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"sqdist(p,q) = "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(p,q) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Segment_2 s(p,q);</div>
<div class="line">  Point_2 m(5, 9);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"m = "</span> &lt;&lt; m &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"sqdist(Segment_2(p,q), m) = "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(s,m) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"p, q, and m "</span>;</div>
<div class="line">  <span class="keywordflow">switch</span> (<a class="code hl_functionRef" href="../Kernel_23/group__orientation__grp.html#ga91d9866cfde916ba70e5dbc596176d9e">CGAL::orientation</a>(p,q,m)){</div>
<div class="line">  <span class="keywordflow">case</span> <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga84f760a315c4f27cb4059db8a3a1159e">CGAL::COLLINEAR</a>:</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"are collinear\n"</span>;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga803e5969acd01d45aec5acaee6f82883">CGAL::LEFT_TURN</a>:</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"make a left turn\n"</span>;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga1f9d8cac74201e22d484b10384fe3bf9">CGAL::RIGHT_TURN</a>:</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"make a right turn\n"</span>;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">" midpoint(p,q) = "</span> &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__midpoint__grp.html#ga6b971827bb460dd0611c932a7dd287f2">CGAL::midpoint</a>(p,q) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassKernel_1_1Point__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></div></div>
<div class="ttc" id="aclassKernel_1_1Segment__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga1f9d8cac74201e22d484b10384fe3bf9"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga1f9d8cac74201e22d484b10384fe3bf9">CGAL::RIGHT_TURN</a></div><div class="ttdeci">const CGAL::Orientation RIGHT_TURN</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga803e5969acd01d45aec5acaee6f82883"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga803e5969acd01d45aec5acaee6f82883">CGAL::LEFT_TURN</a></div><div class="ttdeci">const CGAL::Orientation LEFT_TURN</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga84f760a315c4f27cb4059db8a3a1159e"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga84f760a315c4f27cb4059db8a3a1159e">CGAL::COLLINEAR</a></div><div class="ttdeci">const CGAL::Orientation COLLINEAR</div></div>
<div class="ttc" id="agroup__midpoint__grp_html_ga6b971827bb460dd0611c932a7dd287f2"><div class="ttname"><a href="../Kernel_23/group__midpoint__grp.html#ga6b971827bb460dd0611c932a7dd287f2">CGAL::midpoint</a></div><div class="ttdeci">CGAL::Point_2&lt; Kernel &gt; midpoint(const CGAL::Point_2&lt; Kernel &gt; &amp;p, const CGAL::Point_2&lt; Kernel &gt; &amp;q)</div></div>
<div class="ttc" id="agroup__orientation__grp_html_ga91d9866cfde916ba70e5dbc596176d9e"><div class="ttname"><a href="../Kernel_23/group__orientation__grp.html#ga91d9866cfde916ba70e5dbc596176d9e">CGAL::orientation</a></div><div class="ttdeci">Orientation orientation(const CGAL::Point_2&lt; Kernel &gt; &amp;p, const CGAL::Point_2&lt; Kernel &gt; &amp;q, const CGAL::Point_2&lt; Kernel &gt; &amp;r)</div></div>
<div class="ttc" id="agroup__squared__distance__grp_html_ga1ff73525660a052564d33fbdd61a4f71"><div class="ttname"><a href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="ttdeci">Kernel::FT squared_distance(Type1&lt; Kernel &gt; obj1, Type2&lt; Kernel &gt; obj2)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --><p>使用浮点数进行几何计算可能会带来意外结果，如下例所示。</p>
<p><br>
<b>File</b> <a class="el" href="Kernel_23_2surprising_8cpp-example.html">Kernel_23/surprising.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  {</div>
<div class="line">    Point_2 p(0, 0.3), q(1, 0.6), r(2, 0.9);</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    Point_2 p(0, 1.0/3.0), q(1, 2.0/3.0), r(2, 1);</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    Point_2 p(0,0), q(1, 1), r(2, 2);</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__collinear__grp_html_gadaa777c7b2f72b4321fe1ac3893efc3b"><div class="ttname"><a href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a></div><div class="ttdeci">bool collinear(const CGAL::Point_2&lt; Kernel &gt; &amp;p, const CGAL::Point_2&lt; Kernel &gt; &amp;q, const CGAL::Point_2&lt; Kernel &gt; &amp;r)</div></div>
</div><!-- fragment --><p>阅读代码时，我们可能会认为它会打印三次"collinear"（共线）。然而，实际输出如下：</p>
<pre class="fragment">not collinear
not collinear
collinear
</pre><p>这是因为这些分数无法用双精度数精确表示，共线性测试在内部会计算一个3x3矩阵的行列式，其结果接近但不等于零，因此前两次测试显示非共线。</p>
<p>类似的情况也可能发生在执行左转的点上，由于行列式计算过程中的舍入误差，这些点可能看起来是共线的，或者执行右转。</p>
<p>如果你需要确保数字以其完整精度进行解释，可以使用执行精确谓词和精确构造的CGAL核。</p>
<p><br>
<b>File</b> <a class="el" href="Kernel_23_2exact_8cpp-example.html">Kernel_23/exact.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Point_2 p(0, 0.3), q, r(2, 0.9);</div>
<div class="line">  {</div>
<div class="line">    q  = Point_2(1, 0.6);</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    std::istringstream input(<span class="stringliteral">"0 0.3   1 0.6   2 0.9"</span>);</div>
<div class="line">    input &gt;&gt; p &gt;&gt; q &gt;&gt; r;</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    q = <a class="code hl_functionRef" href="../Kernel_23/group__midpoint__grp.html#ga6b971827bb460dd0611c932a7dd287f2">CGAL::midpoint</a>(p,r);</div>
<div class="line">    std::cout &lt;&lt; (<a class="code hl_functionRef" href="../Kernel_23/group__collinear__grp.html#gadaa777c7b2f72b4321fe1ac3893efc3b">CGAL::collinear</a>(p,q,r) ? <span class="stringliteral">"collinear\n"</span> : <span class="stringliteral">"not collinear\n"</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__exact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></div></div>
</div><!-- fragment --><p>以下是输出结果，可能仍会让你感到惊讶：</p>
<pre class="fragment">not collinear
collinear
collinear
</pre><p>在第一个代码块中，点仍然不共线，原因很简单：你看到的文本坐标首先被转换为浮点数。当它们随后被转换为任意精度有理数时，它们精确表示了浮点数，而不是原始文本！</p>
<p>第二个代码块则不同，它对应于从文件读取数字。任意精度有理数直接从字符串构造，因此它们精确表示了文本。</p>
<p>在第三个代码块中，你可以看到构造操作（如中点构造）是精确的，正如核类型的名称所暗示的那样。</p>
<p>在许多情况下，你会遇到"精确"的浮点数，它们是由某些应用程序计算得出或从传感器获取的。它们不是字符串"0.1"或通过"1.0/10.0"即时计算的，而是完整精度的浮点数。如果它们作为输入提供给不进行构造的算法，你可以使用提供精确谓词但不精确构造的核。凸包算法就是一个这样的例子，我们将在下一节中看到。输出是输入的子集，算法只比较坐标和执行方向测试。</p>
<p>乍看之下，执行精确谓词和构造的核似乎是完美的选择，但性能要求或有限的内存资源使其并非如此。此外，对许多算法来说，执行精确构造并不重要。例如，通过将边折叠到边的中点来迭代收缩边的表面网格简化算法。</p>
<p>大多数CGAL包都会说明应该使用或支持哪种类型的核。</p>
<h1><a class="anchor" id="intro_convex_hull"></a>
点序列的凸包</h1>
<p>本节的所有示例都计算点集的二维凸包。我们将展示算法如何通过表示点范围的起始/结束迭代器对获取输入，并将结果（在示例中是凸包上的点）写入输出迭代器。</p>
<h2><a class="anchor" id="intro_array"></a>
内置数组中点的凸包</h2>
<p>在第一个示例中，输入是一个包含五个点的数组。由于这些点的凸包是输入的子集，因此提供相同大小的数组来存储结果是安全的。</p>
<p><br>
<b>File</b> <a class="el" href="Convex_hull_2_2array_convex_hull_2_8cpp-example.html">Convex_hull_2/array_convex_hull_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Point_2 points[5] = { Point_2(0,0), Point_2(10,0), Point_2(10,10), Point_2(6,5), Point_2(4,1) };</div>
<div class="line">  Point_2 result[5];</div>
<div class="line"> </div>
<div class="line">  Point_2 *ptr = <a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( points, points+5, result );</div>
<div class="line">  std::cout &lt;&lt;  ptr - result &lt;&lt; <span class="stringliteral">" points on the convex hull:"</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; ptr - result; i++){</div>
<div class="line">    std::cout &lt;&lt; result[i] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup__PkgConvexHull2Functions_html_ga8241d43969ff61cb9be46811c2e9e176"><div class="ttname"><a href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a></div><div class="ttdeci">OutputIterator convex_hull_2(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;ch_traits)</div></div>
</div><!-- fragment --><p>我们在上一节中看到CGAL提供了几种核。由于凸包算法只进行坐标比较和输入点的方向测试，我们可以选择提供精确谓词但不提供精确几何构造的核。</p>
<p>凸包函数接受三个参数：输入的起始和结束指针，以及结果数组的起始指针。该函数返回结果数组中最后一个凸包点之后的指针，因此指针差可以告诉我们凸包上有多少个点。</p>
<h2><a class="anchor" id="intro_vector"></a>
Vector中点的凸包</h2>
<p>在第二个示例中，我们用标准模板库的<code>std::vector</code>替换内置数组。</p>
<p><br>
<b>File</b> <a class="el" href="Convex_hull_2_2vector_convex_hull_2_8cpp-example.html">Convex_hull_2/vector_convex_hull_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_2&gt; Points;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Points points, result;</div>
<div class="line">  points.push_back(Point_2(0,0));</div>
<div class="line">  points.push_back(Point_2(10,0));</div>
<div class="line">  points.push_back(Point_2(10,10));</div>
<div class="line">  points.push_back(Point_2(6,5));</div>
<div class="line">  points.push_back(Point_2(4,1));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( points.begin(), points.end(), std::back_inserter(result) );</div>
<div class="line">  std::cout &lt;&lt; result.size() &lt;&lt; <span class="stringliteral">" points on the convex hull"</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>我们通过调用<code>std::vector</code>类的<code>push_back()</code>方法将一些点放入向量中。</p>
<p>然后我们调用凸包函数。前两个参数<code>points.begin()</code>和<code>points.end()</code>是迭代器，它们是指针的泛化：可以解引用和递增。凸包函数是泛型的，意味着它可以接受任何可以解引用和递增的输入。</p>
<p>第三个参数是结果写入的位置。在前一个示例中，我们提供了指向已分配内存的指针。这种指针的泛化是输出迭代器，它允许递增和为解引用的迭代器赋值。在这个示例中，我们从一个空向量开始，它会根据需要增长。因此，我们不能简单地传递<code>result.begin()</code>，而是要使用辅助函数<code>std::back_inserter(result)</code>生成的输出迭代器。这个输出迭代器在递增时不执行任何操作，在赋值时调用<code>result.push_back(..)</code>。</p>
<p>如果你了解STL（标准模板库），上述内容完全合理，因为这就是STL将算法与容器解耦的方式。如果你不了解STL，最好先熟悉其基本概念。</p>
<h1><a class="anchor" id="intro_traits"></a>
关于核和特征类</h1>
<p>在本节中，我们将说明如何表达使用任意点类型的<code><a class="elRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code>函数所必须满足的要求。</p>
<p>如果你查看<code><a class="elRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code>函数和其他二维凸包算法的手册页，你会看到它们有两个版本。在我们之前看到的示例中，函数接受输入点范围的两个迭代器和用于写入结果的输出迭代器。第二个版本有一个额外的模板参数<code>Traits</code>和该类型的额外参数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator , <span class="keyword">class</span> OutputIterator , <span class="keyword">class</span> Traits &gt;</div>
<div class="line"><a class="code hl_class" href="classOutputIterator.html">OutputIterator</a></div>
<div class="line"><a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2</a>(<a class="code hl_class" href="classInputIterator.html">InputIterator</a> first,</div>
<div class="line">              <a class="code hl_class" href="classInputIterator.html">InputIterator</a> beyond,</div>
<div class="line">              <a class="code hl_class" href="classOutputIterator.html">OutputIterator</a> result,</div>
<div class="line">              <span class="keyword">const</span> Traits &amp; ch_traits)</div>
<div class="ttc" id="aclassInputIterator_html"><div class="ttname"><a href="classInputIterator.html">InputIterator</a></div><div class="ttdoc">Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator.</div><div class="ttdef"><b>Definition:</b> General.txt:143</div></div>
<div class="ttc" id="aclassOutputIterator_html"><div class="ttname"><a href="classOutputIterator.html">OutputIterator</a></div><div class="ttdoc">Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/OutputIterator.</div><div class="ttdef"><b>Definition:</b> General.txt:138</div></div>
</div><!-- fragment --><p>典型的凸包算法使用哪些几何基元？当然，这取决于算法，让我们考虑可能是最简单的高效算法，即所谓的"Graham/Andrew扫描"。该算法首先将点从左到右排序，然后通过从排序列表中一个接一个地添加点来增量构建凸包。为此，它至少必须知道某种点类型，应该知道如何对这些点进行排序，并且必须能够评估三个点的方向。</p>
<p>这就是模板参数<code>Traits</code>发挥作用的地方。对于<code><a class="elRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">ch_graham_andrew()</a></code>，它必须提供以下嵌套类型：</p>
<ul>
<li><code>Traits::Point_2</code></li>
<li><code>Traits::Less_xy_2</code></li>
<li><code>Traits::Left_turn_2</code></li>
<li><code>Traits::Equal_2</code></li>
</ul>
<p>正如你所猜测的，<code>Left_turn_2</code>负责方向测试，而<code>Less_xy_2</code>用于排序点。这些类型必须满足的要求在<code><a class="elRef" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>概念中有完整的文档说明。</p>
<p>这些类型被重新组织是有原因的。替代方案将是一个相当长的函数模板，以及更长的函数调用。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Po<span class="keywordtype">int</span>_2, <span class="keyword">class</span> Less_xy_2, <span class="keyword">class</span> Left_turn_2, <span class="keyword">class</span> Equal_2&gt;</div>
<div class="line"><a class="code hl_class" href="classOutputIterator.html">OutputIterator</a></div>
<div class="line"><a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">ch_graham_andrew</a>( <a class="code hl_class" href="classInputIterator.html">InputIterator</a>  first,</div>
<div class="line">                  <a class="code hl_class" href="classInputIterator.html">InputIterator</a>  beyond,</div>
<div class="line">                  <a class="code hl_class" href="classOutputIterator.html">OutputIterator</a> result);</div>
<div class="ttc" id="agroup__PkgConvexHull2Functions_html_gaeccc6dda2f9d3096c94a7ff84cc91a85"><div class="ttname"><a href="../Convex_hull_2/group__PkgConvexHull2Functions.html#gaeccc6dda2f9d3096c94a7ff84cc91a85">CGAL::ch_graham_andrew</a></div><div class="ttdeci">OutputIterator ch_graham_andrew(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;ch_traits=Default_traits)</div></div>
</div><!-- fragment --><p>这里有两个明显的问题：什么可以用作这个模板参数的参数？为什么我们要使用模板参数？</p>
<p>回答第一个问题，CGAL概念<code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code>的任何模型都提供了<code><a class="elRef" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>概念所要求的内容。</p>
<p>至于第二个问题，想象一个需要计算三维点投影到<code>yz</code>平面的凸包的应用。使用<code><a class="elRef" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a></code>类，这只是前一个示例的小修改。</p>
<p><br>
<b>File</b> <a class="el" href="Convex_hull_2_2convex_hull_yz_8cpp-example.html">Convex_hull_2/convex_hull_yz.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_yz_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">CGAL::Projection_traits_yz_3&lt;K3&gt;</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_2 Point_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  std::istream_iterator&lt; Point_2 &gt;  input_begin( std::cin );</div>
<div class="line">  std::istream_iterator&lt; Point_2 &gt;  input_end;</div>
<div class="line">  std::ostream_iterator&lt; Point_2 &gt;  output( std::cout, <span class="stringliteral">"\n"</span> );</div>
<div class="line">  <a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>( input_begin, input_end, output, K() );</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Projection__traits__yz__3_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">CGAL::Projection_traits_yz_3</a></div></div>
</div><!-- fragment --><p>另一个例子是关于用户定义的点类型，或来自CGAL以外的第三方库的点类型。将点类型与该点类型所需的谓词放在一个类的作用域中，你就可以用这些点运行<code><a class="elRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">convex_hull_2()</a></code>。</p>
<p>最后，让我们解释为什么要传递特征对象给凸包函数？它允许使用更通用的投影特征对象来存储状态，例如，如果投影平面由一个方向给出，这在类<code><a class="elRef" href="../Kernel_23/classCGAL_1_1Projection__traits__yz__3.html">Projection_traits_yz_3</a></code>中是硬编码的。</p>
<h1><a class="anchor" id="intro_concept"></a>
概念和模型</h1>
<p>在上一节中，我们写道：CGAL概念<code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code>的任何模型都提供了概念<code><a class="elRef" href="../Convex_hull_2/classConvexHullTraits__2.html">ConvexHullTraits_2</a></code>所要求的内容。</p>
<p>概念（concept）是对类型的一组要求，即它必须具有某些嵌套类型、某些成员函数，或者带有以该类型为参数的某些自由函数。概念的模型（model）是满足概念要求的类。</p>
<p>让我们看看下面的函数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T</div>
<div class="line">duplicate(T t)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> t;</div>
<div class="line">}</div>
</div><!-- fragment --><p>如果你想用类<code>C</code>实例化这个函数，这个类必须至少提供一个复制构造函数，我们说类<code>C</code>必须是<code><a class="el" href="classCopyConstructible.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/CopyConstructible.">CopyConstructible</a></code>的模型。单例类就不满足这个要求。</p>
<p>另一个例子是函数：</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T&amp; std::min(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (a&lt;b)?a:b;</div>
<div class="line">}</div>
</div><!-- fragment --><p>只有当用作<code>T</code>的类型定义了<code>operator&lt;(..)</code>时，这个函数才能编译，我们说该类型必须是<code><a class="el" href="classLessThanComparable.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/LessThanComparable.">LessThanComparable</a></code>的模型。</p>
<p>需要自由函数的概念的一个例子是CGAL包PkgBGL中的`HalfedgeListGraph`。为了成为`HalfedgeListGraph`的模型，类`G`必须有一个全局函数`halfedges(const G&amp;)`等。</p>
<p>需要特征类的概念的一个例子是<code><a class="el" href="classInputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator.">InputIterator</a></code>。对于<code><a class="el" href="classInputIterator.html" title="Concept from the C++ standard. See https://en.cppreference.com/w/cpp/named_req/InputIterator.">InputIterator</a></code>的模型，必须存在类 <a href="https://en.cppreference.com/w/cpp/iterator/iterator_traits"><code>std::iterator_traits</code></a> 的特化（或者通用模板必须适用）。</p>
<h1><a class="anchor" id="intro_further"></a>
进一步阅读</h1>
<p>我们还推荐Addison-Wesley出版的Nicolai M. Josuttis的"The C++ Standard Library, A Tutorial and Reference"，或Matthew H. Austern的"Generic Programming and the STL"，这些书籍介绍了STL及其概念和模型的概念。</p>
<p>CGAL的其他资源包括其余的<a class="el" href="tutorials.html">教程</a>和https://www.cgal.org/上的用户支持页面。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
