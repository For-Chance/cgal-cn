<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classCGAL_1_1Segment__3" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Segment_3</compoundname>
    <includes local="no">CGAL/Segment_3.h</includes>
    <templateparamlist>
      <param>
        <type>typename <ref refid="classKernel" kindref="compound">Kernel</ref></type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1aff6ed6df35e451f8341b697e2ff395b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Segment_3&lt; Kernel &gt;::Segment_3</definition>
        <argsstring>(const Point_3&lt; Kernel &gt; &amp;p, const Point_3&lt; Kernel &gt; &amp;q)</argsstring>
        <name>Segment_3</name>
        <qualifiedname>CGAL::Segment_3::Segment_3</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>introduces a segment <computeroutput>s</computeroutput> with source <computeroutput>p</computeroutput> and target <computeroutput>q</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>It is directed from the source towards the target. <variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="33" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a8112f4621b334b119b1176241397a21c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Segment_3&lt; Kernel &gt;::operator==</definition>
        <argsstring>(const Segment_3&lt; Kernel &gt; &amp;q) const</argsstring>
        <name>operator==</name>
        <qualifiedname>CGAL::Segment_3::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Segment__3" kindref="compound">Segment_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>Test for equality: Two segments are equal, iff their sources and targets are equal. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="44" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1aa4e1d8e0e5c088c5bf6769341bfb0188" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Segment_3&lt; Kernel &gt;::operator!=</definition>
        <argsstring>(const Segment_3&lt; Kernel &gt; &amp;q) const</argsstring>
        <name>operator!=</name>
        <qualifiedname>CGAL::Segment_3::operator!=</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Segment__3" kindref="compound">Segment_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>q</declname>
        </param>
        <briefdescription>
<para>Test for inequality. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="49" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1ae62f06fc5663553958b6ac6e43a1f2b2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::source</definition>
        <argsstring>() const</argsstring>
        <name>source</name>
        <qualifiedname>CGAL::Segment_3::source</qualifiedname>
        <briefdescription>
<para>returns the source of <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="55" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a2c1836447f8d482a3bb532f6411172c8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::target</definition>
        <argsstring>() const</argsstring>
        <name>target</name>
        <qualifiedname>CGAL::Segment_3::target</qualifiedname>
        <briefdescription>
<para>returns the target of <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="61" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a32d927b81402e94c18892d66995f8dc4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::min</definition>
        <argsstring>() const</argsstring>
        <name>min</name>
        <qualifiedname>CGAL::Segment_3::min</qualifiedname>
        <briefdescription>
<para>returns the point of <computeroutput>s</computeroutput> with smallest coordinate (lexicographically). </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="67" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a22bfd1b74be1dd757cfdc92a0b96e2c2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::max</definition>
        <argsstring>() const</argsstring>
        <name>max</name>
        <qualifiedname>CGAL::Segment_3::max</qualifiedname>
        <briefdescription>
<para>returns the point of <computeroutput>s</computeroutput> with largest coordinate (lexicographically). </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="73" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1aaa13a9c1657c0c7fc63881862e6e55b1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::vertex</definition>
        <argsstring>(int i) const</argsstring>
        <name>vertex</name>
        <qualifiedname>CGAL::Segment_3::vertex</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns source or target of <computeroutput>s</computeroutput>: <computeroutput>vertex(0)</computeroutput> returns the source, <computeroutput>vertex(1)</computeroutput> returns the target. </para>
        </briefdescription>
        <detaileddescription>
<para>The parameter <computeroutput>i</computeroutput> is taken modulo 2, which gives easy access to the other vertex. <variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="82" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a1e9efc24d4a6b4ebf226942e6c0465e0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::point</definition>
        <argsstring>(int i) const</argsstring>
        <name>point</name>
        <qualifiedname>CGAL::Segment_3::point</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>vertex(i)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="88" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a7133a8d8662623c4d6e75e7a7f89287c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Point_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::operator[]</definition>
        <argsstring>(int i) const</argsstring>
        <name>operator[]</name>
        <qualifiedname>CGAL::Segment_3::operator[]</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>vertex(i)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="94" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a6537e55b5ea951df2e233334efa03eeb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Kernel::FT</type>
        <definition>Kernel::FT CGAL::Segment_3&lt; Kernel &gt;::squared_length</definition>
        <argsstring>() const</argsstring>
        <name>squared_length</name>
        <qualifiedname>CGAL::Segment_3::squared_length</qualifiedname>
        <briefdescription>
<para>returns the squared length of <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="99" column="12"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a20d5c4bb7c9ad6a9a7ad034fc56587fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Vector__3" kindref="compound">Vector_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Vector_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::to_vector</definition>
        <argsstring>() const</argsstring>
        <name>to_vector</name>
        <qualifiedname>CGAL::Segment_3::to_vector</qualifiedname>
        <briefdescription>
<para>returns the vector <computeroutput>s.target()</computeroutput> - <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput><ref refid="classCGAL_1_1Segment__3_1ae62f06fc5663553958b6ac6e43a1f2b2" kindref="member">source()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="104" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a12d71919befb3b5d19a27db2117ca9f5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Direction__3" kindref="compound">Direction_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Direction_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::direction</definition>
        <argsstring>() const</argsstring>
        <name>direction</name>
        <qualifiedname>CGAL::Segment_3::direction</qualifiedname>
        <briefdescription>
<para>returns the direction from source to target. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="109" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a4ce4f6a8affa8b6514dfb4cef510c5e0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Segment__3" kindref="compound">Segment_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Segment_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::opposite</definition>
        <argsstring>() const</argsstring>
        <name>opposite</name>
        <qualifiedname>CGAL::Segment_3::opposite</qualifiedname>
        <briefdescription>
<para>returns a segment with source and target interchanged. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="115" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a387ee63bbf54df75cf5848f9aa693eae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Line__3" kindref="compound">Line_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Line_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::supporting_line</definition>
        <argsstring>() const</argsstring>
        <name>supporting_line</name>
        <qualifiedname>CGAL::Segment_3::supporting_line</qualifiedname>
        <briefdescription>
<para>returns the line <computeroutput>l</computeroutput> passing through <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Line <computeroutput>l</computeroutput> has the same orientation as segment <computeroutput>s</computeroutput>, that is from the source to the target of <computeroutput>s</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="122" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1ab87b7db9297627c745d1c06cb3492672" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Segment_3&lt; Kernel &gt;::is_degenerate</definition>
        <argsstring>() const</argsstring>
        <name>is_degenerate</name>
        <qualifiedname>CGAL::Segment_3::is_degenerate</qualifiedname>
        <briefdescription>
<para>segment <computeroutput>s</computeroutput> is degenerate, if source and target fall together. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="127" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1aa3ed985e2addf919f6eeba1c929fd40b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Segment_3&lt; Kernel &gt;::has_on</definition>
        <argsstring>(const Point_3&lt; Kernel &gt; &amp;p) const</argsstring>
        <name>has_on</name>
        <qualifiedname>CGAL::Segment_3::has_on</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Point__3" kindref="compound">Point_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>A point is on <computeroutput>s</computeroutput>, iff it is equal to the source or target of <computeroutput>s</computeroutput>, or if it is in the interior of <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="133" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1ad320c22d1172fbe38c544cdddbce5258" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Bbox__3" kindref="compound">Bbox_3</ref></type>
        <definition>Bbox_3 CGAL::Segment_3&lt; Kernel &gt;::bbox</definition>
        <argsstring>() const</argsstring>
        <name>bbox</name>
        <qualifiedname>CGAL::Segment_3::bbox</qualifiedname>
        <briefdescription>
<para>returns a bounding box containing <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><variablelist>
<varlistentry><term>Exactness</term></varlistentry>
<listitem><para>This construction is trivial and therefore always exact in <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>.</para>
</listitem>
</variablelist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="139" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Segment__3_1a03ff6d93bdecbb6e19bb781851726647" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Segment__3" kindref="compound">Segment_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt;</type>
        <definition>Segment_3&lt; Kernel &gt; CGAL::Segment_3&lt; Kernel &gt;::transform</definition>
        <argsstring>(const Aff_transformation_3&lt; Kernel &gt; &amp;t) const</argsstring>
        <name>transform</name>
        <qualifiedname>CGAL::Segment_3::transform</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Aff__transformation__3" kindref="compound">Aff_transformation_3</ref>&lt; <ref refid="classKernel" kindref="compound">Kernel</ref> &gt; &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>returns the segment obtained by applying <computeroutput>t</computeroutput> on the source and the target of <computeroutput>s</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Segment_3.h" line="145" column="11"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object <computeroutput>s</computeroutput> of the data type <computeroutput><ref refid="classCGAL_1_1Segment__3" kindref="compound">Segment_3</ref></computeroutput> is a directed straight line segment in the three-dimensional Euclidean space <formula id="30">$ \E^3$</formula>, that is a straight line segment <formula id="81">$ [p,q]$</formula> connecting two points <formula id="83">$ p,q \in
\R^3$</formula>. </para>
    </briefdescription>
    <detaileddescription>
<para>The segment is topologically closed, i.e. the end points belong to it. Point <computeroutput>p</computeroutput> is called the <emphasis>source</emphasis> and <computeroutput>q</computeroutput> is called the <emphasis>target</emphasis> of <computeroutput>s</computeroutput>. The length of <computeroutput>s</computeroutput> is the Euclidean distance between <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput>. Note that there is only a function to compute the square of the length, because otherwise we had to perform a square root operation which is not defined for all number types, which is expensive, and may not be exact.</para>
<para><variablelist>
<varlistentry><term>Is model of</term></varlistentry>
<listitem><para><computeroutput><ref refid="classKernel_1_1Segment__3" kindref="compound">Kernel::Segment_3</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classHashable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Hashable</ref></computeroutput> if <computeroutput><ref refid="classKernel" kindref="compound">Kernel</ref></computeroutput> is a cartesian kernel and if <computeroutput>Kernel::FT</computeroutput> is <computeroutput><ref refid="classHashable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Hashable</ref></computeroutput></para>
</listitem>
</variablelist>
</para>
    </detaileddescription>
    <location file="CGAL/Segment_3.h" line="21" column="1" bodyfile="CGAL/Segment_3.h" bodystart="21" bodyend="149"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Segment__3_1ad320c22d1172fbe38c544cdddbce5258" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>bbox</name></member>
      <member refid="classCGAL_1_1Segment__3_1a12d71919befb3b5d19a27db2117ca9f5" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>direction</name></member>
      <member refid="classCGAL_1_1Segment__3_1aa3ed985e2addf919f6eeba1c929fd40b" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>has_on</name></member>
      <member refid="classCGAL_1_1Segment__3_1ab87b7db9297627c745d1c06cb3492672" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>is_degenerate</name></member>
      <member refid="classCGAL_1_1Segment__3_1a22bfd1b74be1dd757cfdc92a0b96e2c2" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>max</name></member>
      <member refid="classCGAL_1_1Segment__3_1a32d927b81402e94c18892d66995f8dc4" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>min</name></member>
      <member refid="classCGAL_1_1Segment__3_1aa4e1d8e0e5c088c5bf6769341bfb0188" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>operator!=</name></member>
      <member refid="classCGAL_1_1Segment__3_1a8112f4621b334b119b1176241397a21c" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>operator==</name></member>
      <member refid="classCGAL_1_1Segment__3_1a7133a8d8662623c4d6e75e7a7f89287c" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>operator[]</name></member>
      <member refid="classCGAL_1_1Segment__3_1a4ce4f6a8affa8b6514dfb4cef510c5e0" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>opposite</name></member>
      <member refid="classCGAL_1_1Segment__3_1a1e9efc24d4a6b4ebf226942e6c0465e0" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>point</name></member>
      <member refid="classCGAL_1_1Segment__3_1aff6ed6df35e451f8341b697e2ff395b6" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>Segment_3</name></member>
      <member refid="classCGAL_1_1Segment__3_1ae62f06fc5663553958b6ac6e43a1f2b2" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>source</name></member>
      <member refid="classCGAL_1_1Segment__3_1a6537e55b5ea951df2e233334efa03eeb" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>squared_length</name></member>
      <member refid="classCGAL_1_1Segment__3_1a387ee63bbf54df75cf5848f9aa693eae" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>supporting_line</name></member>
      <member refid="classCGAL_1_1Segment__3_1a2c1836447f8d482a3bb532f6411172c8" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>target</name></member>
      <member refid="classCGAL_1_1Segment__3_1a20d5c4bb7c9ad6a9a7ad034fc56587fb" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>to_vector</name></member>
      <member refid="classCGAL_1_1Segment__3_1a03ff6d93bdecbb6e19bb781851726647" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>transform</name></member>
      <member refid="classCGAL_1_1Segment__3_1aaa13a9c1657c0c7fc63881862e6e55b1" prot="public" virt="non-virtual"><scope>CGAL::Segment_3</scope><name>vertex</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
