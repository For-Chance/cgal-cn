<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Arrangements"/><anchor id="index_1chapterArrangement_on_surface_2"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly></para>
<para><simplesect kind="authors"><para>Ron Wein, Eric Berberich, Efi Fogel, Dan Halperin, Michael Hemmer, Oren Salzman, and Baruch Zukerman</para>
</simplesect>
</para>
<sect1 id="index_1aos_sec-intro">
<title>Introduction</title>
<para>Geometric arrangements, or arrangements for short, are subdivisions of some space induced by geometric objects. <ref refid="index_1fig__aos_fig-simple_arr" kindref="member">fig__aos_fig-simple_arr</ref> shows an arrangement of two curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> in the plane. It has three faces<mdash/>two bounded faces <formula id="2">$f_1$</formula> and <formula id="3">$f_2$</formula> (filled with diagonal-stripe patterns) and an unbounded face. The arrangement has seven vertices<mdash/>four represent the endpoints of <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> (drawn as small discs), and three represent the intersection points of the two curves (drawn as small rings). The arrangement also has eight edges, each of which is a maximal portion of one curve not intersecting the other.</para>
<para><anchor id="index_1fig__aos_fig-simple_arr"/> <image type="html" name="simple_arr.png"></image>
 <image type="latex" name="simple_arr.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-simple_arr" kindref="member">fig__aos_fig-simple_arr</ref> <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Arrangements are not restricted to curves in the plane. There are useful arrangements in three and higher dimensions (these are not so easy to visualize) and they can be induced by geometric objects of any type, such as spheres, simplices, polytopes, or B<eacute/>zier surfaces. This package provides a data structure that represents a two-dimensional arrangement of curves embedded in an orientable parametric surface in three dimensional space, such as a plane, a cylinder, a sphere, a torus, or a surface homeomorphic to them. This package also provides operations that construct and manipulate such arrangements. Arrangements are ubiquitous in the computational-geometry literature and have many applications; see, e.g., <ref refid="citelist_1CITEREF_as-aa-00" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_cgal:bfhks-apsca-10" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_cgal:bfhmw-apsgf-10" kindref="member">[4]</ref>, and <ref refid="citelist_1CITEREF_cgal:h-a-04" kindref="member">[8]</ref>.</para>
<sect2 id="index_1aos_ssec-intro-sep">
<title>Separation of Topology and Geometry</title>
<para>The use of the generic programming paradigm enables a convenient separation of the topology and the geometry of data structures.In this context, we sometimes say <emphasis>combinatorics</emphasis> instead of topology, and say <emphasis>algebra</emphasis> or <emphasis>numerics</emphasis> instead of geometry. We always mean the same thing<mdash/>the separation of the abstract, graph-like structure (the topology) from the actual embedding in the plane (the geometry). This is a key aspect in the design of geometric software, and is put into practice, for example, in the design of CGAL polyhedra, CGAL triangulations, and our CGAL arrangements. This separation allows the convenient abstraction of algorithms and data structures in combinatorial and topological terms, regardless of the specific geometry of the objects at hand. This abstraction is realized through class and function templates that represent specific data structures and algorithmic frameworks, respectively. Consider the class template</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GeometryTraits,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Dcel&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref><sp/>{<sp/>...<sp/>};</highlight></codeline>
</programlisting></para>
<para>An instance of this template represents an arrangement embedded in the plane. When the template is instantiated, the <computeroutput>GeometryTraits</computeroutput> parameter must be substituted by a type that defines a set of geometric-object types, such as point and curve, and a set of operations on objects of these types (see Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>); the <computeroutput>Dcel</computeroutput> parameter must be substituted by a type that represents a doubly-connected edge list (DCEL) data structure. It defines types of topological objects, such as vertices, edges, and faces, and the operations required to maintain the incidence relations among objects of these types (see Section <ref refid="index_1aos_ssec-basic-dcel" kindref="member">Representation of Arrangements: The Dcel</ref>).</para>
<para>The class template <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> derives from the following class template:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GeometryTraits,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>TopologyTraits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref><sp/>{<sp/>...<sp/>};</highlight></codeline>
</programlisting></para>
<para>An instance of this template represents a two-dimensional arrangement embedded in a surface in three dimensional space. When the template is instantiated, the <computeroutput>GeometryTraits</computeroutput> parameter must be substituted as described above; the <computeroutput>TopologyTraits</computeroutput> parameter must be substituted by a type that deals with the topology of the surface (see Section <ref refid="index_1aos_sec-topol_traits" kindref="member">The Topology Traits</ref>). In particular, it maintains a representation of the arrangement graph embedded in the surface using a doubly-connected edge list (DCEL) data-structure suitable for the particular topology.</para>
<para>Several member functions and nested types defined in the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> derived class-template inherit their definitions from the base class-template <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput>; their semantics is equivalent in both class templates. The names of these member functions and nested types typically appear in the manual without any scope, as each of these class templates can serve as their scope. (As a matter of fact, the package provides additional class templates that represent two-dimensional arrangements, such as the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class template, which derives from the class template <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput>; these additional class templates also contain inherited definitions of the aforementioned member functions and nested types.)</para>
<para>An immediate advantage of the separation of the topology and the geometry of data structures is that users with limited expertise in computational geometry can employ the data structure with their own special type of objects. They must, however, supply the relevant traits class, which mainly involves algebraic computations. A traits class also encapsulates the number types used to represent coordinates of geometric objects and to carry out algebraic operations on them. It encapsulates the type of coordinate system used (e.g., Cartesian and homogeneous), and the geometric or algebraic computation methods themselves. The precise minimal sets of requirements the actual traits classes must conform to are organized as a hierarchy of concepts; see Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>.</para>
</sect2>
<sect2 id="index_1aos_ssec-intro-well_behaved">
<title>Well-Behaved Curves</title>
<para>What constitutes valid curves that can be handled by the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package is discussed in detail in Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>, where the models of the traits classes are described. However, when we cite combinatorial complexity bounds or bounds on the resources (i.e., running time and storage space) required by algorithms, we often postulate stricter assumptions on the input curves. The prevalent term in use is that the curves are <emphasis>well behaved</emphasis>, which may have different interpretations in different settings. If we are concerned with combinatorial complexity bounds for curves embedded in a two-dimensional surface, then the standard assumptions are that (i) each curve is non-self-intersecting (a so-called Jordan arc) and (ii) every pair of curves intersects in at most some constant number of points. For algorithmic purposes we need to require more since we assume that any operation on a small constant number of curves takes unit time. In this sense arcs of algebraic curves of degree bounded by a constant (namely the zero set of bivariate polynomials of constant maximum total degree) are well behaved. Naturally, what are typically considered well-behaved surfaces in <formula id="4">$\mathbb{R}^3$</formula> is even more complicated to state.</para>
<para>Remarks <orderedlist>
<listitem>
<para>From the complexity-bound perspective, most of the arrangements that we can deal with can be regarded as defined by well-behaved curves. Even though the package allows for self-intersecting curves, for most types each curve can be decomposed into a constant number of well-behaved curves, thus having no effect on the asymptotic bounds that we state. </para>
<para></para>
</listitem>
<listitem>
<para>One type of curves that we deal with is special in this sense: <emphasis>polylines</emphasis>, namely concatenations of an unlimited number of line segments; see Section <ref refid="index_1arr_sssectr_polylines" kindref="member">The Polyline Traits Class</ref>. A polyline is not well behaved, as it cannot be decomposed into a constant number of constant-descriptive complexity subcurves. Informative bounds for arrangements of polylines are expressed by other parameters in addition to the number of polylines, for example, the total number of segments in all the polylines together. The same holds for the more general type <emphasis>polycurve</emphasis>, which are piecewise curves that are not necessarily linear; see Section <ref refid="index_1arr_sssectr_polycurves" kindref="member">The Polycurve Traits Class</ref>. </para>
<para></para>
</listitem>
</orderedlist>
</para>
</sect2>
<sect2 id="index_1aos_ssec-intro-outline">
<title>Outline</title>
<para>In Section <ref refid="index_1aos_sec-basic" kindref="member">Basic Arrangements</ref> we provide the minimum material you need to know in order to use CGAL 2D arrangements in the plane. In Section <ref refid="index_1aos_sec-curved_surfaces" kindref="member">Arrangements on Curved Surfaces</ref> we provide additional material you need to know in order use CGAL 2D arrangements embedded in curved surfaces. Most of the succeeding material is oblivious to the type of the embedding surface. In Section <ref refid="index_1arr_secqueries" kindref="member">Issuing Queries on an Arrangement</ref> we show how queries on an arrangement can be issued. In Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref> we review some useful free (global) functions that operate on arrangements, the most important ones being the free insertion-functions. In Section <ref refid="index_1aos_sec-unbounded" kindref="member">Arrangements of Unbounded Curves</ref> we explain how to construct and manipulate arrangements of unbounded curves. Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref> contains detailed descriptions of the geometric traits concept hierarchy and the various geometric traits classes included in the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package. The different traits classes enables the construction and manipulation of arrangements of different families of curves. Naturally, here, the embedding surface plays a significant role. In Section <ref refid="index_1arr_ssecnotif" kindref="member">The Notification Mechanism</ref> we review the notification mechanism that allows external classes to keep track of the changes that an arrangement instance goes through. Section <ref refid="index_1arr_ssecex_dcel" kindref="member">Extending the DCEL</ref> explains how to extend the DCEL records, to store extra data with them, and to efficiently update this data. In Section <ref refid="index_1arr_ssecoverlay" kindref="member">Overlaying Arrangements</ref> we introduce the fundamental operation of overlaying two arrangements. Section <ref refid="index_1arr_ssecarr_with_hist" kindref="member">Storing the Curve History</ref> describes a class-template that extends the arrangement by storing additional history records with its curves. In Section <ref refid="index_1aos_sec-io" kindref="member">Input/Output Streams and Visualization</ref> we review the arrangement input/output functions. In Section <ref refid="index_1aos_sec-bgl" kindref="member">Adapting to Boost Graphs</ref> we describes how to apply the graph algorithms implemented in the Boost Graph Library to arrangement types. Finally, in Section <ref refid="index_1aos_sec-tips" kindref="member">How To Speed Up Your Computation</ref> we provide some tips that can be applied to expedite computation.</para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-basic">
<title>Basic Arrangements</title>
<para>We start with a formal definition of two-dimensional arrangements, and proceed with an introduction to the data structure used to represent the incidence relations among features of two-dimensional arrangements, namely, the <emphasis>doubly-connected edge list</emphasis>, or DCEL for short. In Section <ref refid="index_1aos_ssec-basic-arr_class" kindref="member">The Arrangement Class Template</ref> we describe a central component in the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package, namely, the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class-template, which can be used to represent arrangements in the plane.</para>
<sect2 id="index_1aos_ssec-basic-dcel">
<title>Representation of Arrangements: The Dcel</title>
<para>Given a set <formula id="5">$\mathcal{C}$</formula> of curves embedded in a two-dimensional surface, the <emphasis>arrangement</emphasis> <formula id="6">$\mathcal{A}(\mathcal{C})$</formula> is the subdivision of the surface into zero-dimensional, one-dimensional and two-dimensional cells,We use the term <emphasis>cell</emphasis> to describe the various dimensional entities in the induced subdivision. Sometimes, the term <emphasis>face</emphasis> is used for this purpose in the literature. However, we use the term <emphasis>face</emphasis> to describe a <emphasis>two-dimensional</emphasis> cell. called <emphasis>vertices</emphasis>, <emphasis>edges</emphasis> and <emphasis>faces</emphasis>, respectively, induced by the curves in <formula id="5">$\mathcal{C}$</formula>.</para>
<para>In our implementation we use a definition that slightly deviates from the standard definition above for practical reasons. The curves in <formula id="5">$\mathcal{C}$</formula> can intersect each other (a single curve may also be self-intersecting or may comprise several disconnected branches) and are not necessarily <formula id="7">$x$</formula>-monotone.A continuous planar curve <formula id="8">$c$</formula> is <emphasis> <formula id="7">$x$</formula>-monotone</emphasis> if every vertical line intersects it at most once. For example, a non-vertical line segment is always <formula id="7">$x$</formula>-monotone and so is the graph of any continuous function <formula id="9">$y = f(x)$</formula>. For convenience, we treat vertical line segments as <emphasis>weakly <formula id="7">$x$</formula>-monotone</emphasis>, as there exists a single vertical line that overlaps them. A circle of radius <formula id="10">$r$</formula> centered at <formula id="11">$(x_0, y_0)$</formula> is not <formula id="7">$x$</formula>-monotone, as the vertical line <formula id="12">$x
= x_0$</formula> intersects it at <formula id="13">$(x_0, y_0 - r)$</formula> and at <formula id="14">$(x_0, y_0 +
r)$</formula>. We construct a collection <formula id="15">$\mathcal{C}&apos;&apos;$</formula> of <formula id="7">$x$</formula>-monotone subcurves that are pairwise disjoint in their interiors in two steps as follows. First, we decompose each curve in <formula id="5">$\mathcal{C}$</formula> into maximal <formula id="7">$x$</formula>-monotone subcurves and possibly isolated points, obtaining the collection <formula id="16">$\mathcal{C}&apos;$</formula>. Note that an <formula id="7">$x$</formula>-monotone curve cannot be self-intersecting. Then, we decompose each curve in <formula id="16">$\mathcal{C}&apos;$</formula> into maximal connected subcurves not intersecting any other curve (or point) in <formula id="16">$\mathcal{C}&apos;$</formula> in its interior. The collection <formula id="15">$\mathcal{C}&apos;&apos;$</formula> contains isolated points, if the collection <formula id="16">$\mathcal{C}&apos;$</formula> contains such points. The arrangement induced by the collection <formula id="15">$\mathcal{C}&apos;&apos;$</formula> can be conveniently embedded as a planar graph, the vertices of which are associated with curve endpoints or with isolated points, and the edges of which are associated with subcurves. It is easy to see that the faces of <formula id="6">$\mathcal{A}(\mathcal{C})$</formula> are the same as the faces of <formula id="17">$\mathcal{A}(\mathcal{C}&apos;&apos;)$</formula>. There are possibly more vertices in <formula id="17">$\mathcal{A}(\mathcal{C}&apos;&apos;)$</formula> than in <formula id="6">$\mathcal{A}(\mathcal{C})$</formula><mdash/>the vertices where curves were cut into <formula id="7">$x$</formula>-monotone (non-intersecting) pieces; accordingly there may also be more edges in <formula id="17">$\mathcal{A}(\mathcal{C}&apos;&apos;)$</formula>. This graph can be represented using a <emphasis>doubly-connected edge list</emphasis> data-structure (DCEL), which consists of containers of vertices, edges and faces and maintains the incidence relations among these cells. It is one of a family of combinatorial data structures called <emphasis>halfedge data structures</emphasis> (Hds), which are edge-centered data structures capable of maintaining incidence relations among cells of, for example, planar subdivisions, polyhedra, or other orientable, two-dimensional surfaces embedded in a space of arbitrary dimension. Geometric interpretation is added by classes built on top of the halfedge data structure.</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>The <formula id="7">$x$</formula>-monotone curves of an arrangement are embedded in a rectangular two-dimensional area called the parameter space. The parameter space is defined as <formula id="18">$ X \times Y$</formula>, where <formula id="19">$ X$</formula> and <formula id="20">$ Y$</formula> are open, half-open, or closed intervals with endpoints in the compactified real line <formula id="21">$ \mathbb{R} \cup
\{-\infty,+\infty\}$</formula>. Let <formula id="22">$x_{\rm min}$</formula>, <formula id="23">$x_{\rm max}$</formula>, <formula id="24">$y_{\rm min}$</formula>, and <formula id="25">$y_{\rm max}$</formula> denote the endpoints of <formula id="26">$
X$</formula> and <formula id="20">$ Y$</formula>, respectively. We typically refer to these values as the left, right, bottom, and top sides of the boundary of the parameter space. If the parameter space is, for example, the entire compactified plane, as in the case of arrangements in the plane, <formula id="27">$x_{\rm min} = y_{\rm min} = -\infty$</formula> and <formula id="28">$x_{\rm max} = y_{\rm
max} = +\infty$</formula>; see Section <ref refid="index_1aos_sec-curved_surfaces" kindref="member">Arrangements on Curved Surfaces</ref> for more details.</para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
<para>The DCEL data-structure represents each edge using a pair of directed <emphasis>halfedges</emphasis>, one going from the <formula id="29">$xy$</formula>-lexicographically smaller (left) endpoint of the curve towards the <formula id="29">$xy$</formula>-lexicographically larger (right) endpoint, and the other, known as its <emphasis>twin</emphasis> halfedge, going in the opposite direction. As each halfedge is directed, it has a <emphasis>source</emphasis> vertex and a <emphasis>target</emphasis> vertex. Halfedges are used to separate faces, and to connect vertices, with the exception of <emphasis>isolated vertices</emphasis> (representing isolated points), which are disconnected. If a vertex <formula id="30">$v$</formula> is the target of a halfedge <formula id="31">$e$</formula>, we say that <formula id="30">$v$</formula> and <formula id="31">$e$</formula> are <emphasis>incident</emphasis> to each other. The halfedges incident to a vertex <formula id="30">$v$</formula> form a circular list sorted in a clockwise order around this vertex. (An isolated vertex has no incident halfedges.)</para>
<para>An <emphasis>edge</emphasis> of an arrangement is a maximal portion of a curve between two vertices of the arrangement. Each edge is represented in the DCEL by a pair of twin halfedges. Each halfedge <formula id="31">$e$</formula> stores a pointer to its <emphasis>incident face</emphasis>, which is the face lying to its left. Moreover, every halfedge is followed by another halfedge sharing the same incident face, such that the target vertex of the halfedge is the same as the source vertex of the next halfedge. The halfedges around faces form circular chains, such that all halfedges of a chain are incident to the same face and wind along its boundary. We call such a chain a <emphasis>connected component of the boundary</emphasis>, or <emphasis>CCB</emphasis> for short.</para>
<para>The unique CCB of halfedges winding in a counterclockwise orientation along a face boundary is referred to as the <emphasis>outer CCB</emphasis> of the face. For the time being let us consider only (i) arrangements of bounded curves, such that exactly one unbounded face exists in every arrangement, and (ii) arrangements embedded in the plane, such that every face has at most one outer CCB. The unbounded face does not have an outer boundary. Any other connected component of the boundary of the face is called a <emphasis>hole</emphasis>, or <emphasis>inner CCB</emphasis>, and can be represented as a circular chain of halfedges winding in a clockwise orientation around it. Note that a hole does not necessarily correspond to a face at all, as it may have no area, or alternatively it may contain several faces. Every face can have several inner CCBs in its interior, or may not contain inner CCBs at all. In addition, every face may contain isolated vertices in its interior. We distinguish between isolated vertices and holes even though, theoretically, the former are degenerate holes. See <ref refid="index_1fig__aos_fig-arr_segs" kindref="member">fig__aos_fig-arr_segs</ref> for an illustration of the various DCEL features. For more details on the DCEL data structure see <ref refid="citelist_1CITEREF_bkos-cgaa-00" kindref="member">[5]</ref> Chapter 2.</para>
<para><anchor id="index_1fig__aos_fig-arr_segs"/> <image type="html" name="arr_segs.png"></image>
 <image type="latex" name="arr_segs.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-arr_segs" kindref="member">fig__aos_fig-arr_segs</ref> An arrangement of interior-disjoint line segments with some of the DCEL records that represent it. The unbounded face <formula id="32">$ f_0$</formula> has a single connected component that forms a hole inside it, and this hole comprises of several faces. The halfedge <formula id="33">$ e$</formula> is directed from its source vertex <formula id="34">$ v_1$</formula> to its target vertex <formula id="35">$
v_2$</formula>. This edge, together with its twin <formula id="36">$ e&apos;$</formula>, correspond to a line segment that connects the points associated with <formula id="34">$ v_1$</formula> and <formula id="37">$ v_2$</formula> and separates the face <formula id="38">$ f_1$</formula> from <formula id="39">$ f_2$</formula>. The predecessor <formula id="40">$ e_{\rm prev}$</formula> and successor <formula id="41">$ e_{\rm next}$</formula> of <formula id="33">$ e$</formula> are part of the chain that form the outer boundary of the face <formula id="39">$ f_2$</formula>. The face <formula id="38">$ f_1$</formula> has a more complicated structure as it contains two holes in its interior: One hole consists of two adjacent faces <formula id="42">$ f_3$</formula> and <formula id="43">$ f_4$</formula>, while the other hole comprises of two edges. <formula id="38">$ f_1$</formula> also contains two isolated vertices <formula id="44">$ u_1$</formula> and <formula id="45">$ u_2$</formula> in its interior. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1aos_ssec-basic-arr_class">
<title>The Arrangement Class Template</title>
<para>One of the main components of the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package is the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template. An instance of this template is used to represent an arrangement embedded in the plane. The class template provides the interface needed to construct such arrangements, traverse them, and maintain them.</para>
<para>The design of the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package is guided by two aspects of modularity as follows: <itemizedlist>
<listitem>
<para>the separation of the representation of the arrangements and the various geometric algorithms that operate on them, and </para>
</listitem>
<listitem>
<para>the separation of the topological and geometric aspects of the two-dimensional subdivision. </para>
</listitem>
</itemizedlist>
</para>
<para>The latter separation is exhibited by the two template parameters of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template; their description follows.</para>
<para><itemizedlist>
<listitem>
<para>The <computeroutput>Traits</computeroutput> template-parameter should be substituted by a model of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and optionally additional geometry traits concepts. A model of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept defines the types of <formula id="7">$x$</formula>-monotone curves and two-dimensional points, namely <computeroutput><ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member">ArrangementBasicTraits_2::X_monotone_curve_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementBasicTraits__2_1a8cfc873dc62ce86f9479c4689845d4b3" kindref="member">ArrangementBasicTraits_2::Point_2</ref></computeroutput>, respectively, and supports basic geometric predicates on them. The instantiated traits class determines the family of planar curves that induce the arrangement.</para>
<para>In this section we always use <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> as our traits-class model in order to construct arrangements of line segments. In succeeding sections we also use <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> as our traits-class model. These two traits trade computation time and storage space. The latter stores the underlying line of every segment of the arrangement to expedite certain operations on the arrangement segments. In Section <ref refid="index_1aos_sec-unbounded" kindref="member">Arrangements of Unbounded Curves</ref> we use <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref></computeroutput> to construct arrangements of linear curves (i.e., lines, rays, and line segments). The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package contains several other traits classes that can handle other types of curves, such as polylines (continuous piecewise-linear curves), conic arcs, and arcs of rational functions. We exemplify the usage of these traits classes in Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>.</para>
<para></para>
</listitem>
<listitem>
<para>The <computeroutput>Dcel</computeroutput> template-parameter should be substituted by a class that models the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept, which is used to represent the topological layout of the arrangement. This parameter is substituted by <computeroutput>Arr_default_dcel&lt;Traits&gt;</computeroutput> by default, and we use this default value in this and in the following three sections. However, in many applications it is necessary to extend the DCEL features. This is done by substituting the <computeroutput>Dcel</computeroutput> parameter with a different type (typically, a different instance of the <computeroutput><ref refid="classCGAL_1_1Arr__dcel" kindref="compound">Arr_dcel</ref>&lt;&gt;</computeroutput> class template); see Section <ref refid="index_1arr_ssecex_dcel" kindref="member">Extending the DCEL</ref> for further explanations and examples. </para>
</listitem>
</itemizedlist>
</para>
<para>The function template <computeroutput>print_arrangement_size()</computeroutput> listed below, and defined in the header file <computeroutput>Arr_print.h</computeroutput>, prints out quantitative measures of a given arrangement. While in what follows it is used only by examples, it demonstrates well the use of the member functions <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a07afeb623d32ef12745c9b368233e4ea" kindref="member"><computeroutput>number_of_vertices()</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab8c9db7c49f1d4860cd47094a08a6779" kindref="member"><computeroutput>number_of_edges()</computeroutput></ref>, and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac8de48159182ed1dc27d508171c3adb7" kindref="member"><computeroutput>number_of_faces()</computeroutput></ref>, which return the number of vertices, edges, and faces of an arrangement, respectively.</para>
<para><anchor id="index_1lst_paz"/><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_arrangement_size(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Arrangement&amp;<sp/>arr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>size:\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>|V|<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>|E|<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>|F|<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>You can also obtain the number of halfedges of an arrangement using the member function <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ae4e63cf2763246726d5b705a45d2848f" kindref="member"><computeroutput>number_of_halfedges()</computeroutput></ref>. Recall that the number of halfedges is always twice the number of edges.</para>
<para><image type="html" name="triangle.png"></image>
 <image type="latex" name="triangle.png"></image>
</para>
<para>The simple program listed below constructs an arrangement of three connected line segments forming a triangle. It uses the <emphasis><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Cartesian</ref></emphasis> kernel with an integral-number type to instantiate the <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template. The resulting arrangement consists of two faces, a bounded triangular face and the unbounded face. Constructing and maintaining arrangements using limited-precision numbers, such as <computeroutput>int</computeroutput>, works properly only under severe restrictions, which in many cases render the program not very useful. In this example, however, the points are far apart, and constructions of new geometric objects do not occur. Thus, it is safe to use <computeroutput>int</computeroutput> after all. The program constructs an arrangement induced by three line segments that are pairwise disjoint in their interior, prints out the number of faces, and ends. It uses the <ref refid="group__PkgArrangementOnSurface2Insert_1ga25a2ae72727ec4c0680d20477bab7a1c" kindref="member"><computeroutput>insert()</computeroutput></ref> free-function, which inserts the segments into the arrangement; see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref>. It uses the member function <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac8de48159182ed1dc27d508171c3adb7" kindref="member"><computeroutput>number_of_faces()</computeroutput></ref> to obtain the number of faces (two in this case). We give more elaborate examples in the rest of this chapter. The programs in those examples rely on computing with numbers of arbitrary precision, which guarantees robust execution and correct results.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_non_caching_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">CGAL::Arr_non_caching_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits_2::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>1),<sp/>p2(1,<sp/>2),<sp/>p3(2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>cv[]<sp/>=<sp/>{Segment(p1,<sp/>p2),<sp/>Segment(p2,<sp/>p3),<sp/>Segment(p3,<sp/>p1)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>&amp;cv[0],<sp/>&amp;cv[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(cv)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment)]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssectraverse">
<title>Traversing the Arrangement</title>
<para>The simplest and most fundamental arrangement operations are the various traversal methods, which allow users to systematically go over the relevant features of the arrangement at hand.</para>
<para>As mentioned above, the arrangement is represented as a DCEL, which stores three containers of vertices, halfedges and faces; thus, the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template supplies iterator types for these containers, respectively. For example, if <computeroutput>arr</computeroutput> is an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object, the calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aa042e6d15902031a2df0f5c567deb48d" kindref="member"><computeroutput>arr.vertices_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a13b01c9fe13b28f40311bcf5df5f2372" kindref="member"><computeroutput>arr.vertices_end()</computeroutput></ref> return iterators of the nested <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac9e0d41a482a1ce382983871b8e7168d" kindref="member"><computeroutput>Vertex_iterator</computeroutput></ref> type that define the valid range of vertices of the arrangement <computeroutput>arr</computeroutput>. The value type of this iterator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>. Moreover, the vertex-iterator type is convertible to <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member"><computeroutput>Vertex_handle</computeroutput></ref>, which serves as a pointer to a vertex. As we show next, all functions related to arrangement features accept handle types as input parameters and return handle types as their output. See Chapter <ref refid="index_1Chapter_Handles_Ranges_and_Circulators" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Circulator.tag">Handles and Circulators</ref> for more information on CGAL handles.</para>
<para>In addition to the iterators for arrangement vertices, halfedges, and faces, the arrangement class also provides an iterator for edges, namely <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a90b95a65ca2ac31782a88f5ee8e83eba" kindref="member"><computeroutput>Edge_iterator</computeroutput></ref>. The value type of this iterator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>, which is the same as the value type of <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ae8c1944479e0e4cf89522c7dffacd12c" kindref="member"><computeroutput>Halfedge_iterator</computeroutput></ref>. The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a3ecce52c3dbd2d8ffd5910e5c6d2eaa2" kindref="member"><computeroutput>arr.edges_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab4e303e84da92938e0993f8fba5166d5" kindref="member"><computeroutput>arr.edges_end()</computeroutput></ref> return iterators that define the valid range of arrangement edges. This range consists of half the number of halfedges of the arrangement, as every twin halfedges has one representative in this range.</para>
<para>All iterator, circulatorA <emphasis>circulator</emphasis> is used to traverse a circular list, such as the list of halfedges incident to a vertex. and handle types also have non-mutable (<emphasis>const</emphasis>) counterparts. These non-mutable iterator types are useful for traversing an arrangement with the promise to keep it unchanged. For example, the arrangement has a non-constant member function called <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1aa042e6d15902031a2df0f5c567deb48d" kindref="member">Arrangement_on_surface_2::vertices_begin()</ref></computeroutput> that returns a <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac9e0d41a482a1ce382983871b8e7168d" kindref="member"><computeroutput>Vertex_iterator</computeroutput></ref> object and another const member function that returns a <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a6e3184096bbb26b96941800251966713" kindref="member"><computeroutput>Vertex_const_iterator</computeroutput></ref> object. In fact, all methods listed in this section that return an iterator, a circulator, or a handle have non-mutable counterparts. It should be noted that, for example, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member"><computeroutput>Vertex_handle</computeroutput></ref> can be readily converted into a <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member"><computeroutput>Vertex_const_handle</computeroutput></ref>, but not the other way around.</para>
<para>Conversions of non-mutable handles to the corresponding mutable handles are nevertheless possible. They can be performed using the overloaded member function <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab3ce8cfa533c872fee6496a100121bb4" kindref="member"><computeroutput>non_const_handle()</computeroutput></ref>. There are three variants that accept a non-mutable handle to a vertex, a halfedge, or a face, respectively. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab3ce8cfa533c872fee6496a100121bb4" kindref="member"><computeroutput>non_const_handle()</computeroutput></ref> can be issued only if the arrangement object <computeroutput>arr</computeroutput> is mutable; see, e.g., Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>.</para>
<sect3 id="index_1arr_sssectr_vertex">
<title>Traversal Methods for an Arrangement Vertex</title>
<para>A vertex <formula id="30">$v$</formula> of an arrangement induced by bounded curves is always associated with a geometric entity, namely with an <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aed833c3b69b94eae54994439d70a83a2" kindref="member"><computeroutput>Point_2</computeroutput></ref> object, which can be obtained by <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ac051fe1c2c008a0aee0cd7a578d03390" kindref="member"><computeroutput>v-&gt;point()</computeroutput></ref>, where <computeroutput>v</computeroutput> identifies a handle to <formula id="30">$v$</formula>.</para>
<para>The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ac7bd85bf195ed9e15b62ef591cd005a9" kindref="member"><computeroutput>v-&gt;is_isolated()</computeroutput></ref> determines whether the vertex <formula id="30">$v$</formula> is isolated or not. Recall that the halfedges incident to a non-isolated vertex, namely, the halfedges that share a common target vertex, form a circular list around this vertex. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ae8ee4823ad2d0e7a345f61c5778bc8a6" kindref="member"><computeroutput>v-&gt;incident_halfedges()</computeroutput></ref> returns a circulator of the nested type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a3418d290f692e88e110d4bb12b2c59d9" kindref="member"><computeroutput>Halfedge_around_vertex_circulator</computeroutput></ref> that enables the traversal of this circular list around a given vertex <formula id="30">$v$</formula> in a clockwise order. The value type of this circulator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>. By convention, the target of the halfedge is <formula id="30">$v$</formula>. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ac9e62a9b86fd210c1823e4efe243a50a" kindref="member"><computeroutput>v-&gt;degree()</computeroutput></ref> evaluates to the number of the halfedges incident to <formula id="30">$v$</formula>.</para>
<para>The function below prints all the halfedges incident to a given arrangement vertex (assuming that objects of the <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aed833c3b69b94eae54994439d70a83a2" kindref="member"><computeroutput>Point_2</computeroutput></ref> type can be inserted into the standard output using the <computeroutput>&lt;&lt;</computeroutput> operator). The arrangement type is the same as in the simple example above.</para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_incident_halfedges(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Vertex_const_handle<sp/>v)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(v-&gt;is_isolated())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vertex<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>is<sp/>isolated\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_around_vertex_const_circulator<sp/>first,<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>first<sp/>=<sp/>curr<sp/>=<sp/>v-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>neighbors<sp/>of<sp/>the<sp/>vertex<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>are:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If <formula id="30">$v$</formula> is an isolated vertex, the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ae090e4bb8f2f31c020e21d94816e7335" kindref="member"><computeroutput>v-&gt;face()</computeroutput></ref> can be used to obtain the face that contains <formula id="30">$v$</formula>.</para>
</sect3>
<sect3 id="index_1arr_sssectr_halfedge">
<title>Traversal Methods for an Arrangement Halfedge</title>
<para>A halfedge <formula id="31">$e$</formula> of an arrangement induced by bounded curves is associated with an <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ad7f12c4c83fa1d83a3f0d5ceb16c21e1" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> object, which can be obtained by <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a8fac59e117d57f6be9f2a5418e16bb0d" kindref="member"><computeroutput>e-&gt;curve()</computeroutput></ref>, where <computeroutput>e</computeroutput> identifies a handle to <formula id="31">$e$</formula>.</para>
<para>The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a200611c4a0eadf06eb2543149e0ab61e" kindref="member"><computeroutput>e-&gt;source()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a837ae4ea98dfde0332d6787c7543cf6c" kindref="member"><computeroutput>e-&gt;target()</computeroutput></ref> return handles to the halfedge&apos;s source-vertex and target-vertex, respectively. You can obtain a handle to the twin halfedge using <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1aead87f8c5f95770ed7cb2a6b9a43e23e" kindref="member"><computeroutput>e-&gt;twin()</computeroutput></ref>. Note that from the definition of halfedges in the <computeroutput>Dcel</computeroutput> structure, the following invariants always hold: <itemizedlist>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a8fac59e117d57f6be9f2a5418e16bb0d" kindref="member"><computeroutput>e-&gt;curve()</computeroutput></ref> is equivalent to <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a8fac59e117d57f6be9f2a5418e16bb0d" kindref="member"><computeroutput>e-&gt;twin()-&gt;curve()</computeroutput></ref>, </para>
</listitem>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a200611c4a0eadf06eb2543149e0ab61e" kindref="member"><computeroutput>e-&gt;source()</computeroutput></ref> is equivalent to <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a837ae4ea98dfde0332d6787c7543cf6c" kindref="member"><computeroutput>e-&gt;twin()-&gt;target()</computeroutput></ref>, and </para>
</listitem>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a837ae4ea98dfde0332d6787c7543cf6c" kindref="member"><computeroutput>e-&gt;target()</computeroutput></ref> is equivalent to <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a200611c4a0eadf06eb2543149e0ab61e" kindref="member"><computeroutput>e-&gt;twin()-&gt;source()</computeroutput></ref>. </para>
</listitem>
</itemizedlist>
</para>
<para>Every halfedge has an incident face that lies to its left, which can be obtained by <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a4af38ef2e7af77b265a86c8ea42972ef" kindref="member"><computeroutput>e-&gt;face()</computeroutput></ref>. Recall that a halfedge is always one link in a connected chain (CCB) of halfedges that share the same incident face. The <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a42adbd7d0eb22a3e1f7086b163e48fbb" kindref="member"><computeroutput>e-&gt;prev()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a14440bbd90d03a436279047a82e672cf" kindref="member"><computeroutput>e-&gt;next()</computeroutput></ref> calls return handles to the previous and next halfedges in the CCB, respectively.</para>
<para>As the CCB is a circular list of halfedges, it is only natural to traverse it using a circulator. Indeed <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a3cb46f49294d3d35c22cdf12e4bd8afc" kindref="member"><computeroutput>e-&gt;ccb()</computeroutput></ref> returns an <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a74c5102548a855c11d1606af503db209" kindref="member"><computeroutput>Ccb_halfedge_circulator</computeroutput></ref> object for traversing all halfedges along the connected component of <formula id="31">$e$</formula>. The value type of this circulator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>.</para>
<para>The function template <computeroutput>print_ccb()</computeroutput> listed below prints all <formula id="7">$x$</formula>-monotone curves along a given CCB (assuming that objects of the <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aed833c3b69b94eae54994439d70a83a2" kindref="member"><computeroutput>Point_2</computeroutput></ref> and the <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ad7f12c4c83fa1d83a3f0d5ceb16c21e1" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> types can be inserted into the standard output using the <computeroutput>&lt;&lt;</computeroutput> operator).</para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_ccb(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Ccb_halfedge_const_circulator<sp/>circ)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ccb_halfedge_const_circulator<sp/>curr<sp/>=<sp/>circ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_const_handle<sp/>he<sp/>=<sp/>curr-&gt;handle();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>circ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1arr_sssectr_face">
<title>Traversal Methods for an Arrangement Face</title>
<para>An <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object <computeroutput>arr</computeroutput> that identifies an arrangement of bounded curves always has a single unbounded face. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a82638900556c9b8b39d5c207b1a456da" kindref="member"><computeroutput>arr.unbounded_face()</computeroutput></ref> returns a handle to this face. Note that an empty arrangement contains nothing <emphasis>but</emphasis> the unbounded face.</para>
<para>Given a handle to a face <formula id="46">$f$</formula>, you can use the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1aa7cc822cc2a86b313532811d9df6dbb4" kindref="member"><computeroutput>f-&gt;is_unbounded()</computeroutput></ref> to determine whether the face <formula id="46">$f$</formula> is unbounded. Bounded faces have an outer CCB, and the <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a2fffc48e24aaa154122504983d771f1c" kindref="member"><computeroutput>outer_ccb()</computeroutput></ref> method returns a circulator for the halfedges along this CCB. Note that the halfedges along this CCB wind in a counterclockwise order around the outer boundary of the face.</para>
<para>A face can also contain disconnected components in its interior, namely, holes and isolated vertices. You can access these components as follows:</para>
<para><itemizedlist>
<listitem>
<para>You can obtain a pair of iterators of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a53de656d3ec315b4cf60f385a7667b55" kindref="member"><computeroutput>Hole_iterator</computeroutput></ref> that define the range of holes inside a face <formula id="46">$f$</formula> by calling <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1acd9525cd21bf2cd7404fddefe4ade7fb" kindref="member"><computeroutput>f-&gt;holes_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a64b500ed6fcd24544bc13dbde161b63a" kindref="member"><computeroutput>f-&gt;holes_end()</computeroutput></ref>. The value type of this iterator type is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a74c5102548a855c11d1606af503db209" kindref="member"><computeroutput>Ccb_halfedge_circulator</computeroutput></ref>, defining the CCB that winds in a clockwise order around a hole. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1ad926144c5444b2082eda4da7a5142ad2" kindref="member"><computeroutput>f-&gt;number_of_holes()</computeroutput></ref> return the number of holes in <formula id="46">$f$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a4471b967010989047b87beff6f3b7ce9" kindref="member"><computeroutput>f-&gt;isolated_vertices_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a961217cef87b4411eb8d82178ba00d83" kindref="member"><computeroutput>f-&gt;isolated_vertices_end()</computeroutput></ref> return iterators of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a4b8bee4d94c47a284f3f5e14b1327315" kindref="member"><computeroutput>Isolated_vertex_iterator</computeroutput></ref> that define the range of isolated vertices inside the face <formula id="46">$f$</formula>. The value type of this iterator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>The function <computeroutput>print_face()</computeroutput> listed below prints the outer and inner boundaries of a given face. It uses the function template <computeroutput>print_ccb()</computeroutput> listed above.</para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_face(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_const_handle<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>outer<sp/>boundary.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f-&gt;is_unbounded())<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Unbounded<sp/>face.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Outer<sp/>boundary:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_ccb(f-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>boundary<sp/>of<sp/>each<sp/>of<sp/>the<sp/>holes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>hi<sp/>=<sp/>f-&gt;holes_begin();<sp/>hi<sp/>!=<sp/>f-&gt;holes_end();<sp/>++hi)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Hole<sp/>#&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>index++<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_ccb(*hi);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>isolated<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>index<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>iv<sp/>=<sp/>f-&gt;isolated_vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iv<sp/>!=<sp/>f-&gt;isolated_vertices_end();<sp/>++iv)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Isolated<sp/>vertex<sp/>#&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>index++<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>iv-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The function <computeroutput>print_arrangement()</computeroutput> listed below prints the features of a given arrangement. The file <computeroutput>arr_print.h</computeroutput>, which can be found under the examples folder, includes the definitions of this function, as well as the definitions of all other functions listed in this section. This concludes the preview of the various traversal methods.</para>
<para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_arrangement<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&amp;<sp/>arr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_vertices()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertices:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;is_isolated())<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>Isolated.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>degree<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;degree()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>faces:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_face(fit);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="index_1arr_ssecmodify">
<title>Modifying the Arrangement</title>
<para>In this section we review the various member functions of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class that allow users to modify the topological structure of the arrangement through the introduction of new edges or vertices, or the modification or removal of existing edges and vertices.</para>
<para>The arrangement member-functions that insert new <formula id="7">$x$</formula>-monotone curves into the arrangement, thus enabling the construction of a two-dimensional surface subdivision, are rather specialized, as they assume that the interior of the inserted curve is disjoint from all existing arrangement vertices and edges, and in addition require apriori knowledge of the location of the inserted curve. Indeed, for most purposes it is more convenient to construct an arrangement using the free (global) insertion functions, which relax these restrictions. However, as these free functions are implemented in terms of the specialized insertion functions, we start by describing the fundamental functionality of the arrangement class, and describe the operation of the free functions in Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref>.</para>
</sect2>
<sect2 id="index_1arr_sssecmf_insert_cv">
<title>Inserting Pairwise Disjoint x-Monotone Curves</title>
<para>The most trivial functions that allow users to modify the arrangement are the specialized functions for the insertion of an <formula id="7">$x$</formula>-monotone curve the interior of which is disjoint from the interior of all other curves in the existing arrangement and does not contain any point of the arrangement. In addition, these functions require that the location of the curve in the arrangement be known.</para>
<para>The rather harsh restrictions on the inserted curves enable an efficient implementation. While inserting an <formula id="7">$x$</formula>-monotone curve, the interior of which is disjoint from all curves in the existing arrangement, is quite straightforward, as we show next, (efficiently) inserting a curve that intersects with the curves already in the arrangement is much more complicated and requires the application of nontrivial geometric algorithms. The decoupling of the topological arrangement representation from the various algorithms that operate on it dictates that the general insertion operations be implemented as free functions that operate on the arrangement and the inserted curve(s); see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref> for more details and examples.</para>
<para><anchor id="index_1fig__aos_fig-insert"/> <image type="html" name="insert.png"></image>
 <image type="latex" name="insert.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-insert" kindref="member">fig__aos_fig-insert</ref> Illustrations of the various specialized insertion procedures. The inserted <formula id="7">$x$</formula>-monotone curve is drawn as a dashed line, surrounded by two solid arrows that represent the pair of twin halfedges added to the DCEL. Existing vertices are shown as red discs, while new vertices are shown as blue discs. Existing halfedges that are affected by the insertion operations are drawn as dashed arrows. (a) Inserting a curve as a new hole inside the face <formula id="46">$f$</formula>. (b) Inserting a curve from an existing vertex <formula id="47">$u$</formula> that corresponds to one of its endpoints. (c) Inserting an <formula id="7">$x$</formula>-monotone curve, the endpoints of which correspond to existing vertices <formula id="48">$u_1$</formula> and <formula id="49">$u_2$</formula>. In this case, the new pair of halfedges closes a new face <formula id="50">$f&apos;$</formula>. The hole <formula id="51">$h_1$</formula>, which belonged to <formula id="46">$f$</formula> before the insertion, becomes a hole in this new face. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>When an <formula id="7">$x$</formula>-monotone curve is inserted into an existing arrangement, such that the interior of this curve is disjoint from the interiors of all curves in the arrangement, only the following three scenarios are possible, depending on the status of the endpoints of the inserted curve:</para>
<para><orderedlist>
<listitem>
<para>Neither curve endpoints correspond to any existing arrangement vertex. In this case we have to create two new vertices that correspond to the curve endpoints, respectively, and connect them using a pair of twin halfedges. This halfedge pair forms a new hole inside the face that contains the curve in its interior.</para>
<para></para>
</listitem>
<listitem>
<para>Exactly one endpoint corresponds to an existing arrangement vertex. (We distinguish between a vertex that corresponds to the left endpoint of the inserted curve and a vertex that corresponds to its right endpoint.) In this case we have to create a new vertex that corresponds to the other endpoint of the curve and to connect the two vertices by a pair of twin halfedges that form an &quot;antenna&quot; emanating from the boundary of an existing connected component. (Note that if the existing vertex is isolated, we need to form a new hole inside the face that contains this vertex, essentially falling back to the handling of the previous case, naturally, skipping the creation of the existing vertex.)</para>
<para></para>
</listitem>
<listitem>
<para>Both endpoints correspond to existing arrangement vertices. In this case we connect these vertices using a pair of twin halfedges. (If one or both vertices are isolated, we fall back to the handling of the first or second case, respectively, naturally, skipping the creation of the existing vertices.) The two following subcases may occur:</para>
<para><itemizedlist>
<listitem>
<para>Two disconnected components are merged into a single connected component (as is the case with the segment <formula id="52">$s_1$</formula> in the figure below).</para>
<para></para>
</listitem>
<listitem>
<para>A new face, which is split from an existing arrangement face, is created (as is the case with the segment <formula id="53">$s_2$</formula> in the figure below). In this case we also have to examine the holes and isolated vertices in the existing face and move the relevant ones inside the new face.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
</listitem>
</orderedlist>
</para>
<para><image type="html" name="connect_comp.png"></image>
 <image type="latex" name="connect_comp.png"></image>
</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class offers insertion functions that perform the special insertion procedures listed above, namely, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a622e04b98c5d0ac773c0a1b6da94b242" kindref="member"><computeroutput>insert_in_face_interior()</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member"><computeroutput>insert_from_left_vertex()</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1f3b1ceca5219900301e4eefd9f80bd0" kindref="member"><computeroutput>insert_from_right_vertex()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a7f2201fbb9015ddbbd22b7704e958e24" kindref="member"><computeroutput>insert_at_vertices()</computeroutput></ref>. The first function accepts an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> and an arrangement face <formula id="46">$f$</formula> that contains this curve in its interior. The other functions accept an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> and handles to the existing vertices that correspond to the curve endpoint(s). Each of the four functions returns a handle to one of the twin halfedges that have been created; more precisely:</para>
<para><itemizedlist>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a622e04b98c5d0ac773c0a1b6da94b242" kindref="member"><computeroutput>insert_in_face_interior(c, f)</computeroutput></ref> returns a handle to the halfedge directed from the left endpoint of <formula id="8">$c$</formula> towards the vertex corresponding to its right endpoint.</para>
<para></para>
</listitem>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member"><computeroutput>insert_from_left_vertex(c, v)</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1f3b1ceca5219900301e4eefd9f80bd0" kindref="member"><computeroutput>insert_from_right_vertex(c, v)</computeroutput></ref> each returns a handle to the halfedge, the source of which is the vertex <formula id="30">$v$</formula>, and the target of which is the new vertex that has just been created.</para>
<para></para>
</listitem>
<listitem>
<para><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a7f2201fbb9015ddbbd22b7704e958e24" kindref="member"><computeroutput>insert_at_vertices(c, v1, v2)</computeroutput></ref> returns a handle to the halfedge directed from <formula id="54">$v_1$</formula> to <formula id="55">$v_2$</formula>.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para><anchor id="index_1fig__aos_fig-edge_insertion"/> <image type="html" name="edge_insertion.png"></image>
 <image type="latex" name="edge_insertion.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-edge_insertion" kindref="member">fig__aos_fig-edge_insertion</ref> The arrangement of the line segments <formula id="56">$s_1, \ldots, s_5$</formula> constructed in <ref refid="Arrangement_on_surface_2_2edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_insertion.cpp</ref>. The arrows mark the direction of the halfedges returned from the various insertion functions. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The program below demonstrates the usage of the four specialized insertion functions. It creates an arrangement of five line segments <formula id="56">$s_1, \ldots, s_5$</formula>, as depicted in <ref refid="index_1fig__aos_fig-edge_insertion" kindref="member">fig__aos_fig-edge_insertion</ref>. Notice that in all figures in the rest of this chapter the coordinate axes are drawn only for illustrative purposes and are <emphasis>not</emphasis> part of the arrangement. The first line segment <formula id="52">$s_1$</formula> is inserted in the interior of the unbounded face, while the four succeeding line segments <formula id="57">$s_2, \ldots, s_5$</formula> are inserted using the vertices created by the insertion of preceding segments. The arrows in the figure mark the direction of the halfedges <formula id="58">$e_1, \ldots, e_5$</formula> returned from the insertion functions. The resulting arrangement consists of three faces, where the two bounded faces form together a hole in the unbounded face.</para>
<para>Two header files are included in the code in order to make this and the following examples more compact. The file <computeroutput>arr_inexact_construction_segments.h</computeroutput> is listed immediately after the program. The file <computeroutput>arr_print.h</computeroutput> is introduced in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_insertion.cpp</ref> <programlisting filename="Arrangement_on_surface_2/edge_insertion.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>using<sp/>the<sp/>simple<sp/>edge-insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>3),<sp/>p2(3,<sp/>5),<sp/>p3(5,<sp/>3),<sp/>p4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(p1,<sp/>p2),<sp/>s2(p2,<sp/>p3),<sp/>s3(p3,<sp/>p4),<sp/>s4(p4,<sp/>p1),<sp/>s5(p1,<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>e1-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v3<sp/>=<sp/>e2-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>v3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v4<sp/>=<sp/>e3-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s4,<sp/>v4,<sp/>v1);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>return<sp/>e4</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s5,<sp/>v1,<sp/>v3);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>return<sp/>e5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The statements below define the types for arrangements of line segments common to all examples that do not construct new geometric objects. They are kept in the header file <computeroutput>arr_inexact_construction_segments.h</computeroutput>. In these examples the <computeroutput>Traits</computeroutput> parameter of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits, Dcel&gt;</computeroutput> class template is substituted by an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template. The <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> class template is instantiated with the predefined kernel that evaluates predicates in an exact manner, but constructs geometric objects in an inexact manner, as none of these examples construct new geometric objects. In the remaining examples the traits class-template is instantiated with a kernel that evaluates predicates and constructs geometric objects, both in an exact manner.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_non_caching_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">CGAL::Arr_non_caching_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_sssecmf_iso_verts">
<title>Manipulating Isolated Vertices</title>
<para>Isolated points are simpler geometric entities than curves, and indeed the member functions that manipulate them are easier to understand.</para>
<para>The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a622e04b98c5d0ac773c0a1b6da94b242" kindref="member"><computeroutput>arr.insert_in_face_interior(p, f)</computeroutput></ref> inserts an isolated point <formula id="59">$p$</formula>, located in the interior of a given face <formula id="60">$ f$</formula>, into the arrangement and returns a handle to the arrangement vertex associated with <formula id="59">$p$</formula> it has created. Naturally, this function has a precondition that <formula id="59">$p$</formula> is really an isolated point; namely it does not coincide with any existing arrangement vertex and does not lie on any edge. As mentioned in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref>, it is possible to obtain the face containing an isolated vertex calling the member function <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ae090e4bb8f2f31c020e21d94816e7335" kindref="member">Arrangement_on_surface_2::Vertex::face()</ref></computeroutput>. The member function <computeroutput>Arrangement_on_surface_2::remove_isolated_vertex(Vertex_handle v)</computeroutput> accepts a handle to an isolated vertex and removes it from the arrangement.</para>
<para><anchor id="index_1fig__aos_fig-isolated_vertices"/> <image type="html" name="isolated_vertices.png"></image>
 <image type="latex" name="isolated_vertices.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-isolated_vertices" kindref="member">fig__aos_fig-isolated_vertices</ref> An arrangement of line segments containing three isolated vertices, as constructed in <ref refid="Arrangement_on_surface_2_2isolated_vertices_8cpp-example" kindref="compound">Arrangement_on_surface_2/isolated_vertices.cpp</ref>. The vertices <formula id="49">$u_2$</formula> and <formula id="61">$u_3$</formula> are eventually removed from the arrangement. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following program demonstrates the usage of the arrangement member-functions for manipulating isolated vertices. It first inserts three isolated vertices, <formula id="48">$u_1$</formula>, <formula id="49">$u_2$</formula>, and <formula id="61">$u_3$</formula>, located inside the unbounded face of the arrangement. Then, it inserts four line segments <formula id="62">$s_1, \ldots, s_4$</formula>, that form a square hole inside the unbounded face (see <ref refid="index_1fig__aos_fig-edge_insertion" kindref="member">fig__aos_fig-edge_insertion</ref> for an illustration). Finally, it traverses the vertices and removes those isolated vertices that are still contained in the unbounded face ( <formula id="49">$u_2$</formula> and <formula id="61">$u_3$</formula> in this case):</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2isolated_vertices_8cpp-example" kindref="compound">Arrangement_on_surface_2/isolated_vertices.cpp</ref> <programlisting filename="Arrangement_on_surface_2/isolated_vertices.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>with<sp/>isolated<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>isolated<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_handle<sp/>uf<sp/>=<sp/>arr.unbounded_face();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(3,<sp/>3),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(1,<sp/>5),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(Point(5,<sp/>5),<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>four<sp/>segments<sp/>that<sp/>form<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>3),<sp/>p2(3,<sp/>5),<sp/>p3(5,<sp/>3),<sp/>p4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(p1,<sp/>p2),<sp/>s2(p2,<sp/>p3),<sp/>s3(p3,<sp/>p4),<sp/>s4(p4,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>uf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>e1-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v3<sp/>=<sp/>e2-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>v3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v4<sp/>=<sp/>e3-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s4,<sp/>v4,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>isolated<sp/>vertices<sp/>located<sp/>in<sp/>the<sp/>unbounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement::Vertex_iterator<sp/>iter<sp/>=<sp/>arr.vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(iter<sp/>!=<sp/>arr.vertices_end())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Keep<sp/>an<sp/>iterator<sp/>to<sp/>the<sp/>next<sp/>vertex,<sp/>as<sp/>curr<sp/>might<sp/>be<sp/>deleted.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement::Vertex_iterator<sp/>curr<sp/>=<sp/>iter<sp/>++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(curr-&gt;is_isolated()<sp/>&amp;&amp;<sp/>curr-&gt;face()<sp/>==<sp/>uf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>arr.remove_isolated_vertex(curr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_sssecmf_halfedges">
<title>Manipulating Halfedges</title>
<para>While reading the previous subsection you learned how to insert new points that induce isolated vertices into the arrangement. You may wonder now how you can insert a new point that lies on an <formula id="7">$x$</formula>-monotone curve that is associated with existing arrangement edge.</para>
<para>The introduction of a vertex, the geometric mapping of which is a point <formula id="59">$p$</formula> that lies on an <formula id="7">$x$</formula>-monotone curve, requires the splitting of the curve in its interior at <formula id="59">$p$</formula>. The two resulting subcurves induce two new edges, respectively. In general, the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template relies on the geometry traits to perform such a split. As a matter of fact, it relies on the geometry traits to perform all geometric operations. To insert a point <formula id="59">$p$</formula> that lies on an <formula id="7">$x$</formula>-monotone curve associated with an existing edge <formula id="31">$e$</formula> into the arrangement <formula id="63">$\mathcal{A}$</formula>, you must first construct the two curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula>, which are the two subcurves that result from splitting the <formula id="7">$x$</formula>-monotone curve associated with the edge <formula id="31">$e$</formula> at <formula id="59">$p$</formula>. Then, you have to issue the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a2247def3072f9c94c659c68c55388dee" kindref="member"><computeroutput>arr.split_edge(he, c1, c2)</computeroutput></ref>, where <computeroutput>arr</computeroutput> identifies the arrangement <formula id="63">$\mathcal{A}$</formula> and <computeroutput>he</computeroutput> is a handle to one of the two halfedges that represent the edge <formula id="31">$e$</formula>. The function splits the two halfedges that represent <formula id="31">$e$</formula> into two pairs of halfedges, respectively. Two new halfedges are incident to the new vertex <formula id="30">$v$</formula> associated with <formula id="59">$p$</formula>. The function returns a handle to the new halfedge, the source of which is the source vertex of the halfedge handled by <computeroutput>he</computeroutput>, and the target of which is the new vertex <formula id="30">$v$</formula>.</para>
<para>The reverse operation is also possible. Consider a vertex <formula id="30">$v$</formula> of degree <formula id="64">$2$</formula> that has two incident edges <formula id="65">$e_1$</formula> and <formula id="66">$e_2$</formula> associated with two curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula>, respectively, such that the union of <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> results in a single continuous <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> of the type supported by the traits class in use. To merge the edges <formula id="65">$e_1$</formula> and <formula id="66">$e_2$</formula> into a single edge associated with the curve <formula id="8">$c$</formula>, essentially removing the vertex <formula id="30">$v$</formula> from the arrangement identified by <computeroutput>arr</computeroutput>, you need to issue the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a21ad366a7eca1b0b6494e86162b661b6" kindref="member"><computeroutput>arr.merge_edge(he1,
he2, c)</computeroutput></ref>, where <computeroutput>he1</computeroutput> and <computeroutput>he2</computeroutput> are handles to halfedges representing <formula id="65">$e_1$</formula> and <formula id="66">$e_2$</formula>, respectively.</para>
<para>Finally, the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a89618f53b378427e38b7d68fb9f86873" kindref="member"><computeroutput>remove_edge(he)</computeroutput></ref> removes the edge <formula id="31">$e$</formula> from the arrangement, where <computeroutput>he</computeroutput> is a handle to one of the two halfedges that represents <formula id="31">$e$</formula>. Note that this operation is the reverse of an insertion operation, so it may cause a connected component to split into two, or two faces to merge into one, or a hole to disappear. By default, if the removal of <formula id="31">$e$</formula> causes one of its end vertices to become isolated, this vertex is removed as well. However, you can control this behavior and choose to keep the isolated vertices by supplying additional Boolean flags to <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a89618f53b378427e38b7d68fb9f86873" kindref="member"><computeroutput>remove_edge()</computeroutput></ref> indicating whether the source or the target vertices are to be removed should they become isolated.</para>
<para><anchor id="index_1fig__aos_fig-edge_manipulation"/> <image type="html" name="edge_manipulation.png"></image>
 <image type="latex" name="edge_manipulation.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-edge_manipulation" kindref="member">fig__aos_fig-edge_manipulation</ref> The three steps of the example program <ref refid="Arrangement_on_surface_2_2edge_manipulation_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation.cpp</ref>. In Step (a) it constructs an arrangement of four line segments. In Step (b) the edges <formula id="65">$e_1$</formula> and <formula id="66">$e_2$</formula> are split, and the split points are connected with a new segment <formula id="67">$s$</formula> that is inserted into the arrangement. This operation is undone in Step (c), where <formula id="31">$e$</formula> is removed from the arrangement, rendering its end vertices <formula id="48">$u_1$</formula> and <formula id="49">$u_2$</formula> redundant. We therefore remove these vertices by merging their incident edges and go back to the arrangement depicted in (a). <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example program shows how the edge-manipulation functions can be used. The program works in three steps, as demonstrated in <ref refid="index_1fig__aos_fig-isolated_vertices" kindref="member">fig__aos_fig-isolated_vertices</ref>. Note that the program uses the fact that <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a2247def3072f9c94c659c68c55388dee" kindref="member"><computeroutput>split_edge()</computeroutput></ref> returns one of the new halfedges (after the split) that has the same direction as the original halfedge (the first parameter of the function) and is directed towards the split point. Thus, it is easy to identify the vertices <formula id="48">$u_1$</formula> and <formula id="49">$u_2$</formula> associated with the split points.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_manipulation_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation.cpp</ref> <programlisting filename="Arrangement_on_surface_2/edge_manipulation.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>edge-manipulation<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step<sp/>(a)---construct<sp/>a<sp/>rectangular<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>q1(1,<sp/>3),<sp/>q2(3,<sp/>5),<sp/>q3(5,<sp/>3),<sp/>q4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s4(q1,<sp/>q2),<sp/>s1(q2,<sp/>q3),<sp/>s3(q3,<sp/>q4),<sp/>s2(q4,<sp/>q1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_in_face_interior(s2,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e2<sp/>=<sp/>e2-&gt;twin();<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>we<sp/>wish<sp/>e2<sp/>to<sp/>be<sp/>directed<sp/>from<sp/>right<sp/>to<sp/>left</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s3,<sp/>e1-&gt;target(),<sp/>e2-&gt;source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s4,<sp/>e2-&gt;target(),<sp/>e1-&gt;source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>step<sp/>(a):\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step<sp/>(b)---split<sp/>e1<sp/>and<sp/>e2<sp/>and<sp/>connect<sp/>the<sp/>split<sp/>points<sp/>with<sp/>a<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(4,4),<sp/>p2(2,2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1_1(q2,<sp/>p1),<sp/>s1_2(p1,<sp/>q3),<sp/>s2_1(q4,<sp/>p2),<sp/>s2_2(p2,<sp/>q1),<sp/>s(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e1<sp/>=<sp/>arr.split_edge(e1,<sp/>s1_1,<sp/>s1_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>e2<sp/>=<sp/>arr.split_edge(e2,<sp/>s2_1,<sp/>s2_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e<sp/>=<sp/>arr.insert_at_vertices(s,<sp/>e1-&gt;target(),<sp/>e2-&gt;target());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>step<sp/>(b):&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Step<sp/>(c)---remove<sp/>the<sp/>edge<sp/>e<sp/>and<sp/>merge<sp/>e1<sp/>and<sp/>e2<sp/>with<sp/>their<sp/>successors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.remove_edge(e);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.merge_edge(e1,<sp/>e1-&gt;next(),<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.merge_edge(e2,<sp/>e2-&gt;next(),<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>step<sp/>(c):\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The member functions <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aa34dd4faba726f8d8f912b48dc239e5d" kindref="member"><computeroutput>modify_vertex()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a04ddf22219d330f989d39beca666f1b9" kindref="member"><computeroutput>modify_edge()</computeroutput></ref> modify the geometric mappings of existing features of the arrangement. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aa34dd4faba726f8d8f912b48dc239e5d" kindref="member"><computeroutput>arr.modify_vertex(v, p)</computeroutput></ref> accepts a handle to a vertex <formula id="30">$v$</formula> and a reference to a point <formula id="59">$p$</formula>, and sets <formula id="59">$p$</formula> to be the point associated with the vertex <formula id="30">$v$</formula>. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a04ddf22219d330f989d39beca666f1b9" kindref="member"><computeroutput>arr.modify_edge(he,
c)</computeroutput></ref> accepts a handle to one of the two halfedges that represent an edge <formula id="31">$e$</formula> and a reference to a curve <formula id="8">$c$</formula>, and sets <formula id="8">$c$</formula> to be the <formula id="7">$x$</formula>-monotone curve associated with <formula id="31">$e$</formula>. (Note that both halfedges are modified; that is, both expressions <computeroutput>e-&gt;curve()</computeroutput> and <computeroutput>e-&gt;twin()-&gt;curve()</computeroutput> evaluate to <formula id="8">$c$</formula> after the modification.) These functions have preconditions that <formula id="59">$p$</formula> is geometrically equivalent to <computeroutput>v-&gt;point()</computeroutput> and <formula id="8">$c$</formula> is equivalent to <computeroutput>e-&gt;curve()</computeroutput>, respectively.Roughly speaking, two curves are equivalent iff they have the same graph. In Section <ref refid="index_1aos_sssec-geom_traits-concepts_basic" kindref="member">The Basic Concept</ref> we give a formal definition of curves and curve equivalence. If these preconditions are not met, the corresponding operation may invalidate the structure of the arrangement. At first glance it may seem as if these two functions are of little use. However, you should keep in mind that there may be extraneous data (probably non-geometric) associated with the point objects or with the curve objects, as defined by the traits class. With these two functions you can modify this data; see more details in Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>. In addition, you can use these functions to replace a geometric object (a point or a curve) with an equivalent object that has a more compact representation. For example, if we use some simple rational-number type to represent the point coordinates, we can replace the point <formula id="68">$(\frac{20}{40},
\frac{99}{33})$</formula> associated with some vertex <formula id="30">$v$</formula> with an equivalent point with normalized coordinates, namely <formula id="69">$(\frac{1}{2},
3)$</formula>.</para>
</sect2>
<sect2 id="index_1arr_sssecadv_insert">
<title>Advanced Insertion Functions</title>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para><table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="pred_around_vertex.png"></image>
 <image type="latex" name="pred_around_vertex.png"></image>
  </para>
</entry><entry thead="no"><para></para>
<para>Assume that the specialized insertion function <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member"><computeroutput>insert_from_left_vertex(c, v)</computeroutput></ref> is given a curve <formula id="8">$c$</formula>, the left endpoint of which is already associated with a non-isolated vertex <formula id="30">$v$</formula>. Namely, <formula id="30">$v$</formula> has already several incident halfedges. It is necessary in this case to locate the exact place for the new halfedge mapped to the inserted new curve <formula id="8">$c$</formula> in the circular list of halfedges incident to <formula id="30">$v$</formula>. More precisely, in order to complete the insertion, it is necessary to locate the halfedge <formula id="70">$e_{\mathrm{pred}}$</formula> directed toward <formula id="30">$v$</formula>, such that <formula id="8">$c$</formula> is located between the curves associated with <formula id="70">$e_{\mathrm{pred}}$</formula> and the next halfedge in the clockwise order in the circular list of halfedges around <formula id="30">$v$</formula>; see <ref refid="index_1fig__aos_fig-insert" kindref="member">fig__aos_fig-insert</ref>. This search may take <formula id="71">$O(d)$</formula> time, where <formula id="72">$d$</formula> is the degree of the vertex <formula id="30">$v$</formula>. We can store the handles to the halfedges incident to <formula id="30">$v$</formula> in an efficient search structure to obtain <formula id="73">$O(\log d)$</formula> access time. However, as <formula id="72">$d$</formula> is usually very small, this may lead to a waste of storage space without a meaningful improvement in running time in practice. However, if the halfedge <formula id="70">$e_{\mathrm{pred}}$</formula> is known in advance, the insertion can be carried out in constant time, and without performing any geometric comparisons.   </para>
</entry></row>
</table>
</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class provides advanced versions of the specialized insertion functions for a curve <formula id="8">$c$</formula>, namely, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member"><computeroutput>insert_from_left_vertex(c, he_pred)</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1f3b1ceca5219900301e4eefd9f80bd0" kindref="member"><computeroutput>insert_from_right_vertex(c, he_pred)</computeroutput></ref>. These functions accept a halfedge <formula id="70">$e_{\mathrm{pred}}$</formula> as specified above, instead of a handle to a vertex <formula id="30">$v$</formula>. They are more efficient, as they take constant time and do not perform any geometric operations. Thus, you should use them when the halfedge <formula id="70">$e_{\mathrm{pred}}$</formula> is known. In cases where the vertex <formula id="30">$v$</formula> is isolated or the predecessor halfedge for the newly inserted curve is not known, the simpler versions of these insertion functions should be used. Similarly, the member function <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a7f2201fbb9015ddbbd22b7704e958e24" kindref="member"><computeroutput>insert_at_vertices()</computeroutput></ref> is overloaded with two additional versions as follows. One accepts two handles to the two predecessor halfedges around the two vertices <formula id="54">$v_1$</formula> and <formula id="55">$v_2$</formula>, respectively, that correspond to the curve endpoints. The other one accepts a handle to one vertex and a handle to the predecessor halfedge around the other vertex.</para>
<para><anchor id="index_1fig__aos_fig-special_edge_insertion"/> <image type="html" name="special_edge_insertion.png"></image>
 <image type="latex" name="special_edge_insertion.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-special_edge_insertion" kindref="member">fig__aos_fig-special_edge_insertion</ref> An arrangement of line segments, as constructed in <ref refid="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/special_edge_insertion.cpp</ref>. Note that <formula id="74">$p_0$</formula> is initially inserted as an isolated point and later on connected to the other four vertices. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following program shows how to construct the arrangement depicted in <ref refid="index_1fig__aos_fig-special_edge_insertion" kindref="member">fig__aos_fig-special_edge_insertion</ref> using the specialized insertion functions that accept predecessor halfedges:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/special_edge_insertion.cpp</ref> <programlisting filename="Arrangement_on_surface_2/special_edge_insertion.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>using<sp/>the<sp/>specialized<sp/>edge-insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p0(3,<sp/>3),<sp/>p1(1,<sp/>3),<sp/>p2(3,<sp/>5),<sp/>p3(5,<sp/>3),<sp/>p4(3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(p1,<sp/>p2),<sp/>s2(p2,<sp/>p3),<sp/>s3(p3,<sp/>p4),<sp/>s4(p4,<sp/>p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s5(p1,<sp/>p0),<sp/>s6(p0,<sp/>p3),<sp/>s7(p4,<sp/>p0),<sp/>s8(p0,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v0<sp/>=<sp/>arr.insert_in_face_interior(p0,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_from_left_vertex(s2,<sp/>e1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e3<sp/>=<sp/>arr.insert_from_right_vertex(s3,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e4<sp/>=<sp/>arr.insert_at_vertices(s4,<sp/>e3,<sp/>e1-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e5<sp/>=<sp/>arr.insert_at_vertices(s5,<sp/>e1-&gt;twin(),<sp/>v0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e6<sp/>=<sp/>arr.insert_at_vertices(s6,<sp/>e5,<sp/>e3-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s7,<sp/>e4-&gt;twin(),<sp/>e6-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_at_vertices(s8,<sp/>e5,<sp/>e2-&gt;twin());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>It is possible to perform even more refined operations on an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object given specific topological information. As most of these operations are very fragile and perform no precondition testing on their input in order to gain efficiency, they are not included in the public interface of the arrangement class. Instead, the <computeroutput><ref refid="classCGAL_1_1Arr__accessor" kindref="compound">Arr_accessor</ref>&lt;Arrangement&gt;</computeroutput> class allows access to these internal arrangement operations; see more details in the Reference Manual. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect2>
</sect1>
<sect1 id="index_1arr_secqueries">
<title>Issuing Queries on an Arrangement</title>
<para>One of the most useful query types defined on arrangements is the <emphasis>point-location</emphasis> query: Given a point, find the arrangement cell that contains it. Typically, the result of a point-location query is one of the arrangement faces, but in degenerate situations the query point can lie on an edge, or it may coincide with a vertex.</para>
<para>Point-location queries are common in many applications, and also play an important role in the incremental construction of arrangements (and more specifically in the free insertion-functions described in Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref>). Therefore, it is crucial to have the ability to answer such queries effectively.</para>
<sect2 id="index_1arr_ssecpl">
<title>Point-Location Queries</title>
<para>Recall that the arrangement representation is decoupled from the geometric algorithms that operate on it. Thus, the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template does not support point-location queries directly. Instead, the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package provides a set of class templates that are capable of answering such queries; all are models of the concept <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput>. Each model employs a different algorithm or <emphasis>strategy</emphasis> for answering queries. A model of this concept must define the <ref refid="classArrangementPointLocation__2_1a7785ccbae631240802765afbd3ccbaad" kindref="member"><computeroutput>locate()</computeroutput></ref> member function, which accepts an input query-point and returns a polymorphic object representing the arrangement cell that contains this point. The returned object is of type <computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type</computeroutput>, which is a discriminated union container of the bounded types <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member"><computeroutput>Vertex_const_handle</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member"><computeroutput>Halfedge_const_handle</computeroutput></ref>, or <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member"><computeroutput>Face_const_handle</computeroutput></ref>. Depending on whether the query point is located inside a face, lies on an edge, or coincides with a vertex, the appropriate handle can be obtained with <emphasis>value retrieval</emphasis> by <computeroutput>std::get</computeroutput> as demonstrated in the example below.</para>
<para>Note that the handles returned by the <ref refid="classArrangementPointLocation__2_1a7785ccbae631240802765afbd3ccbaad" kindref="member"><computeroutput>locate()</computeroutput></ref> functions are non-mutable (<computeroutput>const</computeroutput>). If necessary, such handles may be cast to mutable handles using the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab3ce8cfa533c872fee6496a100121bb4" kindref="member">Arrangement_on_surface_2::non_const_handle()</ref></computeroutput> methods.</para>
<para>An object <computeroutput>pl</computeroutput> of any point-location class must be attached to an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object <computeroutput>arr</computeroutput> before it is used to answer point-location queries on <computeroutput>arr</computeroutput>. This attachment can be performed when <computeroutput>pl</computeroutput> is constructed or at a later time using the <computeroutput>pl.init(arr)</computeroutput> call.</para>
<para>The function template <computeroutput>locate_point()</computeroutput> listed below accepts a point-location object, the type of which is a model of the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept, and a query point. The function template issues a point-location query for the given point, and prints out the result. It is defined in the header file <computeroutput>point_location_utils.h</computeroutput>.</para>
<para><anchor id="index_1lst_pl"/><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Po</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">Location&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>locate_point(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PointLocation&amp;<sp/>pl,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PointLocation::Arrangement_2::Point_2&amp;<sp/>q)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PointLocation<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_location;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_location::Arrangement_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::Arr_point_location_result&lt;Arrangement_2&gt;::Type</ref><sp/>obj<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pl.locate(q);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_point_location&lt;Arrangement_2&gt;(q,<sp/>obj);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The function template <computeroutput>locate_point()</computeroutput> calls an instance of the function template <computeroutput>print_point_location()</computeroutput>, which inserts the result of the query into the standard output-stream. It is listed below, and defined in the header file <computeroutput>point_location_utils.h</computeroutput>. Observe how the function <computeroutput>std::get()</computeroutput> is used to cast the resulting object into a handle to an arrangement feature. The point-location object <computeroutput>pl</computeroutput> is assumed to be already attached to an arrangement.</para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement_&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>print_point_location</highlight></codeline>
<codeline><highlight class="normal">(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PointLocation::Arrangement_::Point_2&amp;<sp/>q</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::Arr_point_location_result&lt;Arrangement_&gt;::Type</ref><sp/>obj)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement_<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Vertex_const_handle</ref><sp/><sp/><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Halfedge_const_handle</ref><sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Face_const_handle</ref><sp/><sp/><sp/><sp/><sp/>Face_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vertex_const_handle*<sp/><sp/><sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Halfedge_const_handle*<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Face_const_handle*<sp/><sp/><sp/><sp/><sp/>f;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>point<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>is<sp/>located<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>=<sp/>std::get_if&lt;Face_const_handle&gt;(&amp;obj))<sp/></highlight><highlight class="comment">//<sp/>located<sp/>inside<sp/>a<sp/>face</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;inside<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(((*f)-&gt;is_unbounded())<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>unbounded&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;a<sp/>bounded&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>face.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>=<sp/>std::get_if&lt;Halfedge_const_handle&gt;(&amp;obj))<sp/></highlight><highlight class="comment">//<sp/>located<sp/>on<sp/>an<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;on<sp/>an<sp/>edge:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*e)-&gt;curve()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(v<sp/>=<sp/>std::get_if&lt;Vertex_const_handle&gt;(&amp;obj))<sp/></highlight><highlight class="comment">//<sp/>located<sp/>on<sp/>a<sp/>vertex</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;on<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(((*v)-&gt;is_isolated())<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;an<sp/>isolated&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertex:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*v)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>CGAL_error_msg(</highlight><highlight class="stringliteral">&quot;Invalid<sp/>object.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1aos_sssec-pl_strategy">
<title>Choosing a Point-Location Strategy</title>
<para>Each of the various point-location class templates employs a different algorithm or <emphasis>strategy</emphasis>The term <emphasis>strategy</emphasis> is borrowed from the design-pattern taxonomy <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[7]</ref>, Chapter 5. A <emphasis>strategy</emphasis> provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice. for answering queries: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">Arr_naive_point_location</ref>&lt;Arrangement&gt;</computeroutput> employs the <emphasis>naive</emphasis> strategy. It locates the query point naively, exhaustively scanning all arrangement cells.</para>
<para></para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;Arrangement&gt;</computeroutput> employs the <emphasis>walk-along-a-line</emphasis> (or <emphasis>walk</emphasis> for short) strategy. It simulates a traversal, in reverse order, along an imaginary vertical ray emanating from the query point. It starts from the unbounded face of the arrangement and moves downward toward the query point until it locates the arrangement cell containing it.</para>
<para></para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">Arr_landmarks_point_location</ref>&lt;Arrangement,Generator&gt;</computeroutput> uses a set of <emphasis>landmark</emphasis> points, the location of which in the arrangement is known. It employs the <emphasis>landmark</emphasis> strategy. Given a query point, it uses a nearest-neighbor search-structure (a Kd-tree is used by default) to find the nearest landmark, and then traverses the straight-line segment connecting this landmark to the query point.</para>
<para>There are various ways to select the landmark set in the arrangement. The selection is governed by the <computeroutput>Generator</computeroutput> template parameter. The default generator class, namely <computeroutput>Arr_landmarks_vertices_generator</computeroutput>, selects all the vertices of the attached arrangement as landmarks. Additional generators that select the set in other ways, such as by sampling random points or choosing points on a grid, are also available; see the Reference Manual for more details.</para>
<para>The landmark strategy requires that the type of the attached arrangement be an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> parameter is substituted by a geometry-traits class that models the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, which refines the basic <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept; see Section <ref refid="index_1aos_sssec-tr_landmarks_concept" kindref="member">The Landmark Concept</ref> for details. Most traits classes included in the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package are models of this refined concept.</para>
<para></para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">Arr_trapezoid_ric_point_location</ref>&lt;Arrangement&gt;</computeroutput> implements an improved variant of Mulmuley&apos;s point-location algorithm <ref refid="citelist_1CITEREF_m-fppa-90" kindref="member">[11]</ref>; see also <ref refid="citelist_1CITEREF_bkos-cgaa-00" kindref="member">[5]</ref>, Chapter 6. The (expected) query-time is logarithmic in the size of the arrangement. The arrangement faces are decomposed into simpler cells each of constant complexity, known as <emphasis>pseudo trapezoids</emphasis>, and a search structure (a directed acyclic graph) is constructed on top of these cells, facilitating the search of the pseudo trapezoid (hence the arrangement cell) containing a query point in expected logarithmic time. The trapezoidal map and the search structure are built by a randomized incremental construction algorithm (RIC).</para>
<para></para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__triangulation__point__location" kindref="compound">Arr_triangulation_point_location</ref>&lt;Arrangement&gt;</computeroutput> uses a constrained triangulation, provided by the <ref refid="packages_1PkgTriangulation2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Triangulations</ref> package, as a search structure. Every time the arrangement is modified the constrained triangulation search-structure is reconstructed from scratch, where the edges of the arrangement are set to be the constrained edges of the triangulation. This strategy is inefficient (especially when the number of modifications applied to the arrangement is high) and provided only for educational purposes.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>The first two strategies do not require any extra data. The class templates that implement them store a pointer to an arrangement object and operate directly on it. Attaching such point-location objects to an existing arrangement has virtually no running-time cost at all, but the query time is linear in the size of the arrangement (the performance of the walk strategy is much better in practice, but its worst-case performance is linear). Using these strategies is therefore recommended only when a relatively small number of point-location queries are issued by the application, or when the arrangement is constantly changing (That is, changes in the arrangement structure are more frequent than point-location queries). On the other hand, the landmark and the trapezoid RIC strategies require auxiliary data structures on top of the arrangement structure, which they need to construct once they are attached to an arrangement object and need to keep up-to-date as this arrangement changes.</para>
<para>As mentioned above, the triangulation strategy is provided only for educational purposes, and thus we do not elaborate on this strategy. The data structure needed by the landmark and the trapezoidal map RIC strategies can be constructed in <formula id="75">$O(N \log N)$</formula> time, where <formula id="76">$N$</formula> is the overall number of edges in the arrangement, but the constant hidden in the <formula id="77">$O(&amp;nbsp;)$</formula> notation for the trapezoidal map RIC strategy is much larger. Thus, construction needed by the landmark algorithm is in practice significantly faster than the construction needed by the trapezoidal map RIC strategy. In addition, although both resulting data structures are asymptotically linear in size, the actual amount of memory consumed by the landmark algorithm is typically smaller than to the amount used by the trapezoidal map RIC algorithm, due to the space-efficient Kd-tree used by the landmark algorithm as the nearest-neighbor search-structure. The trapezoidal map RIC algorithm has expected logarithmic query time, while the query time for the landmark algorithm may be as large as linear. In practice however, the query times of both strategies are competitive. For a detailed experimental comparison see <ref refid="citelist_1CITEREF_cgal:hh-eplca-05" kindref="member">[9]</ref>.</para>
<para>Updating the auxiliary data structures of the trapezoidal map RIC algorithm is done very efficiently. On the other hand, updating the nearest-neighbor search-structure of the landmark algorithm may consume significant time when the arrangement changes frequently, especially when a Kd-tree is used, as it must be rebuilt each time the arrangement changes. It is therefore recommended that the <computeroutput><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">Arr_landmarks_point_location</ref></computeroutput> class template be used when the application frequently issues point-location queries on an arrangement that only seldom changes. If the arrangement is more dynamic and is frequently going through changes, the <computeroutput><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">Arr_trapezoid_ric_point_location</ref></computeroutput> class template should be the selected point-location strategy.</para>
<para><anchor id="index_1fig__aos_fig-point_location"/> <image type="html" name="point_location.png"></image>
 <image type="latex" name="point_location.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-point_location" kindref="member">fig__aos_fig-point_location</ref> The arrangement of line segments, as constructed in <ref refid="Arrangement_on_surface_2_2point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/point_location.cpp</ref>, <ref refid="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example" kindref="compound">Arrangement_on_surface_2/vertical_ray_shooting.cpp</ref>, and <ref refid="Arrangement_on_surface_2_2batched_point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/batched_point_location.cpp</ref>. The arrangement vertices are drawn as small rings, while the query points <formula id="78">$q_1,
\ldots, q_6$</formula> are drawn as crosses. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The program listed below constructs a simple arrangement of five line segments that form a pentagonal face, with a single isolated vertex in its interior, as depicted in <ref refid="index_1fig__aos_fig-point_location" kindref="member">fig__aos_fig-point_location</ref>. Notice that we use the same arrangement structure in the next three example programs. The arrangement construction is performed by the function <computeroutput>construct_segment_arr()</computeroutput> defined in the header file <computeroutput>point_location_utils.h</computeroutput>. (Its listing is omitted here.) The program employs the naive and the landmark strategies to issue several point-location queries on this arrangement.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/point_location.cpp</ref> <programlisting filename="Arrangement_on_surface_2/point_location.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Answering<sp/>point-location<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_landmarks_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Naive_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Landmarks_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__landmarks__point__location" kindref="compound">CGAL::Arr_landmarks_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>point-location<sp/>queries<sp/>using<sp/>the<sp/>naive<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/>naive_pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(naive_pl,<sp/>Point(1,<sp/>4));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(naive_pl,<sp/>Point(4,<sp/>3));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(naive_pl,<sp/>Point(6,<sp/>3));<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>point-location<sp/>queries<sp/>using<sp/>the<sp/>landmark<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Landmarks_pl<sp/>landmarks_pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(landmarks_pl,<sp/>Point(3,<sp/>2));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q4</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(landmarks_pl,<sp/>Point(5,<sp/>2));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(landmarks_pl,<sp/>Point(1,<sp/>0));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q6</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Note that the program uses the <computeroutput>locate_point()</computeroutput> function template to locate a point and nicely print the result of each query; see <ref refid="index_1lst_pl" kindref="member">code example</ref> in Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>.</para>
</sect2>
<sect2 id="index_1arr_ssecray_shoot">
<title>Vertical Ray Shooting</title>
<para>Another query frequently issued on arrangements is the vertical ray-shooting query: Given a query point, which arrangement cell is encounter by a vertical ray shot upward (or downward) from this point? In the general case the ray hits an edge, but it is possible that it hits a vertex, or that the arrangement does not have any vertex or edge lying directly above (or below) the query point.</para>
<para>All point-location classes listed in the previous section are also models of the <computeroutput><ref refid="classArrangementVerticalRayShoot__2" kindref="compound">ArrangementVerticalRayShoot_2</ref></computeroutput> concept. That is, they all have member functions called <computeroutput>ray_shoot_up(q)</computeroutput> and <computeroutput>ray_shoot_down(q)</computeroutput> that accept a query point <formula id="79">$q$</formula>. These functions output a polymorphic object of type <computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type</computeroutput>, which is a discriminated union container of the bounded types <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member"><computeroutput>Vertex_const_handle</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member"><computeroutput>Halfedge_const_handle</computeroutput></ref>, or <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member"><computeroutput>Face_const_handle</computeroutput></ref>. The latter type is used for the unbounded face of the arrangement, in case there is no edge or vertex lying directly above (or below) <formula id="79">$q$</formula>.</para>
<para>The function template <computeroutput>vertical_ray_shooting_query()</computeroutput> listed below accepts a vertical ray-shooting object, the type of which models the <computeroutput><ref refid="classArrangementVerticalRayShoot__2" kindref="compound">ArrangementVerticalRayShoot_2</ref></computeroutput> concept. It exports the result of the upward vertical ray-shooting operation from a given query point to the standard output-stream. The ray-shooting object <computeroutput>vrs</computeroutput> is assumed to be already attached to an arrangement. The function template is defined in the header file <computeroutput>point_location_utils.h.</computeroutput></para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VerticalRayShooting&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>shoot_vertical_ray(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>RayShoot&amp;<sp/>vrs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VerticalRayShooting::Arrangement_2::Point_2&amp;<sp/>q)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VerticalRayShooting<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertical_ray_shooting;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>the<sp/>point-location<sp/>query.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vertical_ray_shooting::result_type<sp/>obj<sp/>=<sp/>vrs.ray_shoot_up(q);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Vertical_ray_shooting::Arrangement_2<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Vertex_const_handle</ref><sp/><sp/><sp/>Vertex_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Halfedge_const_handle</ref><sp/>Halfedge_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Arrangement_2::Face_const_handle</ref><sp/><sp/><sp/><sp/><sp/>Face_const_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Vertex_const_handle*<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Halfedge_const_handle*<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Face_const_handle*<sp/>f;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Shooting<sp/>up<sp/>from<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(v<sp/>=<sp/>std::get_if&lt;Vertex_const_handle&gt;(&amp;obj))<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>hit<sp/>a<sp/>vertex</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;hit<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(((*v)-&gt;is_isolated())<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;an<sp/>isolated&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>vertex:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*v)-&gt;point()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>=<sp/>std::get_if&lt;Halfedge_const_handle&gt;(&amp;obj))<sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>hit<sp/>an<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;hit<sp/>an<sp/>edge:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(*e)-&gt;curve()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>=<sp/>std::get_if&lt;Face_const_handle&gt;(&amp;obj))<sp/>{<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>hit<sp/>nothing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_assertion((*f)-&gt;is_unbounded());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;hit<sp/>nothing.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>CGAL_error();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The program below uses the function template listed above to perform vertical ray-shooting queries on an arrangement. The arrangement and the query points are exactly the same as in <ref refid="Arrangement_on_surface_2_2point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/point_location.cpp</ref>; see <ref refid="index_1fig__aos_fig-point_location" kindref="member">fig__aos_fig-point_location</ref>. <linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example" kindref="compound">Arrangement_on_surface_2/vertical_ray_shooting.cpp</ref> <programlisting filename="Arrangement_on_surface_2/vertical_ray_shooting.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Answering<sp/>vertical<sp/>ray-shooting<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_walk_along_line_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Walk_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">CGAL::Arr_walk_along_line_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Trap_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">CGAL::Arr_trapezoid_ric_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>vertical<sp/>ray-shooting<sp/>queries<sp/>using<sp/>the<sp/>walk<sp/>strategy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Walk_pl<sp/>walk_pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(walk_pl,<sp/>Point(1,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(walk_pl,<sp/>Point(4,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(walk_pl,<sp/>Point(6,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Attach<sp/>the<sp/>trapezoid-RIC<sp/>object<sp/>to<sp/>the<sp/>arrangement<sp/>and<sp/>perform<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Trap_pl<sp/>trap_pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(trap_pl,<sp/>Point(3,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(trap_pl,<sp/>Point(5,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>shoot_vertical_ray(trap_pl,<sp/>Point(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssecbatched_pl">
<title>Batched Point-Location</title>
<para>Suppose that at a given moment our application has to issue a relatively large number <formula id="80">$m$</formula> of point-location queries on a specific arrangement object. Naturally, It is possible to define a point-location object and use it to issue separate queries on the arrangement. However, as explained in Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref> choosing a simple point-location strategy (either the naive or the walk strategy) means inefficient queries, while the more sophisticated strategies need to construct auxiliary structures that incur considerable overhead in running time.</para>
<para>Alternatively, the <emphasis>2D Arrangement</emphasis> package includes a free <computeroutput><ref refid="group__PkgArrangementOnSurface2PointLocation_1ga278df8e4d85dcb6bf3dfa35e251a706e" kindref="member">locate()</ref></computeroutput> function that accepts an arrangement and a range of query points as its input and sweeps through the arrangement to locate all query points in one pass. The function outputs the query results as pairs, where each pair consists of a query point and a discriminated union container, which represents the cell containing the point; see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>. The output pairs are sorted in increasing <formula id="29">$xy$</formula>-lexicographical order of the query point.</para>
<para>The batched point-location operation is carried out by sweeping the arrangement. Thus, it takes <formula id="81">$O((m+N)\log{(m+N)})$</formula> time, where <formula id="76">$N$</formula> is the number of edges in the arrangement. Issuing separate queries exploiting a point-location strategy with logarithmic query time per query, such as the trapezoidal map RIC strategy (see Section <ref refid="index_1aos_sssec-pl_strategy" kindref="member">Choosing a Point-Location Strategy</ref>), is asymptotically more efficient. However, experiments show that when the number <formula id="80">$m$</formula> of point-location queries is of the same order of magnitude as <formula id="76">$N$</formula>, the batched point-location operation is more efficient in practice. One of the reasons for the inferior performance of the alternative (asymptotically faster) procedures is the necessity to construct and maintain complex additional data structures.</para>
<para>The program below issues a batched point-location query, which is essentially equivalent to the six separate queries performed in <ref refid="Arrangement_on_surface_2_2point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/point_location.cpp</ref>; see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>. <linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2batched_point_location_8cpp-example" kindref="compound">Arrangement_on_surface_2/batched_point_location.cpp</ref> <programlisting filename="Arrangement_on_surface_2/batched_point_location.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Answering<sp/>a<sp/>batched<sp/>point-location<sp/>query.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_batched_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_location_result<sp/>=<sp/><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">CGAL::Arr_point_location_result&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Query_result<sp/>=<sp/>std::pair&lt;Point,<sp/>Point_location_result::Type&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>a<sp/>batched<sp/>point-location<sp/>query.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(1,<sp/>4),<sp/>Point(4,<sp/>3),<sp/>Point(6,<sp/>3),<sp/>Point(3,<sp/>2),<sp/>Point(5,<sp/>2),<sp/>Point(1,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Query_result&gt;<sp/>results;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2PointLocation_1ga278df8e4d85dcb6bf3dfa35e251a706e" kindref="member">CGAL::locate</ref>(arr,<sp/>points.begin(),<sp/>points.end(),<sp/>std::back_inserter(results));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>results.begin();<sp/>it<sp/>!=<sp/>results.end();<sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>print_point_location&lt;Arrangement&gt;(it-&gt;first,<sp/>it-&gt;second);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1arr_secgl_funcs">
<title>Free Functions</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput> class template is used to represent subdivisions of two-dimensional surfaces induced by curves that lie on such surfaces. Its interface is minimal in the sense that the member functions hardly perform any geometric operations. In this section we explain how to utilize the free functions that enhance that set of operations on arrangements. The implementation of these operations typically require non-trivial geometric algorithms, and occasionally incurs additional requirements on the geometry traits class; the implementation of many of the operations is based on two frameworks, namely the <emphasis>surface sweep</emphasis> and the <emphasis>zone construction</emphasis>. These operations accepts <formula id="7">$x$</formula>-monotone curves; thus, the geometry-traits class used by the arrangements passed as input to, or obtained as output from, these operations must be a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept; see Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref> for the precise definition of this concept. It defines the minimal set of geometric primitives, among other things, required to perform the algorithms of the surface-sweep and zone-construction frameworks.</para>
<sect2 id="index_1arr_ssec_zone">
<title>The Zone Construction Algorithm</title>
<para>Given an arrangement of curves <formula id="82">$\mathcal{A} =
\mathcal{A}(\mathcal{C})$</formula> embedded in a two-dimensional surface, the <emphasis>zone</emphasis> of an additional curve <formula id="83">$\gamma \notin \mathcal{C}$</formula> in <formula id="63">$\mathcal{A}$</formula> is the union of the features of <formula id="63">$\mathcal{A}$</formula>, whose closure is intersected by <formula id="84">$\gamma$</formula>. The complexity of the zone is defined as the sum of the complexities of its constituents. (Notice that some vertices are counted multiple times.) The zone of a curve <formula id="84">$\gamma$</formula> is computed by locating the left endpoint of <formula id="84">$\gamma$</formula> in the arrangement and then &quot;walking&quot;&apos; along the curve towards the right endpoint, keeping track of the vertices, edges, and faces crossed on the way. The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package offers a generic implementation of an algorithm that computes the zone. It is used to implement a set of operations that incrementally construct arrangements induced by sets of curves that lie in two-dimensional surfaces. For simplicity, however, we continue to consider arrangements embedded in the plane.</para>
<para>Section <ref refid="index_1aos_ssec-basic-arr_class" kindref="member">The Arrangement Class Template</ref> explains how to construct arrangements of <formula id="7">$x$</formula>-monotone curves that are pairwise disjoint in their interior when the location of the segment endpoints in the arrangement is known. Here we relax this constraint, and allow the location of the inserted <formula id="7">$x$</formula>-monotone curve endpoints to be unknown at the time of insertion.</para>
<sect3 id="index_1arr_sssecinsert_non_x">
<title>Inserting Pairwise Disjoint Curves</title>
<para>We retain, for the moment, the requirement that the interior of the inserted curve is disjoint from all existing arrangement edges and vertices.</para>
<para>The call <ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member"><computeroutput>insert_non_intersecting_curve(arr, c, pl)</computeroutput></ref> inserts the <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> into the arrangement <computeroutput>arr</computeroutput>, with the precondition that the interior of <formula id="8">$c$</formula> is disjoint from all existing edges and vertices of <computeroutput>arr</computeroutput>. The third argument <computeroutput>pl</computeroutput> is a point-location object attached to the arrangement; it is used to locate both endpoints of <formula id="8">$c$</formula> in the arrangement. Each endpoint is expected to either coincide with an existing vertex or lie inside a face. It is possible to invoke one of the specialized insertion functions (see Section <ref refid="index_1aos_ssec-basic-arr_class" kindref="member">The Arrangement Class Template</ref>), based on the query results, and insert <formula id="8">$c$</formula> at its proper location.The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">CGAL::insert_non_intersecting_curve&lt;&gt;()</ref></computeroutput> function template, as all other functions reviewed in this section, is parameterized by an arrangement type and a point-location type (The latter must be substituted by a model of the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept). The insertion operation thus hardly requires any geometric operations on top of the ones needed to answer the point-location queries. Moreover, it is sufficient that the traits class that substitutes the <computeroutput>Traits</computeroutput> template parameter of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template when the latter is instantiated models the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept (and the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> if the landmark point-location strategy is used), and does not have to support the computation of intersection points between curves. This implies that using a kernel that provides exact geometric predicates, but potentially inexact geometric constructions due to round-off errors, is still sufficient.</para>
<para>The free-function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">CGAL::insert_non_intersecting_curve</ref>&lt;&gt;(arr, c, pl)</computeroutput> is overloaded. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref></computeroutput> class template, and uses it to insert the curve.</para>
</sect3>
<sect3 id="index_1arr_sssecinsert_x_mon">
<title>Inserting X-monotone Curves</title>
<para>The time it takes to insert a curve <formula id="8">$c$</formula> using the <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> function template is the sum of the time is takes to locate the two endpoints of <formula id="8">$c$</formula> and the time is takes to find the exact place for the new two halfedges mapped to <formula id="8">$c$</formula> in the circular list of halfedges incident to the two vertices mapped to the endpoints of <formula id="8">$c$</formula>, respectively. This makes the function relatively efficient; however, its preconditions on the input curves are still rather restricting. Let us assume that the traits class that substitutes the <computeroutput>Traits</computeroutput> template parameter of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template models the refined <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept and supports curve intersection computations; see Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref> for the exact details. Given an <formula id="7">$x$</formula>-monotone curve, it is sufficient to locate its left endpoint in the arrangement and to trace its <emphasis>zone</emphasis> (see Section <ref refid="index_1arr_ssec_zone" kindref="member">The Zone Construction Algorithm</ref>) until the right endpoint is reached. Each time the new curve <formula id="8">$c$</formula> crosses an existing vertex or edge, the curve is split into subcurves (in the latter case, we have to split the curve associated with the existing halfedge as well) and new edges are associated with the resulting subcurves. Recall that an edge is represented by a pair of twin halfedges, so we split it into two halfedge pairs.</para>
<para>The call <ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member"><computeroutput>insert(arr, c, pl)</computeroutput></ref> performs this insertion operation. The <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;()</computeroutput> function template accepts an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula>, which may intersect some of the curves already in the arrangement <computeroutput>arr</computeroutput>, and inserts it into the arrangement by computing its zone. Users may supply a point-location object <computeroutput>pl</computeroutput> or use the default walk point-location strategy (namely, the variant <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;(arr, c)</computeroutput> is also available). The running-time of this insertion function is proportional to the complexity of the zone of the curve <formula id="8">$c$</formula>.</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly>  In some cases users may have a prior knowledge of the location of the left endpoint of the <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> they wish to insert, so they can perform the insertion without issuing any point-location queries. This can be done by calling the free function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;(arr, c, obj)</computeroutput>, where <computeroutput>obj</computeroutput> is a polymorphic object of type <computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type</computeroutput> that represents the location of <formula id="8">$c$</formula>s left endpoint in the arrangement. It is a discriminated union container of the bounded types <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member"><computeroutput>Vertex_const_handle</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member"><computeroutput>Halfedge_const_handle</computeroutput></ref>, or <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member"><computeroutput>Face_const_handle</computeroutput></ref>; see also Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect3>
<sect3 id="index_1aos_ssec-insert_gen">
<title>Inserting General Curves</title>
<para>So far, all the examples have constructed arrangements of line segments, where the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> template was instantiated with an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template. In this case, the restriction that <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;()</computeroutput> requires an <formula id="7">$x$</formula>-monotone is irrelevant, as all line segments are <formula id="7">$x$</formula>-monotone. (Note that we always deal with <emphasis>weakly</emphasis> <formula id="7">$x$</formula>-monotone curves, and we consider vertical line-segments to be weakly <formula id="7">$x$</formula>-monotone).</para>
<para>Consider an arrangement of circles. A circle is obviously not <formula id="7">$x$</formula>-monotone, so <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;()</computeroutput> cannot be used in this case.A key operation performed by <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert&lt;&gt;()</ref></computeroutput> is to locate the left endpoint of the curve in the arrangement. A circle, however, does not have any endpoints! , it is necessary to subdivide each circle into two <formula id="7">$x$</formula>-monotone circular arcs, namely, its upper half and its lower half, and to insert the two individual <formula id="7">$x$</formula>-monotone arcs.</para>
<para>The free function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;()</computeroutput> is overloaded. It is possible to another version of this function and pass a curve that is not necessarily <formula id="7">$x$</formula>-monotone, but this is subject to an important condition. Consider the call <ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member"><computeroutput>insert(arr, c,
pl)</computeroutput></ref>, where <formula id="8">$c$</formula> is not necessarily <formula id="7">$x$</formula>-monotone. In this case the type of <computeroutput>arr</computeroutput> must be an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits, Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> template parameter is substituted by a traits class that models the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, which refines the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. It has to define an additional <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref> type, which may differ from the <ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> type. It also has to support the subdivision of curves of this new type into <formula id="7">$x$</formula>-monotone curves and possibly singular points; see the exact details in Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>. The <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;(arr, c, pl)</computeroutput> function performs the insertion of the curve <formula id="8">$c$</formula> that does not need to be <formula id="7">$x$</formula>-monotone, into the arrangement by subdividing it into <formula id="7">$x$</formula>-monotone subcurves and inserting all individual <formula id="7">$x$</formula>-monotone subcurves. Users may supply a point-location object <computeroutput>pl</computeroutput>, or use the default walk point-location strategy by calling <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;(arr, c)</computeroutput>.</para>
</sect3>
<sect3 id="index_1arr_sssecinsert_point">
<title>Inserting Points</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template has a member function that inserts a point as an isolated vertex in a given face. The free function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gabfaca749e7d8c9547c143032a0e9df08" kindref="member">CGAL::insert_point</ref>&lt;&gt;(arr, p, pl)</computeroutput> inserts a vertex that corresponds to the point <formula id="59">$p$</formula> into <computeroutput>arr</computeroutput> at an arbitrary location. It uses the point-location object <computeroutput>pl</computeroutput> to locate the point in the arrangement (by default, the walk point-location strategy is used), and acts according to the result as follows:</para>
<para><itemizedlist>
<listitem>
<para>If <formula id="59">$p$</formula> is located inside a face, it is inserted as an isolated vertex inside this face.</para>
<para></para>
</listitem>
<listitem>
<para>If <formula id="59">$p$</formula> lies on an edge, the edge is split to create a vertex associated with <formula id="59">$p$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>Otherwise, <formula id="59">$p$</formula> coincides with an existing vertex and no further actions are needed. </para>
</listitem>
</itemizedlist>
</para>
<para>In all cases, the function returns a handle to the vertex associated with <formula id="59">$p$</formula>.</para>
<para>The type of <computeroutput>arr</computeroutput> must be and instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template instantiated with a traits class that models the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept, as the insertion operation may involve the splitting of curves.</para>
</sect3>
<sect3 id="index_1arr_sssecinsert_ex">
<title>Inserting Intersecting Line Segments (code example)</title>
<para><anchor id="index_1fig__aos_fig-incremental_insertion"/> <image type="html" name="incremental_insertion.png"></image>
 <image type="latex" name="incremental_insertion.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-incremental_insertion" kindref="member">fig__aos_fig-incremental_insertion</ref> An arrangement of five intersecting line segments, as constructed in <ref refid="Arrangement_on_surface_2_2incremental_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/incremental_insertion.cpp</ref> and <ref refid="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/aggregated_insertion.cpp</ref>. The segment endpoints are marked by black disks and the arrangement vertices that correspond to intersection points are marked by circles. The query point <formula id="79">$q$</formula> is marked with a cross and the face that contains it is shaded. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The program below constructs an arrangement of five intersecting line-segments <formula id="56">$s_1, \ldots, s_5$</formula>. It is known that <formula id="52">$s_1$</formula> and <formula id="53">$s_2$</formula> do not intersect, so <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">CGAL::insert_non_intersecting_curve</ref>&lt;&gt;()</computeroutput> is used to insert them into the empty arrangement. The rest of the segments are inserted using <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>&lt;&gt;()</computeroutput>. Using a kernel that constructs geometric objects in an inexact manner (due to round-off errors) may yield a program that computes incorrect results and crashes from time to time. This is avoided by using a kernel that provides exact geometric-object constructions as well as exact geometric-predicate evaluations. The header file <computeroutput>arr_exact_construction_segments.h</computeroutput>, just like the header file <computeroutput>arr_inexact_construction_segments.h</computeroutput>, contains the definitions for arrangements of line segments. Unlike the latter, it uses a kernel suitable for arrangements induced by curves that intersect each other, namely a kernel that is exact always. Note that we alternately use the naive point-location strategy, given explicitly to the insertion functions, and the default walk point-location strategy.</para>
<para>The resulting arrangement is depicted in <ref refid="index_1fig__aos_fig-incremental_insertion" kindref="member">fig__aos_fig-incremental_insertion</ref>, where the vertices that correspond to segment endpoints are drawn as dark discs, and the vertices that correspond to intersection points are drawn as circles. It consists of 13 vertices, 16 edges, and 5 faces. We also perform a point-location query on the resulting arrangement. The query point <formula id="79">$q$</formula> is drawn as a plus sign. The face that contains it is drawn with a shaded texture. The program calls an instance of the function template <computeroutput>print_arrangement_size()</computeroutput>, which prints quantitative measures of the arrangement; see <ref refid="index_1lst_paz" kindref="member">code example</ref> for its listing in Section <ref refid="index_1aos_ssec-basic-arr_class" kindref="member">The Arrangement Class Template</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2incremental_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/incremental_insertion.cpp</ref> <programlisting filename="Arrangement_on_surface_2/incremental_insertion.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>incremental<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Naive_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Pl_result_type<sp/>=<sp/><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::Arr_point_location_result&lt;Arrangement&gt;::Type</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>five<sp/>intersecting<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(Point(1,<sp/>0),<sp/>Point(2,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s2(Point(5,<sp/>0),<sp/>Point(5,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s3(Point(1,<sp/>0),<sp/>Point(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s4(Point(0,<sp/>2),<sp/>Point(6,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s5(Point(3,<sp/>0),<sp/>Point(5,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>e<sp/>=<sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s1,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s2,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s3,<sp/>Pl_result_type(e-&gt;source()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s4,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s5,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>a<sp/>point-location<sp/>query<sp/>on<sp/>the<sp/>resulting<sp/>arrangement<sp/>and<sp/>print</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>boundary<sp/>of<sp/>the<sp/>face<sp/>that<sp/>contains<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>q(4,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>obj<sp/>=<sp/>pl.locate(q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>f<sp/>=<sp/>std::get_if&lt;Arrangement::Face_const_handle&gt;(&amp;obj);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>query<sp/>point<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>q<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>is<sp/>located<sp/>in:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_face&lt;Arrangement&gt;(*f);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="index_1arr_ssseczone">
<title>Other Zone Related Functions</title>
<para>In this section we have described so far free functions that insert curves and points into a given arrangement. Now we describe functions that do not change the arrangement at all; nevertheless, they are closely related to the incremental insertion functions, as they also use the zone framework.</para>
<para>The free function template <computeroutput>CGAL::do_intersect&lt;&gt;(arr, c, pl)</computeroutput> checks whether the given query curve <formula id="8">$c$</formula> intersects the curves and points of an existing arrangement <computeroutput>arr</computeroutput>. If <formula id="8">$c$</formula> is not <formula id="7">$x$</formula>-monotone (that is, it is of type <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref>) the curve is subdivided into <formula id="7">$x$</formula>-monotone subcurves and isolated points. Each <formula id="7">$x$</formula>-monotone curve (or point) is checked for intersection in turn using the zone framework. For points we simply apply point-location. Given an <formula id="7">$x$</formula>-monotone curve, first its left endpoint is located; then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement curve or point is found or when the right endpoint is reached. A given point-location object is used for locating the left endpoint of the curve in the existing arrangement. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref></computeroutput> class template, and uses it to locate the endpoint. If the given curve is <formula id="7">$x$</formula>-monotone then the traits type must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. If the curve is not <formula id="7">$x$</formula>-monotone then the traits type must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept.</para>
<para>The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga52ccca744c113ea53ae30cdf6c70b295" kindref="member">CGAL::zone</ref>&lt;&gt;(arr, c, oi, pl)</computeroutput> function template computes the zone of a given <formula id="7">$x$</formula>-monotone curve in a given arrangement. More precisely, it outputs all the arrangement cells (namely, vertices, edges, and faces) that the input <formula id="7">$x$</formula>-monotone curve <formula id="85">$C$</formula> intersects in the order they are discovered when traversing the curve from left to right. The function uses a given point-location object to locate the left endpoint of the given curve. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref></computeroutput> class template, and uses it to locate the endpoint. The traits type must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept.</para>
</sect2>
<sect2 id="index_1arr_ssec_sweep">
<title>The Surface-Sweep Algorithm</title>
<para>The famous plane-sweep algorithm introduced by Bentley and Ottmann was originally formulated for sets of line segments in the plane. The <ref refid="packages_1PkgSurfaceSweep2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Intersection of Curves</ref> package offers a generic implementation of a generalized version of the original plane-sweep algorithm. It (i) operates in two-dimensional surfaces (not restricted to the plane), (ii) accepts various families of <formula id="7">$x$</formula>-monotone curves (not only line segments), and (iii) handles overlaps. (Observe that the original algorithm did not handle overlaps. Handling overlaps is difficult, especially for polyline, as two polylines may overlap in more then one connected component.) The generic implementation serves as the foundation of a family of concrete operations described in the rest of this section, such as aggregately constructing an arrangement induced by a set of curves that lie in a two-dimensional surface and outputting the overlay of two arrangements.</para>
<para>Given a set of <formula id="86">$n$</formula> input curves, you can insert the curves in the set into an arrangement incrementally one by one. However, the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package also provides a couple of free (overloaded) functions that aggregately insert a range of curves into an arrangement using the surface-Sweep framework.</para>
<para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">CGAL::insert_non_intersecting_curves</ref>&lt;&gt;(arr, begin, end)</computeroutput> inserts a range of <formula id="7">$x$</formula>-monotone curves given by the range <computeroutput>[begin, end)</computeroutput> into an arrangement <computeroutput>arr</computeroutput>. The <formula id="7">$x$</formula>-monotone curves should be pairwise disjoint in their interior and also interior-disjoint from all existing curves and points of <computeroutput>arr</computeroutput>.</para>
<para></para>
</listitem>
<listitem>
<para><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member"><computeroutput>insert(arr, begin, end)</computeroutput></ref> operates on a range of <formula id="7">$x$</formula>-monotone curves that may intersect one another.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>We distinguish between two cases: (i) The given arrangement <computeroutput>arr</computeroutput> is empty (has only an unbounded face), so it must be construct from scratch. (ii) The given arrangement <computeroutput>arr</computeroutput> is not empty.</para>
<para>In the first case, we sweep over the input curves, compute their intersection points, and construct the DCEL that represents their arrangement. This process is performed in <formula id="87">$O(left((n + k)\log
n\right)$</formula> time, where <formula id="88">$k$</formula> is the total number of intersection points. The running time is asymptotically better than the time needed for incremental insertion if the arrangement is relatively sparse (when <formula id="88">$k$</formula> is <formula id="89">$O(\frac{n^2}{\log n})$</formula>), but it is recommended that this aggregate construction process be used even for dense arrangements, since the plane-sweep algorithm performs fewer geometric operations compared to the incremental insertion algorithms, and hence typically runs much faster in practice.</para>
<para>Another important advantage of the aggregated insertion functions is that they do not issue point-location queries. Thus, no point-location object needs to be attached to the arrangement. As explained in Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>, there is a trade-off between construction time and query time in each of the point-location strategies, which affects the running times of the incremental insertion process. Naturally, this trade-off is absent in the case of aggregated insertion.</para>
<para>The example below shows how to construct the same arrangement of five line segments built incrementally in <ref refid="Arrangement_on_surface_2_2incremental_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/incremental_insertion.cpp</ref> depicted in <ref refid="index_1fig__aos_fig-incremental_insertion" kindref="member">fig__aos_fig-incremental_insertion</ref> using the aggregate insertion function <ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member"><computeroutput>insert()</computeroutput></ref>. Note that no point-location object needs to be defined and attached to the arrangement.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/aggregated_insertion.cpp</ref> <programlisting filename="Arrangement_on_surface_2/aggregated_insertion.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>aggregated<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Aggregately<sp/>construct<sp/>the<sp/>arrangement<sp/>of<sp/>five<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>segments[]<sp/>=<sp/>{Segment(Point(1,<sp/>0),<sp/>Point(2,<sp/>4)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(5,<sp/>0),<sp/>Point(5,<sp/>5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(1,<sp/>0),<sp/>Point(5,<sp/>3)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(0,<sp/>2),<sp/>Point(6,<sp/>0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(3,<sp/>0),<sp/>Point(5,<sp/>5))};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segments,<sp/>segments<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(segments)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Next we handle the case where we have to insert a set of <formula id="86">$n$</formula> curves into an existing arrangement. Let <formula id="76">$N$</formula> denote the number of edges in the arrangement. If <formula id="86">$n$</formula> is very small compared to <formula id="76">$N$</formula> (in theory, we would say that if <formula id="90">$n = o(\sqrt{N})$</formula>), we insert the curves one by one. For larger input sets, we use the aggregate insertion procedures.</para>
<para><anchor id="index_1fig__aos_fig-global_insertion"/> <image type="html" name="global_insertion.png"></image>
 <image type="latex" name="global_insertion.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-global_insertion" kindref="member">fig__aos_fig-global_insertion</ref> An arrangement of intersecting line segments, as constructed in <ref refid="Arrangement_on_surface_2_2global_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/global_insertion.cpp</ref>. The segments of <formula id="91">$\mathcal{S}_1$</formula> are drawn in solid lines and the segments of <formula id="92">$\mathcal{S}_2$</formula> are drawn in dark dashed lines. Note that the segment <formula id="93">$ s$</formula> (light dashed line) overlaps one of the segments in <formula id="91">$\mathcal{S}_1$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The program below aggregately construct an arrangement of a set <formula id="91">$\mathcal{S}_1$</formula> containing five line segments (drawn as solid lines). Then, it inserts a single segment <formula id="67">$s$</formula> (drawn as a dotted line) using the incremental insertion function. Finally, it adds a set <formula id="92">$\mathcal{S}_2$</formula> with five more line segments (drawn as dashed lines) in an aggregate fashion. Notice that the line segments of <formula id="91">$\mathcal{S}_1$</formula> are pairwise interior-disjoint, so <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves()</ref></computeroutput> is safely used. <formula id="92">$\mathcal{S}_2$</formula> also contains pairwise interior-disjoint segments, but as they intersect the existing arrangement, <ref refid="group__PkgArrangementOnSurface2Insert_1ga25a2ae72727ec4c0680d20477bab7a1c" kindref="member"><computeroutput>insert()</computeroutput></ref> must be used to insert them. Also note that the single segment <formula id="67">$s$</formula> inserted incrementally partially overlaps an existing arrangement curve; the overlapped portion is drawn as a dash-dotted line.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2global_insertion_8cpp-example" kindref="compound">Arrangement_on_surface_2/global_insertion.cpp</ref> <programlisting filename="Arrangement_on_surface_2/global_insertion.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>insertion<sp/>functions<sp/>(incremental<sp/>and<sp/>aggregated).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>S1[]<sp/>=<sp/>{Segment(Point(1,<sp/>3),<sp/>Point(4,<sp/>6)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(1,<sp/>3),<sp/>Point(6,<sp/>3)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(1,<sp/>3),<sp/>Point(4,<sp/>0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(4,<sp/>6),<sp/>Point(6,<sp/>3)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(4,<sp/>0),<sp/>Point(6,<sp/>3))};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s<sp/>=<sp/>Segment(Point(0,<sp/>3),<sp/>Point(4,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>S2[]<sp/>=<sp/>{Segment(Point(0,<sp/>5),<sp/>Point(6,<sp/>6)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(0,<sp/>4),<sp/>Point(6,<sp/>5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(0,<sp/>2),<sp/>Point(6,<sp/>1)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(0,<sp/>1),<sp/>Point(6,<sp/>0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(6,<sp/>1),<sp/>Point(6,<sp/>5))};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves</ref>(arr,<sp/>S1,<sp/>S1<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(S1)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1<sp/>incremental</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>S2,<sp/>S2<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(S2)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment));<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>5<sp/>aggregate</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>We summarize the three levels of arrangement types based on curve monotonicity and intersection properties in the table below. The three levels, starting from the most restrictive, are (i) <formula id="7">$x$</formula>-monotone curves that are pairwise disjoint in their interior, (ii) <formula id="7">$x$</formula>-monotone curves (which are possibly intersecting one another), and (iii) general curves. We list the single-curve insertion functions.</para>
<para><table rows="4" cols="3"><row>
<entry thead="yes"><para>Type of Curves </para>
</entry><entry thead="yes"><para>Geometry-Traits Concept </para>
</entry><entry thead="yes"><para>Insertion Function </para>
</entry></row>
<row>
<entry thead="no"><para><formula id="7">$x$</formula>-monotone and pairwise disjoint </para>
</entry><entry thead="no"><para><computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> or <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> </para>
</entry><entry thead="no"><para><computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">CGAL::insert_non_intersecting_curve</ref>&lt;&gt;()</computeroutput> </para>
</entry></row>
<row>
<entry thead="no"><para><formula id="7">$x$</formula>-monotone </para>
</entry><entry thead="no"><para><computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> </para>
</entry><entry thead="no"><para><computeroutput>CGAL::insert&lt;&gt;()</computeroutput> </para>
</entry></row>
<row>
<entry thead="no"><para>general </para>
</entry><entry thead="no"><para><computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> </para>
</entry><entry thead="no"><para><computeroutput>CGAL::insert&lt;&gt;()</computeroutput> </para>
</entry></row>
</table>
</para>
<para>The insertion function template <computeroutput>insert()</computeroutput> is overloaded to (i) incrementally insert a single <formula id="7">$x$</formula>-monotone curve, (ii) incrementally insert a single general curve, (iii) aggregately insert a set of <formula id="7">$x$</formula>-monotone curves, and (iv) aggregately insert a set of general curves. The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">CGAL::insert_non_intersecting_curves</ref>&lt;&gt;()</computeroutput> function template aggregately inserts a set of <formula id="7">$x$</formula>-monotone pairwise interior-disjoint curves into an arrangement.</para>
</sect2>
<sect2 id="index_1arr_ssecgl_remove">
<title>Removing Vertices and Edges</title>
<para>The free functions <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> and <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" kindref="member">remove_edge()</ref></computeroutput> handle the removal of vertices and edges from an arrangement, respectively. The difference between these functions and the corresponding member functions of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template (see Section <ref refid="index_1arr_sssecmf_iso_verts" kindref="member">Manipulating Isolated Vertices</ref> and Section <ref refid="index_1arr_sssecmf_halfedges" kindref="member">Manipulating Halfedges</ref>) has to do with the ability to merge two curves associated with adjacent edges to form a single curve associated with a single edge. An attempt to remove a vertex or an edge from an arrangement object <computeroutput>arr</computeroutput> using the free functions above requires that the traits class used to instantiate the arrangement type of <computeroutput>arr</computeroutput> models the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which refines the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept; see Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref>.</para>
<para>The function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">CGAL::remove_vertex</ref>&lt;&gt;(arr, v)</computeroutput> removes the vertex <formula id="30">$v$</formula> from the given arrangement <computeroutput>arr</computeroutput>, where <formula id="30">$v$</formula> is either an isolated vertex or is a <emphasis>redundant</emphasis> vertex. Namely, it has exactly two incident edges that are associated with two curves that can be merged to form a single <formula id="7">$x$</formula>-monotone curve. If neither of the two cases apply, the function returns an indication that it has failed to remove the vertex.</para>
<para>The function <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" kindref="member">CGAL::remove_edge</ref>&lt;&gt;(arr, e)</computeroutput> removes the edge <formula id="31">$e$</formula> from the arrangement by simply calling <computeroutput>arr.remove_edge(e)</computeroutput>; see Section <ref refid="index_1arr_ssecmodify" kindref="member">Modifying the Arrangement</ref>. In addition, if either of the end vertices of <formula id="31">$e$</formula> becomes isolated or redundant after the removal of the edge, it is removed as well.</para>
<para><image type="html" name="global_removal.png"></image>
 <image type="latex" name="global_removal.png"></image>
</para>
<para>The following example demonstrates the usage of the free removal functions. It creates an arrangement of four line segment <formula id="94">$s_1,
\ldots, s_4$</formula> forming an H-shape with two horizontal edges induced by <formula id="52">$s_1$</formula> and <formula id="53">$s_2$</formula> (drawn as dashed lines). Then it removes the two horizontal edges and clears all redundant vertices (drawn as lightly shaded discs), such that the final arrangement consists of just two edges associated with the vertical line segments <formula id="95">$s_3$</formula> and <formula id="96">$s_4$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2global_removal_8cpp-example" kindref="compound">Arrangement_on_surface_2/global_removal.cpp</ref> <programlisting filename="Arrangement_on_surface_2/global_removal.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>global<sp/>removal<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arrangement<sp/>of<sp/>four<sp/>line<sp/>segments<sp/>forming<sp/>an<sp/>H-shape:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(Point(1,<sp/>3),<sp/>Point(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e1<sp/>=<sp/>arr.insert_in_face_interior(s1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s2(Point(1,<sp/>4),<sp/>Point(5,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e2<sp/>=<sp/>arr.insert_in_face_interior<sp/>(s2,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(1,<sp/>1),<sp/>Point(1,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(5,<sp/>1),<sp/>Point(5,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>initial<sp/>arrangement:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>e1<sp/>and<sp/>its<sp/>incident<sp/>vertices<sp/>using<sp/>the<sp/>function<sp/>remove_edge().</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v1<sp/>=<sp/>e1-&gt;source(),<sp/>v2<sp/>=<sp/>e1-&gt;target();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.remove_edge(e1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex</ref>(arr,<sp/>v1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex</ref>(arr,<sp/>v2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>e2<sp/>using<sp/>the<sp/>free<sp/>remove_edge()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" kindref="member">remove_edge</ref>(arr,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>final<sp/>arrangement:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssec_decompose">
<title>Vertical Decomposition</title>
<para>As you have already seen, an arrangement face may have a fairly complicated structure; its outer boundary may be very large, and it may contain numerous holes. For many practical applications, it is more convenient to analyze the faces by decomposing each into a finite number of cells (preferably convex when dealing with arrangements of linear curves) of constant complexity. Vertical decomposition is a generic way to achieve such a simplification of the arrangement.</para>
<para>Given an arrangement, we consider each arrangement vertex <formula id="30">$v$</formula>, and locate the feature lying vertically below the vertex and the feature lying vertically above it, or the unbounded face in case there is no such feature. (Such a feature is also the result of the vertical ray-shooting operation from the vertex <formula id="30">$v$</formula>, as described in Section <ref refid="index_1arr_ssecray_shoot" kindref="member">Vertical Ray Shooting</ref>.) It is now possible to construct two vertical segments connecting <formula id="30">$v$</formula> to the feature above it and to the feature below it, possibly extending the vertical segments to infinity. The collection of the vertical segments and rays computed for all arrangement vertices induces a subdivision of the arrangement into simple cells. There are two types of bounded two-dimensional cells, as follows:</para>
<para><itemizedlist>
<listitem>
<para>Cells whose outer boundaries comprise four edges, of which two originate from the original arrangement and the other two are vertical.</para>
<para></para>
</listitem>
<listitem>
<para>Cells whose outer boundaries comprise three edges, of which two originate from the original arrangement and intersect at a common vertex and the remaining one is vertical.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para><anchor id="index_1fig__aos_fig-bounded_vd"/> <image type="html" name="bounded_vertical_decomposition.png"></image>
 <image type="latex" name="bounded_vertical_decomposition.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-bounded_vd" kindref="member">fig__aos_fig-bounded_vd</ref> An arrangement of four line segments and its vertical decomposition into pseudo trapezoids, as constructed in <ref refid="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example" kindref="compound">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</ref>. The segments of the arrangement are drawn in solid blue lines and the segments of the vertical decomposition are drawn in dark dotted lines. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In the case of an arrangement of line segments, two-dimensional cells of the former type are trapezoids (as they have a pair of parallel vertical edges), while two-dimensional cells of the latter type are triangles, which can be viewed as degenerate trapezoids. The unbounded cells can be similarly categorized into two types. Observe that the boundary of an unbounded cell contains only one original edge or none and it may contain only non-vertical edges. The resulting cells are therefore referred to as <emphasis>pseudo trapezoids</emphasis>. The <ref refid="index_1fig__aos_fig-bounded_vd" kindref="member">fig__aos_fig-bounded_vd</ref> depicts the vertical decomposition of an arrangement induced by four line segments, as constructed in <ref refid="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example" kindref="compound">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</ref> and listed below. The decomposition consists of 14 pseudo trapezoids, out of which two are bounded triangles, two are bounded trapezoids, and 10 are unbounded trapezoids.</para>
<para>The function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" kindref="member">decompose()</ref></computeroutput> accepts an arrangement <formula id="63">$\mathcal{A}$</formula> and outputs for each vertex <formula id="30">$v$</formula> of <formula id="63">$\mathcal{A}$</formula> a pair of features<mdash/>one that directly lies below <formula id="30">$v$</formula> and another that directly lies above <formula id="30">$v$</formula>. It is implemented as a plane-sweep algorithm, which aggregately computes the set of pairs of features. Let <formula id="30">$v$</formula> be a vertex of <formula id="63">$\mathcal{A}$</formula>. The feature above (respectively below) <formula id="30">$v$</formula> may be one of the following:</para>
<para><itemizedlist>
<listitem>
<para>Another vertex <formula id="47">$u$</formula> having the same <formula id="7">$x$</formula>-coordinate as <formula id="30">$v$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>An arrangement edge associated with an <formula id="7">$x$</formula>-monotone curve that contains <formula id="30">$v$</formula> in its <formula id="7">$x$</formula>-range.</para>
<para></para>
</listitem>
<listitem>
<para>An unbounded face in case <formula id="30">$v$</formula> is incident to an unbounded face, and there is no curve lying above (respectively below) it.</para>
<para></para>
</listitem>
<listitem>
<para>An empty object, in case <formula id="30">$v$</formula> is the lower (respectively upper) endpoint of a vertical edge in the arrangement.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example" kindref="compound">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</ref> <programlisting filename="Arrangement_on_surface_2/bounded_vertical_decomposition.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Performing<sp/>vertical<sp/>decomposition<sp/>of<sp/>an<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_vertical_decomposition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Object_pair<sp/>=<sp/>std::pair&lt;CGAL::Object,<sp/>CGAL::Object&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vert_decomp_entry<sp/>=<sp/>std::pair&lt;Vertex_const_handle,<sp/>Object_pair&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vert_decomp_list<sp/>=<sp/>std::list&lt;Vert_decomp_entry&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>segments[]<sp/>=<sp/>{Segment(Point(0,<sp/>0),<sp/>Point(3,<sp/>3)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(3,<sp/>3),<sp/>Point(6,<sp/>0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(2,<sp/>0),<sp/>Point(5,<sp/>3)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(5,<sp/>3),<sp/>Point(8,<sp/>0))};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segments,<sp/>segments<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(segments)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>vertical<sp/>ray-shooting<sp/>from<sp/>every<sp/>vertex<sp/>and<sp/>locate<sp/>the<sp/>feature</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>lie<sp/>below<sp/>it<sp/>and<sp/>the<sp/>feature<sp/>that<sp/>lies<sp/>above<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vert_decomp_list<sp/>vd_list;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" kindref="member">CGAL::decompose</ref>(arr,<sp/>std::back_inserter(vd_list));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vd_iter<sp/>=<sp/>vd_list.begin();<sp/>vd_iter<sp/>!=<sp/>vd_list.end();<sp/>++vd_iter)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Object_pair&amp;<sp/>curr<sp/>=<sp/>vd_iter-&gt;second;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Vertex<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vd_iter-&gt;first-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_const_handle<sp/>vh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Halfedge_const_handle<sp/>hh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Face_const_handle<sp/>fh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>feature<sp/>below:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(hh,<sp/>curr.first))<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;[&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hh-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;]&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(vh,<sp/>curr.first))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vh-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;)&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(fh,<sp/>curr.first))<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;NONE&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;EMPTY&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/>feature<sp/>above:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(hh,<sp/>curr.second))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;[&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>hh-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(vh,<sp/>curr.second))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vh-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CGAL::assign(fh,<sp/>curr.second))<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;NONE\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;EMPTY\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>As you might have noticed, the code above contains a call to an instance of a the function template <computeroutput>read_objects()</computeroutput>. It reads the description of geometric objects from a file and constructs them. It accepts the name of an input file that contains the plain-text description of the geometric objects and an output iterator for storing the newly constructed objects. When the function is instantiated, the first template parameter, namely <computeroutput>Type</computeroutput>, must be substituted by the type of objects to read. It is assumed that an extractor operator (<computeroutput>&gt;&gt;</computeroutput>) that extracts objects of the given type from the input stream is available. The listing of the function template, which is defined in the file <computeroutput>read_objects.h</computeroutput>, is omitted here</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>In Section <ref refid="index_1aos_sec-unbounded" kindref="member">Arrangements of Unbounded Curves</ref> you will learn that we also support arrangements induced by unbounded curves, referred to as <emphasis>unbounded arrangements</emphasis>. For such an arrangement we maintain an imaginary rectangle with left, right, bottom, and top boundaries, which bound the concrete vertices and edges of the arrangement. Halfedges that represent the boundaries of the rectangle are <emphasis>fictitious</emphasis>. The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" kindref="member">decompose()</ref></computeroutput> function template handles unbounded arrangements. If <formula id="30">$v$</formula> is a vertex of an unbounded arrangement, and <formula id="30">$v$</formula> is incident to an unbounded face and there is no curve lying above (respectively below) it, the feature above (respectively below) <formula id="30">$v$</formula> returned by the function template <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" kindref="member">decompose()</ref></computeroutput> is a fictitious edge.</para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-unbounded">
<title>Arrangements of Unbounded Curves</title>
<para>All the arrangements constructed and manipulated in previous chapters were induced only by line segments, which are, in particular, bounded curves. Such arrangements always have one unbounded face that contains all other arrangement features. In this section we explain how to construct arrangements of unbounded curves. For simplicity of exposition, we stay with linear objects and restrict our examples in this section to lines and rays. However, the discussion in this section, as well as the software described, apply more generally to arbitrary curves in two-dimensional surfaces.</para>
<sect2 id="index_1aos_ssec-unbounded-rep">
<title>Representing Arrangements of Unbounded Curves</title>
<para>Given a set <formula id="5">$\mathcal{C}$</formula> of unbounded curves, a simple approach for representing the arrangement induced by <formula id="5">$\mathcal{C}$</formula> would be to clip the unbounded curves using an axis-parallel rectangle that contains all finite curve endpoints and intersection points between curves in <formula id="5">$\mathcal{C}$</formula>. This process would result in a set of bounded curves (line segments if <formula id="5">$\mathcal{C}$</formula> consists of lines and rays), and it would be straightforward to compute the arrangement induced by this set. However, we would like to operate directly on the unbounded curves without having to preprocess them. Moreover, if we are not given all the curves inducing the arrangement in advance, then the choice of a good bounding rectangle may change as more curves are introduced.</para>
<para><anchor id="index_1fig__aos_fig-unb_dcel"/> <image type="html" name="unb_dcel.png"></image>
 <image type="latex" name="unb_dcel.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-unb_dcel" kindref="member">fig__aos_fig-unb_dcel</ref> A DCEL representing an arrangement of four lines. Halfedges are drawn as thin arrows. The vertices <formula id="97">$v_1, \ldots, v_8$</formula> lie at infinity, and are not associated with valid points. The halfedges that connect them are fictitious, and are not associated with concrete curves. The face denoted <formula id="98">$f_0$</formula> (lightly shaded) is the fictitious &quot;unbounded face&quot; which lies outside the bounding rectangle (dashed) that bounds the actual arrangement. The four fictitious vertices <formula id="99">$v_{\rm bl}, v_{\rm tl}, v_{\rm br}$</formula> and <formula id="100">$v_{\rm tr}$</formula> represent the four corners of the imaginary bounding rectangle. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Instead of an explicit approach, we use an implicit bounding rectangle embedded in the DCEL structure. <ref refid="index_1fig__aos_fig-unb_dcel" kindref="member">fig__aos_fig-unb_dcel</ref> shows the arrangement of four lines that subdivide the plane into eight unbounded faces and two bounded ones. Notice that in this case portions of the the unbounded faces now have outer boundaries (those portions inside the bounding rectangle), and the halfedges along these outer CCBs are drawn as arrows. The bounding rectangle is drawn dashed. The vertices <formula id="101">$v_1,v_2,\ldots,v_8$</formula>, which lie on the bounding rectangle, represent the unbounded ends of the four lines that approach infinity. The halfedges connecting them, which overlap with the bounding rectangle, are not associated with geometric curves. Thus, we refer to them as <emphasis>fictitious</emphasis>. Note that the outer CCBs of the unbounded faces contain fictitious halfedges. The twins of these halfedges form together one connected component that corresponds to the entire imaginary rectangle. It forms a single hole in the face <formula id="102">$\tilde{f}$</formula>. We refer to <formula id="102">$\tilde{f}$</formula> as <emphasis>fictitious</emphasis>, since it does not correspond to a real two-dimensional cell of the arrangement. Finally, there are four additional vertices denoted by <formula id="99">$v_{\rm bl}, v_{\rm tl}, v_{\rm br}$</formula>, and <formula id="100">$v_{\rm tr}$</formula>, which coincide with the bottom-left, top-left, bottom-right, and top-right corners of the bounding rectangle, respectively. They do not lie on any curve, and are referred to as <emphasis>fictitious</emphasis> as well. These four vertices identify each of the fictitious edges as lying on the top, the bottom, the left, and the right edge of the imaginary bounding rectangle. The four fictitious vertices exist even when the arrangement is empty: In this case they are connected by four pairs of fictitious halfedges that define a single unbounded face (which represents the entire <formula id="103">$\mathbb{R}^2$</formula> plane) lying inside the imaginary bounding rectangle and a fictitious face lying outside.</para>
<para>In summary, there are four types of arrangement vertices, which differ from one another by their location with respect to the imaginary bounding rectangle as follows:</para>
<para><orderedlist>
<listitem>
<para><anchor id="index_1type-normal"/>A vertex, associated with a point in <formula id="103">$\mathbb{R}^2$</formula>. Such a vertex always lies inside the bounding rectangle and has bounded coordinates..</para>
<para></para>
</listitem>
<listitem>
<para><anchor id="index_1type-unbounded"/>A vertex that represents an unbounded end of an <formula id="7">$x$</formula>-monotone curve that approaches <formula id="104">$x = -\infty$</formula> or at <formula id="105">$x = \infty$</formula>. In case of a horizontal line or a curve with a horizontal asymptote, the <formula id="106">$y$</formula>-coordinate of the curve end may be finite (see, for example, the vertices <formula id="55">$v_2$</formula> and <formula id="107">$v_7$</formula> in <ref refid="index_1fig__aos_fig-unb_dcel" kindref="member">fig__aos_fig-unb_dcel</ref>), but in general the curve end also approaches <formula id="108">$y = \pm\infty$</formula>; see for instance the vertices <formula id="54">$v_1$</formula>, <formula id="109">$v_3$</formula>, <formula id="110">$v_6$</formula> and <formula id="111">$v_8$</formula> in <ref refid="index_1fig__aos_fig-unb_dcel" kindref="member">fig__aos_fig-unb_dcel</ref>). For convenience, we always take a &quot;tall&quot; enough bounding rectangle and treat such vertices as lying on either the left or the right rectangle edges (that is, if a curve approaches <formula id="104">$x = -\infty$</formula>, its left end will be represented by a vertex on the left edge of the bounding rectangle, and if it approaches <formula id="105">$x = \infty$</formula>, its right end will be represented by a vertex on the right edge).</para>
<para></para>
</listitem>
<listitem>
<para><anchor id="index_1typeunboundedvertical"/>A vertex that represents the unbounded end of a vertical linear curve (line or ray) or of a curve with a vertical asymptote (finite <formula id="7">$x$</formula>-coordinate and an unbounded <formula id="106">$y$</formula>-coordinate). Such a vertex always lies on one of the horizontal edges of the bounding rectangle (either the bottom one if <formula id="112">$y = -\infty$</formula>, or the top one if <formula id="113">$y = \infty$</formula>). The vertices <formula id="114">$v_4$</formula> and <formula id="115">$v_5$</formula> in <ref refid="index_1fig__aos_fig-unb_dcel" kindref="member">fig__aos_fig-unb_dcel</ref> are of this type.</para>
<para></para>
</listitem>
<listitem>
<para><anchor id="index_1typefictitious"/>The fictitious vertices that represent the four corners of the bounding rectangle.</para>
<para></para>
</listitem>
</orderedlist>
</para>
<para><anchor id="index_1fig__aos_fig-unb_asymptote"/> <image type="html" name="unb_asymptote.png"></image>
 <image type="latex" name="unb_asymptote.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-unb_asymptote" kindref="member">fig__aos_fig-unb_asymptote</ref> The portions of a horizontal line, a vertical line, and two rectangular hyperbolas with horizontal and vertical asymptotes confined to the imaginary bounding rectangle. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>A vertex (at infinity) of Type 2 or Type 3 above always has three incident edges<mdash/>one concrete edge that is associated with an unbounded portion of an <formula id="7">$x$</formula>-monotone curve, and two fictitious edges connecting the vertex to its neighboring vertices at infinity or the corners of the bounding rectangle; see <ref refid="index_1fig__aos_fig-unb_asymptote" kindref="member">fig__aos_fig-unb_asymptote</ref>. Fictitious vertices (of type 4 above) have exactly two incident fictitious edges. See Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref> for an explanation on how the traits-class interface helps impose the fact that a vertex at infinity is incident to a single non-fictitious edge.</para>
<para>The traits class that substitutes the <computeroutput>Traits</computeroutput> parameter of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template when the latter is instantiated specifies whether the arrangement instance supports unbounded curves through the definitions of some tags nested in the traits class; see Section <ref refid="index_1aos_sssec-geom_traits-concepts_basic" kindref="member">The Basic Concept</ref> for details. Every arrangement that supports unbounded curves supports bounded curves as well, but not vice versa. Maintaining an arrangement that supports unbounded curves incurs an overhead due to the necessity to manage the imaginary bounding rectangle. If you know beforehand that all input curves that induce a particular arrangement are bounded, define your arrangement accordingly. That is, use a traits class that does not support unbounded curves.</para>
<sect3 id="index_1arr_sssecunb_basic">
<title>Basic Manipulation and Traversal Methods</title>
<para>The types <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>, and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref> nested in the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template support the methods described below in addition to the ones listed in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref>. Let <formula id="30">$v$</formula>, <formula id="31">$e$</formula>, and <formula id="46">$f$</formula> be handles to a vertex of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>, a halfedge of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>, and a face of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref>, respectively.</para>
<para><itemizedlist>
<listitem>
<para>The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1aa324ce50ac500bc80bf74abad4b22d78" kindref="member"><computeroutput>v-&gt;parameter_space_in_x()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1acdc784d286542020869d294adc6101eb" kindref="member"><computeroutput>v-&gt;parameter_space_in_y()</computeroutput></ref> determine the location of the geometric embedding of the vertex <formula id="30">$v$</formula>. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1aa324ce50ac500bc80bf74abad4b22d78" kindref="member"><computeroutput>v-&gt;parameter_space_in_x()</computeroutput></ref> returns <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput> if the <formula id="7">$x$</formula>-coordinate associated with <formula id="30">$v$</formula> is finite, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref></computeroutput> if <formula id="30">$v$</formula> represents the end of a curve the <formula id="7">$x$</formula>-coordinate of which approaches <formula id="116">$-\infty$</formula>, and <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref></computeroutput> if <formula id="30">$v$</formula> represents the end of a curve the <formula id="7">$x$</formula>-coordinate of which approaches <formula id="117">$\infty$</formula>. Similarly, the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1acdc784d286542020869d294adc6101eb" kindref="member"><computeroutput>v-&gt;parameter_space_in_y()</computeroutput></ref> returns <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput> if the <formula id="106">$y$</formula>-coordinate associated with <formula id="30">$v$</formula> is finite and <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf276ca43e83c8791923154aba4584651" kindref="member">CGAL::ARR_BOTTOM_BOUNDARY</ref></computeroutput> or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf8d89294c23614f33351e94ff28e0d59" kindref="member">CGAL::ARR_TOP_BOUNDARY</ref></computeroutput> if <formula id="30">$v$</formula> represents the end of a curve the <formula id="106">$y$</formula>-coordinate of which approaches <formula id="116">$-\infty$</formula> or <formula id="117">$\infty$</formula>, respectively.</para>
<para>The nested <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref> type also provides the Boolean predicate <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ad5c3177a4fd6417300001eb286c5bc9f" kindref="member"><computeroutput>is_at_open_boundary()</computeroutput></ref>. If the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1ad5c3177a4fd6417300001eb286c5bc9f" kindref="member"><computeroutput>v-&gt;is_at_open_boundary()</computeroutput></ref> predicates evaluates to <computeroutput>false</computeroutput>, you can access the point associated with <formula id="30">$v$</formula>. Otherwise, <formula id="30">$v$</formula> is not associated with a <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aed833c3b69b94eae54994439d70a83a2" kindref="member"><computeroutput>Point_2</computeroutput></ref> object, as it represents the unbounded end of a curve that approaches infinity.</para>
<para></para>
</listitem>
<listitem>
<para>The nested <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref> type provides the Boolean predicate <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a3ee455b495c2ee20fc55403d60978004" kindref="member"><computeroutput>is_fictitious()</computeroutput></ref>. If the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge_1a3ee455b495c2ee20fc55403d60978004" kindref="member"><computeroutput>e-&gt;is_fictitious()</computeroutput></ref> evaluates to <computeroutput>false</computeroutput>, you can access the <formula id="7">$x$</formula>-monotone curve associated with <formula id="31">$e$</formula>. Otherwise, <formula id="31">$e$</formula> is not associated with an <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ad7f12c4c83fa1d83a3f0d5ceb16c21e1" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> object.</para>
<para></para>
</listitem>
<listitem>
<para>The nested <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref> type provides the Boolean predicate <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1adec2dd3f9fb8d7364c8ac7370f721be2" kindref="member"><computeroutput>is_fictitious()</computeroutput></ref>. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1adec2dd3f9fb8d7364c8ac7370f721be2" kindref="member"><computeroutput>f-&gt;is_fictitious()</computeroutput></ref> evaluates to <computeroutput>true</computeroutput> only when <formula id="46">$f$</formula> lies outside the bounding rectangle. The method <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a2fffc48e24aaa154122504983d771f1c" kindref="member"><computeroutput>outer_ccb()</computeroutput></ref> (see Section <ref refid="index_1arr_sssectr_face" kindref="member">Traversal Methods for an Arrangement Face</ref> must not be invoked for the fictitious face. Typically, the code is guarded against such malicious calls with adequate preconditions. However, these preconditions are suppressed when the code is compiled with maximum optimization. Note that a valid unbounded face (of an arrangement that supports unbounded curves) has a valid outer CCB, although the CCB comprises only fictitious halfedges if the arrangement is induced only by bounded curves.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>Let <formula id="118">$p_l = (x_l,y_l)$</formula> and <formula id="119">$p_r = (x_r,y_r)$</formula> be the left and right endpoints of a bounded <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula>, respectively. We say that a point <formula id="120">$p = (x_p,y_p)$</formula> lies in the <formula id="7">$x$</formula>-range of <formula id="8">$c$</formula> if <formula id="121">$x_l \leq x_p \leq x_r$</formula>. Let <formula id="122">$p_l =
(x_l,y_l)$</formula> be the left endpoint of an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> unbounded from the right. A point <formula id="120">$p = (x_p,y_p)$</formula> lies in the <formula id="7">$x$</formula>-range of <formula id="8">$c$</formula> if <formula id="123">$x_l \leq x_p$</formula>. Similarly, A point <formula id="120">$p = (x_p,y_p)$</formula> lies in the <formula id="7">$x$</formula>-range of an <formula id="7">$x$</formula>-monotone curve unbounded from the left if <formula id="124">$x_p \leq x_r$</formula>. Naturally, every point <formula id="125">$p \in \mathbb{R}^2$</formula> is in the <formula id="7">$x$</formula>-range of an <formula id="7">$x$</formula>-monotone curve unbounded from the left and from the right.</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>The function template <computeroutput>is_in_x_range()</computeroutput> listed below, and defined in the file <computeroutput>is_in_x_range.h</computeroutput>, checks whether a given point <formula id="59">$p$</formula> is in the <formula id="7">$x$</formula>-range of the curve associated with a given halfedge <formula id="31">$e$</formula>. The function template also exemplifies how some of the above functions can be used. The traits functor <ref refid="classArrangementBasicTraits__2_1a50f0e201b051be81f31257feab0cdab7" kindref="member"><computeroutput>Compare_x_2</computeroutput></ref> used in the code is described in Section <ref refid="index_1aos_sssec-geom_traits-concepts_basic" kindref="member">The Basic Concept</ref>.</para>
<para><programlisting><codeline><highlight class="comment">//<sp/>Check<sp/>whether<sp/>the<sp/>given<sp/>point<sp/>is<sp/>in<sp/>the<sp/>x-range<sp/>of<sp/>the<sp/>curve<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>with<sp/>the<sp/>given<sp/>halfedge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_in_x_range(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_const_handle<sp/>he,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Point_2&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Traits_2&amp;<sp/>traits)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cmp<sp/>=<sp/>traits.compare_x_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compare<sp/>p<sp/>with<sp/>the<sp/>source<sp/>vertex<sp/>(which<sp/>may<sp/>lie<sp/>at<sp/>x<sp/>=<sp/>+/-<sp/>oo).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__kernel__enums_1ga69d3e68aa488b8927506333b04400bdf" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Arr_parameter_space</ref><sp/>src_px<sp/>=<sp/>e-&gt;source()-&gt;parameter_space_in_x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__kernel__enums_1ga84351c7e66be00efccd4ab1a61070469" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Comparison_result</ref><sp/>res_s<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(src_px<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref>)<sp/>?<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>((src_px<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref>)<sp/>?<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>cmp(e-&gt;source()-&gt;point(),<sp/>p));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res_s<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref>)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compare<sp/>p<sp/>with<sp/>the<sp/>target<sp/>vertex<sp/>(which<sp/>may<sp/>lie<sp/>at<sp/>x<sp/>=<sp/>+/-<sp/>oo).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__kernel__enums_1ga69d3e68aa488b8927506333b04400bdf" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Arr_parameter_space</ref><sp/>trg_px<sp/>=<sp/>e-&gt;target()-&gt;parameter_space_in_x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__kernel__enums_1ga84351c7e66be00efccd4ab1a61070469" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Comparison_result</ref><sp/><sp/>res_t<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(trg_px<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref>)<sp/>?<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>((trg_px<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref>)<sp/>?<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref><sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>cmp(e-&gt;target()-&gt;point(),<sp/>p));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>p<sp/>lies<sp/>in<sp/>the<sp/>x-range<sp/>of<sp/>the<sp/>halfedge<sp/>iff<sp/>its<sp/>source<sp/>and<sp/>target<sp/>lie</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>at<sp/>opposite<sp/>x-positions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(res_s<sp/>!=<sp/>res_t);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
<para>It is important to observe that the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a07afeb623d32ef12745c9b368233e4ea" kindref="member"><computeroutput>arr.number_of_vertices()</computeroutput></ref> does not count the vertices at infinity in the arrangement <computeroutput>arr</computeroutput>. To find out this number you need to issue the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a6456e981d377cd6a13b0df360f3a455d" kindref="member"><computeroutput>arr.number_of_vertices_at_infinity()</computeroutput></ref>. Similarly, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ab8c9db7c49f1d4860cd47094a08a6779" kindref="member"><computeroutput>arr.number_of_edges()</computeroutput></ref> does not count the fictitious edges (whose number is always <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a6456e981d377cd6a13b0df360f3a455d" kindref="member"><computeroutput>arr.number_of_vertices_at_infinity()</computeroutput></ref> + 4) and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac8de48159182ed1dc27d508171c3adb7" kindref="member"><computeroutput>arr.number_of_faces()</computeroutput></ref> does not count the fictitious faces. The vertex, halfedge, edge, and face iterators defined by the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template only go over true features of the arrangement; namely, vertices at infinity and fictitious halfedges and fictitious faces are skipped. On the other hand, the <computeroutput>Ccb_halfedge_circulator</computeroutput> of the outer boundary of an unbounded face or the <computeroutput>Halfedge_around_vertex_circulator</computeroutput> of a vertex at infinity do traverse fictitious halfedges. While an arrangement induced by bounded curves has a single unbounded face, an arrangement induced by unbounded curves may have several unbounded faces. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1abeed5715498a29e1e7f869346998ce5d" kindref="member"><computeroutput>arr.number_of_unbounded_faces()</computeroutput></ref> returns the number of unbounded arrangement faces (Thus, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ac8de48159182ed1dc27d508171c3adb7" kindref="member"><computeroutput>arr.number_of_faces()</computeroutput></ref> - <ref refid="classCGAL_1_1Arrangement__on__surface__2_1abeed5715498a29e1e7f869346998ce5d" kindref="member"><computeroutput>arr.number_of_unbounded_faces()</computeroutput></ref> is the number of bounded faces). The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1807df960b1c3ebdb7e9afd2443b8651" kindref="member"><computeroutput>arr.unbounded_faces_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a35f815859d85d7b465a4e37129aaa08f" kindref="member"><computeroutput>arr.unbounded_faces_end()</computeroutput></ref> return iterators of the type <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a498b04d51254fac9c16472d2de9412f1" kindref="member">Arrangement_on_surface_2::Unbounded_face_iterator</ref></computeroutput> (or its non-mutable, <computeroutput>const</computeroutput>, counterpart type) that define the range of the arrangement unbounded faces. Naturally, the value-type of this iterator is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref>.</para>
<para>There is no way to directly obtain the fictitious vertices that represent the four corners of the imaginary bounding rectangle. However, you can obtain the fictitious face through the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaf85591f55aa56e0cd01dbed708cc691" kindref="member"><computeroutput>arr.fictitious_face()</computeroutput></ref>, and then iterate over the boundary of its single hole, which represents the imaginary bounding rectangle. Recall that an arrangement of bounded curves does not have a fictitious face. In this case the call above returns a null handle.</para>
<para>The example below exhibits the difference between an arrangement induced by bounded curves, which has a single unbounded face, and an arrangement induced by unbounded curves, which may have several unbounded faces. It also demonstrates the usage of the insertion function for pairwise interior-disjoint unbounded curves. In this case we use an instance of the traits class-template <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> to substitute the <computeroutput>Traits</computeroutput> parameter of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template when instantiated. This traits class-template is capable of representing line segments as well as unbounded linear curves, namely, lines and rays. Observe that objects of the <ref refid="classCGAL_1_1Arr__linear__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> type nested in this traits class-template are constructible from objects of types <ref refid="classCGAL_1_1Arr__linear__traits__2_1ac164fa9f286510a6f82b6d19f1337ea7" kindref="member"><computeroutput>Line_2</computeroutput></ref>, <ref refid="classCGAL_1_1Arr__linear__traits__2_1a9fabc6237c3e8eecaaaec8294d89ed24" kindref="member"><computeroutput>Ray_2</computeroutput></ref>, and <ref refid="classCGAL_1_1Arr__linear__traits__2_1a85c800b80f8a138ce592325131c7e9f4" kindref="member"><computeroutput>Segment_2</computeroutput></ref> also nested in the traits class-template. These three types and the <ref refid="classCGAL_1_1Arr__linear__traits__2_1a0cfd7a27d192fbad2e7756429ed64ef8" kindref="member"><computeroutput>Point_2</computeroutput></ref> type are defined by the traits class-template <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> to be the corresponding types of the kernel used to instantiate the traits class-template; see Paragraph <ref refid="index_1arr_sssectr_linear" kindref="member">The Linear-Traits Class</ref>.</para>
<para><anchor id="index_1fig__aos_fig-unbounded_non_intersecting"/> <image type="html" name="unbounded_non_intersecting.png"></image>
 <image type="latex" name="unbounded_non_intersecting.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-unbounded_non_intersecting" kindref="member">fig__aos_fig-unbounded_non_intersecting</ref> An arrangement of unbounded linear objects, as constructed in <ref refid="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The first three curves, <formula id="0">$c_1$</formula>, <formula id="1">$c_2$</formula>, and <formula id="126">$c_3$</formula>, are inserted using the specialized insertion functions for <formula id="7">$x$</formula>-monotone curves whose location in the arrangement is known. Notice that inserting an unbounded curve in the interior of an unbounded face, or from an existing vertex that represents an bounded end of the curve, may cause an unbounded face to split. (This is never the case when inserting a bounded curve<mdash/>compare with Section <ref refid="index_1arr_sssecmf_insert_cv" kindref="member">Inserting Pairwise Disjoint x-Monotone Curves</ref>.) Three additional rays are then inserted incrementally using the insertion function for <formula id="7">$x$</formula>-monotone curves, the interior of which is disjoint from all arrangement features; see the illustration in <ref refid="index_1fig__aos_fig-unbounded_non_intersecting" kindref="member">fig__aos_fig-unbounded_non_intersecting</ref>). Finally, the program prints the size of the arrangement using the function template <computeroutput>print_unbounded_arrangement_size()</computeroutput> defined in the header file <computeroutput>arr_print.h</computeroutput>. (Its listing is omitted here.) The program also traverses the outer boundaries of its six unbounded faces and prints the curves along these boundaries. The header file <computeroutput>arr_linear.h</computeroutput>, which contains the definitions used by the example program, is listed immediately after the listing of the main function.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</ref> <programlisting filename="Arrangement_on_surface_2/unbounded_non_intersecting.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>unbounded<sp/>linear<sp/>objects<sp/>using<sp/>the<sp/>insertion</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>function<sp/>for<sp/>non-intersecting<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>line<sp/>in<sp/>the<sp/>(currently<sp/>single)<sp/>unbounded<sp/>face<sp/>of<sp/>the<sp/>arrangement;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>then,<sp/>insert<sp/>a<sp/>point<sp/>that<sp/>lies<sp/>on<sp/>the<sp/>line<sp/>splitting<sp/>it<sp/>into<sp/>two.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve<sp/>c1<sp/>=<sp/>Line(Point(-1,<sp/>0),<sp/>Point(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_in_face_interior(c1,<sp/>arr.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_handle<sp/>v<sp/>=<sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gabfaca749e7d8c9547c143032a0e9df08" kindref="member">insert_point</ref>(arr,<sp/>Point(0,0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!<sp/>v-&gt;is_at_open_boundary());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>two<sp/>more<sp/>rays<sp/>using<sp/>the<sp/>specialized<sp/>insertion<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_from_right_vertex(Ray(Point(0,<sp/>0),<sp/>Point(-1,<sp/>1)),<sp/>v);<sp/></highlight><highlight class="comment">//<sp/>c2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.insert_from_left_vertex(Ray(Point(0,<sp/>0),<sp/>Point(1,<sp/>1)),<sp/>v);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>c3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>more<sp/>interior-disjoint<sp/>rays,<sp/>c4,<sp/>c5,<sp/>and<sp/>c6.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Ray(Point(0,<sp/>-1),<sp/>Point(-2,<sp/>-2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Ray(Point(0,<sp/>-1),<sp/>Point(2,<sp/>-2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Ray(Point(0,<sp/>0),<sp/>Point(0,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_unbounded_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>outer<sp/>CCBs<sp/>of<sp/>the<sp/>unbounded<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>arr.unbounded_faces_begin();<sp/>it<sp/>!=<sp/>arr.unbounded_faces_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Face<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k++<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>it-&gt;is_unbounded()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>it-&gt;number_of_holes()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Arrangement::Ccb_halfedge_const_circulator<sp/>first<sp/>=<sp/>it-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>curr<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>curr-&gt;source()-&gt;is_at_open_boundary())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement::Halfedge_const_handle<sp/>e<sp/>=<sp/>curr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>e-&gt;is_fictitious())<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[<sp/>...<sp/>]<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>e-&gt;target()-&gt;is_at_open_boundary())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;target()-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The type definitions used by the example below, as well as by other examples that use the <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref></computeroutput> class template, are listed next. These types are defined in the header file <computeroutput>arr_linear.h</computeroutput>.</para>
<para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_linear_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Ray_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ray;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::X_monotone_curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>X_monotone_curve;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Halfedge_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1arr_sssec-unb_global">
<title>Free Functions</title>
<para>All the free functions that operate on arrangements of bounded curves (see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref>) can also be applied to arrangements of unbounded curves. For example, consider a container of linear curves that has to be inserted into an arrangement object, the type of which is an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> parameter is substituted by the traits class that handles linear curves; see Section <ref refid="index_1arr_sssectr_linear" kindref="member">The Linear-Traits Class</ref>. You can do it incrementally; namely, insert the curves one by one as follows: <programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>curves.begin();<sp/>it<sp/>!=<sp/>curves.end();<sp/>++it)<sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>*it);</highlight></codeline>
</programlisting> Alternatively, the curves can be inserted aggregately using a single call as follows: <programlisting><codeline><highlight class="normal"><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>curves.begin(),<sp/>curves.end());</highlight></codeline>
</programlisting> It is also possible to issue point-location queries and vertical ray-shooting queries (see also Section <ref refid="index_1arr_secqueries" kindref="member">Issuing Queries on an Arrangement</ref>) on arrangements of lines, where the only restriction is that the query point has finite coordinates. Note that all the point-location strategies mentioned above, except the trapezoidal map strategy, are capable of handling arrangements of unbounded curves.</para>
</sect3>
</sect2>
<sect2 id="index_1arr_ssec-unb_duality">
<title>Point-Line Duality</title>
<para>In the following example we show how an arrangement of unbounded lines is utilized to solve the following problem: Given a set of points, does the set contain at least three collinear points? In this example a set of input points is read from a file. The file <computeroutput>points.dat</computeroutput> is used by default. It contains definitions of <formula id="127">$100$</formula> points randomly selected on the grid <formula id="128">$[-10000,10000]\times[-10000,10000]$</formula>. We construct an arrangement of the dual lines, where the line <formula id="129">$p^{*}$</formula> dual to the point <formula id="130">$p = (x_p, y_p)$</formula> is given by the equation <formula id="131">$y =
x_p*x - y_p$</formula>, and check whether three (or more) of the dual lines intersect at a common point, by searching for a (dual) vertex, whose degree is greater than <formula id="132">$4$</formula>. If such a vertex exists, then there are at least three dual lines that intersect at a common point, which implies that there are at least three collinear points.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dual_lines_8cpp-example" kindref="compound">Arrangement_on_surface_2/dual_lines.cpp</ref> <programlisting filename="Arrangement_on_surface_2/dual_lines.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Checking<sp/>whether<sp/>there<sp/>are<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>a<sp/>given<sp/>input<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;read_objects.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;points.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;!\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>points<sp/>from<sp/>the<sp/>file,<sp/>and<sp/>construct<sp/>their<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>integers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_1&gt;<sp/>&lt;y_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_2&gt;<sp/>&lt;y_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;x_n&gt;<sp/>&lt;y_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>point<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>read_objects&lt;Point&gt;(filename,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;X_monotone_curve&gt;<sp/>dual_lines;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>p<sp/>:<sp/>points)<sp/>dual_lines.push_back(Line(p.x(),<sp/>-1,<sp/>-p.y()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>dual<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>the<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_lines.begin(),<sp/>dual_lines.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>dual<sp/>arrangement<sp/>size:\n&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(+<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices_at_infinity()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>at<sp/>infinity)&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/><sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_unbounded_faces()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>unbounded)\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Look<sp/>for<sp/>a<sp/>vertex<sp/>whose<sp/>degree<sp/>is<sp/>greater<sp/>than<sp/>4.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(found_collinear)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Found<sp/>at<sp/>least<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>the<sp/>input<sp/>set.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;No<sp/>three<sp/>collinear<sp/>points<sp/>are<sp/>found<sp/>in<sp/>the<sp/>input<sp/>set.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Pick<sp/>two<sp/>points<sp/>from<sp/>the<sp/>input<sp/>set,<sp/>compute<sp/>their<sp/>midpoint<sp/>and<sp/>insert</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>its<sp/>dual<sp/>line<sp/>into<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>ker;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>points.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>k1<sp/>=<sp/>std::rand()<sp/>%<sp/>n,<sp/>k2<sp/>=<sp/>(k1<sp/>+<sp/>1)<sp/>%<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p_mid<sp/>=<sp/>ker.construct_midpoint_2_object()(points[k1],<sp/>points[k2]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>X_monotone_curve<sp/>dual_p_mid<sp/>=<sp/>Line(p_mid.x(),<sp/>-1,<sp/>-p_mid.y());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_p_mid);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>sure<sp/>that<sp/>we<sp/>now<sp/>have<sp/>three<sp/>collinear<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>found_collinear<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(found_collinear);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(0);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Note that there are no three collinear points among the points defined in the input file <computeroutput>points.dat</computeroutput>. In the second part of the example the existence of a collinear triple is forced and verified as follows. A line dual to the midpoint of two randomly selected points is introduced, and inserted into the arrangement. This operation is followed by a test that verifies that a vertex of degree greater than <formula id="132">$4$</formula> exists.</para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-curved_surfaces">
<title>Arrangements on Curved Surfaces</title>
<para>We are given a surface <formula id="133">$S$</formula> in <formula id="4">$\mathbb{R}^3$</formula> and a set <formula id="5">$\mathcal{C}$</formula> of curves embedded in this surface. The curves subdivide <formula id="133">$S$</formula> into cells of dimension 0 (<emphasis>vertices</emphasis>), 1 (<emphasis>edges</emphasis>), and 2 (<emphasis>faces</emphasis>). This subdivision is the <emphasis>arrangement</emphasis> <formula id="6">$\mathcal{A}(\mathcal{C})$</formula> induced by <formula id="5">$\mathcal{C}$</formula> on <formula id="133">$S$</formula>. Arrangements embedded in curved surfaces in <formula id="4">$\mathbb{R}^3$</formula> are generalizations of arrangements embedded in the plane. In this section we explain how to construct, maintain, and manipulate two-dimensional arrangements embedded in orientable parametric surfaces in three dimensions, such as planes, cylinders, spheres, and tori, and surfaces homeomorphic to them; see <ref refid="index_1fig__aos_fig-surfaces" kindref="member">fig__aos_fig-surfaces</ref>. Such arrangements have many theoretical and practical applications; see, e.g., <ref refid="citelist_1CITEREF_as-aa-00" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_cgal:bfhks-apsca-10" kindref="member">[3]</ref>, <ref refid="citelist_1CITEREF_cgal:bfhmw-apsgf-10" kindref="member">[4]</ref>, <ref refid="citelist_1CITEREF_cgal:fhktww-a-07" kindref="member">[6]</ref>, and <ref refid="citelist_1CITEREF_cgal:h-a-04" kindref="member">[8]</ref>.</para>
<para><anchor id="index_1fig__aos_fig-surfaces"/><center> <table rows="2" cols="6"><row>
<entry thead="no"><para><image type="html" name="sphere.png"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="cylinder.png"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="cone.png"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="ellipsoid.png"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="torus.png"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="paraboloid.png"></image>
td </para>
</entry></row>
<row>
<entry thead="no"><para>(a) Sphere </para>
</entry><entry thead="no"><para>(b) Cylinder </para>
</entry><entry thead="no"><para>(c) Cone </para>
</entry><entry thead="no"><para>(d) Ellipsoid </para>
</entry><entry thead="no"><para>(e) Torus </para>
</entry><entry thead="no"><para>(f) Paraboloid  </para>
</entry></row>
</table>
</center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__aos_fig-surfaces" kindref="member">fig__aos_fig-surfaces</ref> Various two-dimensional parametric surfaces, arrangements on which are supported by the framework. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<sect2 id="index_1aos_ssec-curved_surfaces-parameteric">
<title>Parametric Surfaces</title>
<para>We use <formula id="134">$\overline{\mathbb{R}}$</formula> to denote the compactified real line <formula id="135">$\mathbb{R} \cup \{-\infty,+\infty\}$</formula>. The mapping <formula id="136">$x \mapsto x/(1 - x^2)$</formula> is a homeomorphism between <formula id="137">$(-1,+1)$</formula> and <formula id="138">$\mathbb{R}$</formula> and between <formula id="139">$[-1,+1]$</formula> and <formula id="134">$\overline{\mathbb{R}}$</formula>. So you may also think of finite intervals instead of the (compactified) real line in what follows.</para>
<para>A parametric surface <formula id="133">$S$</formula> is given by a continuous function <formula id="140">$\phi_S: \Phi \rightarrow \mathbb{R}^3$</formula>, where the domain <formula id="141">$\Phi
= X \times Y$</formula> is a rectangular two-dimensional parameter space and <formula id="142">$S = \phi_S(\Phi)$</formula>. The sets <formula id="143">$X$</formula> and <formula id="144">$Y$</formula> are open, half-open, or closed intervals with endpoints in <formula id="134">$\overline{\mathbb{R}}$</formula>. We use <formula id="22">$x_{\rm min}$</formula>, <formula id="145">$x_{\rm
max}$</formula>, <formula id="24">$y_{\rm min}$</formula>, and <formula id="25">$y_{\rm max}$</formula> to denote the endpoints of <formula id="143">$X$</formula> and <formula id="144">$Y$</formula>, respectively.</para>
<para><itemizedlist>
<listitem>
<para>The left side of the boundary of <formula id="146">$\Phi$</formula> consists of the points <formula id="147">$(x_{\rm min},y)$</formula> with <formula id="148">$y \in {\rm closure}(Y)$</formula>. It is <emphasis>open</emphasis>, if <formula id="149">$x_{\rm min} \not\in X$</formula> or <formula id="150">$y\not\in Y$</formula>, and <emphasis>closed</emphasis>, otherwise. The right side is defined analogously. The bottom side consists of the points <formula id="151">$(x, y_{\rm min})$</formula> with <formula id="152">$x \notin (x_{\rm min},x_{\rm max})$</formula>; the top side is defined analogously. The bottom or top sides can also be open. Note that the &quot;corners&quot; of the parameter space belong to the vertical sides; this asymmetry corresponds to the fact that we sweep <formula id="7">$x$</formula>-monotone curves, and not <formula id="106">$y$</formula>-monotone curves. The four sides together form the boundary <formula id="153">$\partial \Phi$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A point <formula id="154">$p \in S$</formula> is <emphasis>regular</emphasis> if it has only one pre-image under <formula id="146">$\Phi$</formula>. All pre-images of a non-regular point lie in the boundary of <formula id="146">$\Phi$</formula>. In particular, <formula id="155">$\phi_S$</formula> is bijective on <formula id="156">$(x_{\rm min},x_{\rm max})\times(y_{\rm min},y_{\rm
max})$</formula>. More precisely, a non-regular point has either exactly two pre-images that lie on opposite sides of the domain, or all points of exactly one side of the domain.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>A side of the domain is contracted if <formula id="155">$\phi_S$</formula> is constant on it. The image of the side is called a <emphasis>contraction point</emphasis>.</para>
<para>The bottom and top sides of the domain (similarly for the left and right sides) are <emphasis>identified</emphasis> if <formula id="157">$\phi_S(x,y_{\rm min}) = \phi_S(x, y_{\rm max})$</formula> for all <formula id="158">$x \in X $</formula>. The curve <formula id="159">$x \mapsto \phi_S(x,y_{\rm min})$</formula> is called an <emphasis>identification curve</emphasis>.</para>
<para>Rectangles, strips, quadrants, half-planes, and planes can be modeled with <formula id="160">$\phi_S $</formula> being the identity mapping. For example, <formula id="161">$\Phi_S(x, y) = (x, y, 0)$</formula> with <formula id="162">$X = Y =(-\infty, +\infty)$</formula> parameterizes a plane. Surfaces such as paraboloids can be modeled through continuous and bijective parameterizations, for example, <formula id="163">$\phi_S(x,y) = (x,y,x^2 + y^2)$</formula>, where <formula id="164">$U = V =(-\infty, +\infty)$</formula>, defines a paraboloid of revolution. Cylinders, tori, spheres, and surfaces homeomorphic to them, require more general parameterizations. For example, the unit sphere is commonly parameterized as <formula id="165">$\phi_S(x, y) = (\cos x \cos y, \sin x \cos y, \sin y)$</formula>, where <formula id="166">$\Phi = [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}]$</formula>. With respect to this parameterization, the north and the south pole and all points on the opposite Prime (Greenwich) Meridian are non-regular. The north pole <formula id="167">$(0,0,1)$</formula> has infinitely many pre-images <formula id="168">$(x, \pi/2)$</formula> with <formula id="169">$-\pi &lt; x &lt; \pi$</formula> and so does the south pole <formula id="170">$(0,0,-1)$</formula>. The points on the opposite Prime Meridian have two pre-images each, namely <formula id="171">$(-\pi,y)$</formula> and <formula id="172">$(\pi,y)$</formula> with <formula id="173">$-\pi/2 \leq y \leq \pi/2$</formula>. We say that the top and bottom side of the domain are <emphasis>contracted</emphasis> and the left and right sides are <emphasis>identified</emphasis>. These are exactly the kinds of non-injectivity that we allow.</para>
<para>We give more examples. A <emphasis>triangle</emphasis> with corners <formula id="174">$(a_1, b_1), (a_2, b_2)$</formula>, and <formula id="175">$(a_3, b_3)$</formula> can be parameterized via <formula id="176">$\Phi = [0,1] \times [0,1]$</formula> with  <formula id="177">$\phi_S(x,y) = (a_1 + x(a_2 - a_1) + xy(a_3-a_2), b_1 +
x(b_2 - b_1) + xy(b_3-b_2), 0)$</formula>. The left side of the rectangular domain contracts to a point. An open or closed <emphasis>cylinder</emphasis> is modeled by identifying the vertical sides and having <formula id="144">$Y$</formula> open or closed, respectively. A <emphasis>torus</emphasis> is modeled by identifying the vertical sides and the horizontal sides. A <emphasis>paraboloid</emphasis> or <emphasis>half-cone</emphasis> may be modeled by identifying the vertical sides and contracting one of the horizontal sides to a point. More elegantly, they are modeled by a bijective parameterization as given above. A <emphasis>sphere</emphasis> is modeled by identifying the vertical sides and contracting both horizontal sides. A <emphasis>croissant</emphasis>, a torus with one pinch point, is modeled by identifying the vertical and identifying the horizontal sides and, in addition, contracting one of the pairs. However, the croissant is excluded by our definitions. All surfaces supported by our framework are locally homeomorphic to a disk, and hence an DCEL data-structure suffices for representing arrangements on these surfaces. The croissant is, at the pinch point, not locally homeomorphic to a disk, and hence a more general cell-tuple data structure than an DCEL would be needed.</para>
<para>A curve <formula id="84">$\gamma$</formula> is a continuous function <formula id="178">$\gamma: I \rightarrow
\Phi$</formula>, where <formula id="179">$I$</formula> is an open, half-open, or closed interval with endpoints 0 and 1, and <formula id="84">$\gamma$</formula> is injective except at a finite number of points. If <formula id="180">$0 \not\in I$</formula>, the limit <formula id="181">$\lim_{t
\rightarrow 0+} \gamma(t)$</formula> exists (in the closure of <formula id="146">$\Phi$</formula>) and lies in an open side of the boundary. Similarly, if <formula id="182">$1 \not\in I$</formula>, then <formula id="183">$\lim_{t \rightarrow 1-} \gamma(t)$</formula> exists and lies in an open side of the boundary. A curve <formula id="8">$c$</formula> in <formula id="133">$S$</formula> is the image of a curve <formula id="84">$\gamma$</formula> in the domain.</para>
<para>A curve is <emphasis>closed in the domain</emphasis> if <formula id="184">$\gamma(0) =
\gamma(1)$</formula>; in particular, <formula id="185">$0 \in I$</formula> and <formula id="186">$1 \in I$</formula>. A curve is <emphasis>closed in the surface <formula id="133">$S$</formula> (or simply closed)</emphasis> if <formula id="187">$\phi_S(\gamma(0)) = \phi_S(\gamma(1))$</formula>. A curve <formula id="84">$\gamma$</formula> has two <emphasis>ends</emphasis>, the 0-end <formula id="188">$\langle \gamma,0 \rangle$</formula> and the 1-end <formula id="189">$\langle \gamma,1 \rangle$</formula>. If <formula id="190">$d \in I$</formula>, the <formula id="72">$d$</formula>-end has a geometric interpretation. It is a point in <formula id="146">$\Phi$</formula>. If <formula id="191">$d \not\in I$</formula>, the <formula id="72">$d$</formula>-end has no geometric interpretation. You may think of it as a point on an open side of the domain or an initial or terminal segment of <formula id="84">$\gamma$</formula>. If <formula id="192">$d
\not\in I$</formula>, we say that the <formula id="72">$d$</formula>-end of the curve is open. The equator curve on the sphere in standard parameterization is given by <formula id="193">$\gamma(t) = (\pi(2t - 1),0)$</formula> for <formula id="194">$t \in [0,1]$</formula>. The <formula id="195">$0$</formula>-end of <formula id="84">$\gamma$</formula> is the point <formula id="196">$(-\pi,0)$</formula> in <formula id="146">$\Phi$</formula> and a point on the equator of the sphere. It is closed on the sphere, but not closed in <formula id="146">$\Phi$</formula>. The diagonal <formula id="197">$(u,u)$</formula> in the plane is, for example, given by <formula id="198">$\gamma(t) = (x(t),y(t))$</formula> and <formula id="199">$x(t) =
y(t) = (t - 1/2)/(t(1-t))$</formula>. Both ends of this curve are open. The <formula id="72">$d$</formula>-end of a curve <formula id="84">$\gamma$</formula> is incident to the left side if either <formula id="190">$d \in I$</formula> and <formula id="200">$\gamma(d)$</formula> lies on the left side or <formula id="192">$d
\not\in I$</formula> and <formula id="201">$\lim_{t \rightarrow d} \gamma(t)$</formula> lies on the left side, which is then an open side. Similarly for the other sides.</para>
<para>A <emphasis>strongly <formula id="7">$x$</formula>-monotone curve</emphasis> is the image of a curve <formula id="84">$\gamma$</formula>, such that if <formula id="202">$t_1 &lt; t_2$</formula> for <formula id="203">$t_1, t_2 \in I$</formula>, then <formula id="204">$x(t_1) &lt; x(t_2)$</formula>. A <emphasis>vertical curve</emphasis> is the image of a curve <formula id="84">$\gamma$</formula>, such that <formula id="205">$x(t) = C$</formula> for all <formula id="206">$t \in I$</formula> and some <formula id="207">$C \in X$</formula> and <formula id="208">$y(t_1) &lt; y(t_2)$</formula> for <formula id="209">$t_1 &lt;
t_2$</formula>. For instance, every Meridian curve of a sphere parameterized as above is vertical. An <emphasis> <formula id="7">$x$</formula>-monotone curve</emphasis> is either vertical or strongly <formula id="7">$x$</formula>-monotone.</para>
</sect2>
<sect2 id="index_1aos_ssec-curved_surfaces-aos_class">
<title>The Arrangement on Surface Class Template</title>
<para>The class template <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeomTraits, TopolTraits&gt;</computeroutput> can be used to represent a 2D arrangement embedded in a 3D surface. The template is parameterized by template parameters <emphasis>geometry traits</emphasis> and <emphasis>topology traits</emphasis>. The topology-traits type deals with the topology of the parametric surface; see Section <ref refid="index_1aos_sec-topol_traits" kindref="member">The Topology Traits</ref>. As explained in the previous section, a parametric surface <formula id="142">$S = \phi_S(\Phi)$</formula> is given by a continuous function <formula id="140">$\phi_S: \Phi \rightarrow \mathbb{R}^3$</formula>, where the domain <formula id="210">$\Phi = X \times Y$</formula> is a rectangular two-dimensional parameter space. <formula id="143">$X$</formula> and <formula id="144">$Y$</formula> are open, half-open, or closed intervals with endpoints in <formula id="134">$\overline{\mathbb{R}}$</formula>.</para>
<para>The geometry-traits type introduces the type names of the basic geometric objects (i.e., point, curve, and <formula id="7">$x$</formula>-monotone curve) and the set of operations on objects of these types required to construct and maintain the arrangement and to operate on it. The traits-concept hierarchy described in Section <ref refid="index_1aos_sec-geom_traits" kindref="member">The Geometry Traits</ref> accurately defines the requirements imposed on a model of a geometry traits class. Recall that requirements apply to the parameter space <formula id="210">$\Phi = X \times Y$</formula>; thus, they are defined in terms of <formula id="7">$x$</formula> and <formula id="106">$y$</formula> coordinates. Most requirements apply to all type of arrangements regardless of the embedding surface. However, several refined concepts apply only to arrangements on surfaces that are not in the plane, that is, modeled with <formula id="155">$\phi_S$</formula> not being the identity mapping. They differ according to the type of the side boundaries of the parameter space being open, closed, contracted, or identified.</para>
<para>At this point only one type of arrangements on non planar surfaces is supported, namely, arrangements embedded in the sphere and induced by arcs of great circles, also known as geodesic arcs. <ref refid="index_1fig__aos_fig-voronoi" kindref="member">fig__aos_fig-voronoi</ref> shows various Voronoi diagrams the bisectors of which are geodesic arcs. They are represented as arrangements induced by geodesic arcs embedded in the sphere.</para>
<para><anchor id="index_1fig__aos_fig-voronoi"/><center> <table rows="2" cols="4"><row>
<entry thead="no"><para><image type="html" name="voronoi.jpg"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="degenerate_voronoi.jpg"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="power_diagram.jpg"></image>
td </para>
</entry><entry thead="no"><para><image type="html" name="degenerate_power_diagram.jpg"></image>
td </para>
</entry></row>
<row>
<entry thead="no"><para>(a) </para>
</entry><entry thead="no"><para>(b) </para>
</entry><entry thead="no"><para>(c) </para>
</entry><entry thead="no"><para>(d)  </para>
</entry></row>
</table>
</center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__aos_fig-voronoi" kindref="member">fig__aos_fig-voronoi</ref> Voronoi diagrams on the sphere. All diagram edges are geodesic arcs. Sites are drawn in red and Voronoi edges are drawn in blue. (a) The Voronoi diagram of 32 random points. (b) A highly degenerate case of Voronoi diagram of 30 point sites on the sphere. (c) The power diagram of 10 random circles. (d) A degenerate power diagram of 14 sites on the sphere. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1aos_ssec-curved_surfaces-basic">
<title>Basic Manipulation and Traversal Methods</title>
<para>The types <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>, and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref> nested in the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput> class template support the methods listed in Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref> and in Section <ref refid="index_1arr_sssecunb_basic" kindref="member">Basic Manipulation and Traversal Methods</ref>. Additional methods supported by these types are described next. Let <formula id="30">$v$</formula>, <formula id="31">$e$</formula>, and <formula id="46">$f$</formula> be handles to a vertex of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex" kindref="compound"><computeroutput>Vertex</computeroutput></ref>, a halfedge of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge" kindref="compound"><computeroutput>Halfedge</computeroutput></ref>, and a face of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face" kindref="compound"><computeroutput>Face</computeroutput></ref>, respectively.</para>
<para><itemizedlist>
<listitem>
<para>The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1aa324ce50ac500bc80bf74abad4b22d78" kindref="member"><computeroutput>v-&gt;parameter_space_in_x()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1acdc784d286542020869d294adc6101eb" kindref="member"><computeroutput>v-&gt;parameter_space_in_y()</computeroutput></ref> determine the location of the geometric embedding of the vertex <formula id="30">$v$</formula>. The call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1aa324ce50ac500bc80bf74abad4b22d78" kindref="member"><computeroutput>v-&gt;parameter_space_in_x()</computeroutput></ref> returns <computeroutput>ARR_INTERIOR</computeroutput> if the geometric embedding of <formula id="30">$v$</formula> is a point <formula id="59">$p$</formula> the pre-image of which does not lie on the left nor on the right sides of the boundary of the parameter space. If the left and right sides are not identified, then <computeroutput>ARR_LEFT_BOUNDARY</computeroutput> or <computeroutput>ARR_RIGHT_BOUNDARY</computeroutput> are returned if the pre-image of <formula id="59">$p$</formula> lies on the left or the right side, respectively. If the left and right sides are identified, the return value is unspecified and can be either <computeroutput>ARR_LEFT_BOUNDARY</computeroutput> or <computeroutput>ARR_RIGHT_BOUNDARY</computeroutput>. Similarly, the call <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex_1acdc784d286542020869d294adc6101eb" kindref="member"><computeroutput>v-&gt;parameter_space_in_y()</computeroutput></ref> returns <computeroutput>ARR_INTERIOR</computeroutput> if the geometric embedding of <formula id="30">$v$</formula> is a point <formula id="79">$q$</formula>, the pre-image of which does not lie on the bottom nor on the top sides of the boundary of the parameter space. If the bottom and top sides are not identified, then <computeroutput>ARR_BOTTOM_BOUNDARY</computeroutput> or <computeroutput>ARR_TOP_BOUNDARY</computeroutput> are returned if the pre-image of <formula id="79">$q$</formula> lies on the bottom or the top side, respectively. If the bottom and top sides are identified, the return value is unspecified.</para>
<para>If you want to determine whether the pre-image of a point <formula id="59">$p$</formula> lies on identified sides, you need to employ one of the two traits functors <ref refid="classArrangementIdentifiedHorizontalTraits__2_1a27b52387b49e8e41a31383105b0e1271" kindref="member"><computeroutput>Is_on_x_identification_2</computeroutput></ref> or <ref refid="classArrangementIdentifiedVerticalTraits__2_1a25e81de87d3f3fe7f50668c6efb0698a" kindref="member"><computeroutput>Is_on_y_identification_2</computeroutput></ref>; see Section <ref refid="index_1aos_ssec-traits-curved" kindref="member">Supporting Unbounded Curves or Curved Surfaces</ref>. If the pre-image of an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> does not entirely lie on identified sides, you can determine the location of the pre-image of an endpoint of <formula id="8">$c$</formula> employing either the <ref refid="classArrangementVerticalSideTraits__2_1aa5f28542a43863ce2d5d5d02d40b9b31" kindref="member"><computeroutput>Parameter_space_in_x_2</computeroutput></ref> functor or the <ref refid="classArrangementHorizontalSideTraits__2_1ade2b2e1b437891f6f570f64df975636f" kindref="member"><computeroutput>Parameter_space_in_y_2</computeroutput></ref> functors; see Section <ref refid="index_1aos_ssec-traits-curved" kindref="member">Supporting Unbounded Curves or Curved Surfaces</ref>. The operations in both functors accept an enumeration that indicates the curve end, that is, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88" kindref="member">CGAL::ARR_MIN_END</ref></computeroutput> or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce" kindref="member">CGAL::ARR_MAX_END</ref></computeroutput>, in addition to the curve itself.</para>
<para></para>
</listitem>
<listitem>
<para>A face in a planar arrangement has at most one outer CCB. However, an arrangement embedded on a surface may present additional scenarios. For example, a face of an arrangement embedded on a torus may have two outer CCBs, and a face of an arrangement embedded on a sphere might be consider a hole inside the surrounding face or vice versa. To this end, outer CCBs and inner CCBs of faces of arrangements embedded on surfaces are symmetrically treated (while maintaining the invariant that a face always lies to the left of every halfedge of every CCB of the face regardless of whether the CCB is inner or outer). The classification of a CCB as inner or outer becomes an implementation detail. The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1ad0464c76e813743d7f80a82ef84e01f6" kindref="member"><computeroutput>f-&gt;outer_ccbs_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a5134b106c11cbd421f275dccb0aa2948" kindref="member"><computeroutput>f-&gt;outer_ccbs_end()</computeroutput></ref> return iterators of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a222b4b4fb958962f4604f63381bac206" kindref="member"><computeroutput>Outer_ccb_iterator</computeroutput></ref> that define a range of outer CCBs inside the face <formula id="46">$f$</formula>. Similarly, the methods <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a73238866496b4defe425b18095c31089" kindref="member"><computeroutput>f-&gt;inner_ccbs_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1ab344171878b04ec4353106385941caf3" kindref="member"><computeroutput>f-&gt;inner_ccbs_end()</computeroutput></ref> return iterators of type <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1afdf407b9a6f2d995a33e54e5ffc55925" kindref="member"><computeroutput>Inner_ccb_iterator</computeroutput></ref> that define a range of inner CCBs inside the face <formula id="46">$f$</formula>. (The latter pair of member functions and the iterator type are equivalent to the methods <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1acd9525cd21bf2cd7404fddefe4ade7fb" kindref="member"><computeroutput>holes_begin()</computeroutput></ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a64b500ed6fcd24544bc13dbde161b63a" kindref="member"><computeroutput>holes_end()</computeroutput></ref>, and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a53de656d3ec315b4cf60f385a7667b55" kindref="member"><computeroutput>Hole_iterator</computeroutput></ref>; see Section <ref refid="index_1arr_sssectr_face" kindref="member">Traversal Methods for an Arrangement Face</ref>.) The calls <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1a519d3b1c9bda314d305f69096461f303" kindref="member"><computeroutput>f-&gt;number_of_outer_ccbs()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1_1Face_1aa656d33ec8426fd3db3012632980ddae" kindref="member"><computeroutput>f-&gt;number_of_inner_ccbs()</computeroutput></ref> return the number of outer CCBs and the number of inner CCBs in <formula id="46">$f$</formula>, respectively.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>The function template <computeroutput>is_in_x_range()</computeroutput> listed below, and defined in the file <computeroutput>spherical_is_in_x_range.h</computeroutput> checks whether a given point <formula id="59">$p$</formula>, in the interior of the parameter space, is in the <formula id="7">$x$</formula>-range of an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> that represents a great-circle arc. It assumes that the left and right sides of the parameter space are identified and the bottom and top sides are contracted, which is the settings used by the traits class template <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,X,Y&gt;</computeroutput>; see Section <ref refid="index_1arr_ssectr_spherical" kindref="member">Arcs of Great Circles Embedded in the Sphere</ref>. The traits functors <ref refid="classArrangementBasicTraits__2_1ac00c8a45688aeaa21496f4a21c8e22d5" kindref="member"><computeroutput>Construct_min_vertex_2</computeroutput></ref>, <ref refid="classArrangementBasicTraits__2_1a04f2fbd7da5f539f94fab902f9bcf37d" kindref="member"><computeroutput>Construct_min_vertex_2</computeroutput></ref>, and <ref refid="classArrangementBasicTraits__2_1a50f0e201b051be81f31257feab0cdab7" kindref="member"><computeroutput>Compare_x_2</computeroutput></ref> used in the code are described is Section <ref refid="index_1aos_sssec-geom_traits-concepts_basic" kindref="member">The Basic Concept</ref>. The traits functors <ref refid="classArrangementVerticalSideTraits__2_1aa5f28542a43863ce2d5d5d02d40b9b31" kindref="member"><computeroutput>Parameter_space_in_x_2</computeroutput></ref>, <ref refid="classArrangementHorizontalSideTraits__2_1ade2b2e1b437891f6f570f64df975636f" kindref="member"><computeroutput>Parameter_space_in_y_2</computeroutput></ref>, <ref refid="classArrangementIdentifiedVerticalTraits__2_1a25e81de87d3f3fe7f50668c6efb0698a" kindref="member"><computeroutput>Is_on_y_identification_2</computeroutput></ref>, and <ref refid="classArrangementHorizontalSideTraits__2_1aa69f216050ce5fee135ae6130633ca97" kindref="member"><computeroutput>Compare_x_on_boundary_2</computeroutput></ref>, are described is Section <ref refid="index_1aos_ssec-traits-curved" kindref="member">Supporting Unbounded Curves or Curved Surfaces</ref>.</para>
<para><programlisting><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GeometryTraits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_in_x_range(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GeometryTraits::X_monotone_curve_2&amp;<sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>GeometryTraits::Point_2&amp;<sp/>p,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>GeometryTraits&amp;<sp/>traits)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL_assertion(!<sp/>traits.is_on_y_identification_2_object()(p));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(traits.is_on_y_identification_2_object()(c))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>a<sp/>great-circle<sp/>arc<sp/>that<sp/>is<sp/>incident<sp/>to<sp/>a<sp/>pole<sp/>is<sp/>vertical.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cmp_x_boundary<sp/>=<sp/>traits.compare_x_on_boundary_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psy<sp/>=<sp/>traits.parameter_space_in_y_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psy_min<sp/>=<sp/>psy(c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88" kindref="member">CGAL::ARR_MIN_END</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(psy_min<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gaf276ca43e83c8791923154aba4584651" kindref="member">CGAL::ARR_BOTTOM_BOUNDARY</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cmp_x_boundary(p,<sp/>c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88" kindref="member">CGAL::ARR_MIN_END</ref>)<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psy_max<sp/>=<sp/>psy(c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce" kindref="member">CGAL::ARR_MAX_END</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(psy_max<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gaf8d89294c23614f33351e94ff28e0d59" kindref="member">CGAL::ARR_TOP_BOUNDARY</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cmp_x_boundary(p,<sp/>c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce" kindref="member">CGAL::ARR_MAX_END</ref>)<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psx<sp/>=<sp/>traits.parameter_space_in_x_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psx_min<sp/>=<sp/>psx(c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88" kindref="member">CGAL::ARR_MIN_END</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>psx_max<sp/>=<sp/>psx(c,<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce" kindref="member">CGAL::ARR_MAX_END</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((psx_min<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref>)<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(psx_min<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref>))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cmp_x<sp/>=<sp/>traits.compare_x_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(psx_min<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>p_right<sp/>=<sp/>traits.construct_max_vertex_2_object()(c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>cmp_x(p,<sp/>p_right);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref>)<sp/>||<sp/>(res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref>));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(psx_max<sp/>==<sp/><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>p_left<sp/>=<sp/>traits.construct_min_vertex_2_object()(c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>cmp_x(p_left,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::SMALLER</ref>)<sp/>||<sp/>(res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref>));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>p_left<sp/>=<sp/>traits.construct_min_vertex_2_object()(c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>cmp_x(p_left,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref>)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>p_right<sp/>=<sp/>traits.construct_max_vertex_2_object()(c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res<sp/>=<sp/>cmp_x(p,<sp/>p_right);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::LARGER</ref>)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-geom_traits">
<title>The Geometry Traits</title>
<para>A geometry traits class encapsulates the definitions of the geometric entities and the implementation of the geometric predicates and constructions that handle these geometric entities, used by the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput> class template and by the peripheral modules. The identified minimal requirements imposed by the various algorithms that apply to arrangements are organized in a hierarchy of refined geometry-traits concepts. The requirements listed by each concept include only the utterly essential types and operations needed to implement specific algorithms. This modular structuring yields controllable parts that can be produced, maintained, and utilized with less effort. For each operation, all the preconditions that its operands must satisfy are specified as well, as these may simplify the implementation of models of these concepts even further. Each traits class models one or more concepts. This section contains a detailed description of the concepts in the refinement hierarchy and the various traits classes that model these concepts.</para>
<para>All the algebra required for constructing and manipulating arrangements is concentrated in the traits classes. The knowledge required to devise a good traits class is very different from the knowledge required for the development of the rest of the package or for using the package. It has less to do with computational geometry and it involves mainly algebra and numerical computation. This way, traits classes for new types of curves can be developed with little knowledge of algorithms and data structures in computational geometry. In this section we discuss how to use existing traits classes, but we also explain the concepts these traits classes model<mdash/>a starting point for every novice developer of such classes.</para>
<para>This section is divided into three parts. The first part describes the refinement hierarchy of the arrangement geometry-traits concepts. The second part reviews various models of these concepts. These traits classes handle different curve families, such as line segments, polylines, conic arcs, B<eacute/>zier curves, algebraic curves, and geodesic arcs on the sphere. The last part introduces decorators for geometric traits classes. A decorator of a traits class attaches auxiliary data to the geometric objects handled by the original traits class, thereby extending it.</para>
<sect2 id="index_1aos_ssec-geom_traits-concepts">
<title>The Hierarchy of the Geometry Traits Concepts</title>
<para>A hierarchy of related concepts can be viewed as a directed acyclic graph, where a node of the graph represents a concept and an arc represents a refinement relation. An arc directed from concept A to concept B indicates that concept B refines concept A. A rather large directed acyclic graph is required to capture the entire hierarchy of the geometry traits-class concepts. In the following sections we review individual clusters of the graph and describe the relations between them. <ref refid="index_1fig__aos_fig-central_concept_cluster" kindref="member">fig__aos_fig-central_concept_cluster</ref> depicts the central cluster.</para>
<para><anchor id="index_1fig__aos_fig-central_concept_cluster"/> <image type="html" name="central_concept_cluster.png"></image>
 <image type="latex" name="central_concept_cluster.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-central_concept_cluster" kindref="member">fig__aos_fig-central_concept_cluster</ref> The hierarchy of the main geometry traits concepts. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<sect3 id="index_1aos_sssec-geom_traits-concepts_basic">
<title>The Basic Concept</title>
<para>A model of the basic concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> needs to define the types <ref refid="classArrangementBasicTraits__2_1a8cfc873dc62ce86f9479c4689845d4b3" kindref="member"><computeroutput>Point_2</computeroutput></ref> and <ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref>, where objects of the former type are the geometric mapping of arrangement vertices, and objects of the latter type are the geometric mapping of edges. In addition, it has to support the set of predicates listed below. This basic set of predicates is sufficient for constructing arrangements of bounded <formula id="7">$x$</formula>-monotone curves that are pairwise disjoint in their interiors and points that do not lie in the interiors of the curves. The basic set of predicates is also sufficient for answering vertical ray-shooting queries and point-location queries with a small exception: Locating a point using the landmark strategy requires a traits class that models the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>; see Section <ref refid="index_1aos_sssec-tr_landmarks_concept" kindref="member">The Landmark Concept</ref>.</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a50f0e201b051be81f31257feab0cdab7" kindref="member"><bold><computeroutput>Compare_x_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Compares the <formula id="7">$x$</formula>-coordinates of two points.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a293a8cbafe9449891fd1480f34d0c31c" kindref="member"><bold><computeroutput>Compare_xy_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Compares two points lexicographically, first by their <formula id="7">$x$</formula>-coordinates, and if they are equal, by their <formula id="106">$y$</formula>-coordinates.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1aee2d448e95348f47d37aeb1d9d0f705c" kindref="member"><bold><computeroutput>Equal_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>There are two overloaded Boolean operators that test equality. One returns true iff two given points represent the same geometric point in the two-dimensional surface, and the second returns true iff the graphs of two given <formula id="7">$x$</formula>-monotone curves are the same.The predicate that tests equality between graphs of two <formula id="7">$x$</formula>-monotone curves is used only for testing as part of the test suite.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1ac00c8a45688aeaa21496f4a21c8e22d5" kindref="member"><bold><computeroutput>Construct_min_vertex_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Returns the lexicographically smallest (or left) endpoint of an <formula id="7">$x$</formula>-monotone curve.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a04f2fbd7da5f539f94fab902f9bcf37d" kindref="member"><bold><computeroutput>Construct_max_vertex_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Returns the lexicographically largest (or right) endpoint of an <formula id="7">$x$</formula>-monotone curve.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a64064c1508c2560a6bab217ad1b969f8" kindref="member"><bold><computeroutput>Is_vertical_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Determines whether an <formula id="7">$x$</formula>-monotone curve is vertical.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1ac87c7d7779ddf778dd8be68ad5a4fb37" kindref="member"><bold><computeroutput>Compare_y_at_x_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> and a point <formula id="59">$p$</formula> that lies in the <formula id="7">$x$</formula>-range of <formula id="8">$c$</formula>, determines whether <formula id="59">$p$</formula> is below, above or lies on <formula id="8">$c$</formula>.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a1eeadafe6fc9b9de597e61bdce250f23" kindref="member"><bold><computeroutput>Compare_y_at_x_right_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given two <formula id="7">$x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> that share a common minimal (left) endpoint <formula id="59">$p$</formula>, determines whether <formula id="0">$c_1$</formula> is above or below <formula id="1">$c_2$</formula> immediately to the right of <formula id="59">$p$</formula>, or whether the two curves overlap there. </para>
</listitem>
</variablelist>
</para>
<para>Every model of the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> needs to define a nested type named <ref refid="classArrangementBasicTraits__2_1a928de1a5dac72286c1e2dd811dcb559f" kindref="member"><computeroutput>Has_left_category</computeroutput></ref>. It determines whether the traits class supports the following predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementBasicTraits__2_1a88da529dbddab3034e71ca82d414e7e1" kindref="member"><bold><computeroutput>Compare_y_at_x_left_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given two <formula id="7">$x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> that share a common maximal (right) endpoint <formula id="59">$p$</formula>, determines whether <formula id="0">$c_1$</formula> is above or under <formula id="1">$c_2$</formula> immediately to the left of <formula id="59">$p$</formula>, or whether the two curves overlap there.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>If the <computeroutput><ref refid="classArrangementBasicTraits__2_1a928de1a5dac72286c1e2dd811dcb559f" kindref="member">ArrangementBasicTraits_2::Has_left_category</ref></computeroutput> type nested in a model of the basic concept is defined as <computeroutput>Tag_true</computeroutput>In principle, the category type may only be convertible to the tag type, but in practice the category is typically explicitly defined as the tag. the model must support the predicate. If the type is defined as <computeroutput>Tag_false</computeroutput>, we resort to an internal version, which is based just on the reduced set of provided operations. The internal version might be less efficient, but it exempts the traits developer from the providing an (efficient) implementation of this predicate<mdash/>a task that turns out to be nontrivial in some cases.</para>
<para>The basic set of predicates is sufficient for constructing arrangements of <formula id="7">$x$</formula>-monotone curves that do not reach or approach the boundary of the parameter space. The nature of the input curves, whether they are expected to reach or approach the left, right, bottom, or top side of the boundary of the parameter space, must be conveyed by the traits class. This is done through the definition of four additional nested types, namely <orderedlist>
<listitem>
<para><ref refid="classArrangementBasicTraits__2_1a71e663e1e6e125a70aedf6ab2c82e95f" kindref="member"><computeroutput>Left_side_category</computeroutput></ref>, </para>
</listitem>
<listitem>
<para><ref refid="classArrangementBasicTraits__2_1a51ec39783adcc206066f6075bee4ba77" kindref="member"><computeroutput>Right_side_category</computeroutput></ref>, </para>
</listitem>
<listitem>
<para><ref refid="classArrangementBasicTraits__2_1ad1c0c7aecbb67a46314b49271af64795" kindref="member"><computeroutput>Bottom_side_category</computeroutput></ref>, and </para>
</listitem>
<listitem>
<para><ref refid="classArrangementBasicTraits__2_1ad4077ad8b432735b265f25aa8aafa083" kindref="member"><computeroutput>Top_side_category</computeroutput></ref>. </para>
</listitem>
</orderedlist>
Each of those types must be convertible to the type <computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput> for the class to be a model of the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>.</para>
</sect3>
<sect3 id="index_1aos_sssec-geom_traits-concepts_intersecting">
<title>Intersections</title>
<para>Constructing an arrangement induced by <formula id="7">$x$</formula>-monotone curves that may intersect in their interior requires operations that are not part of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept. The additional operations are listed by the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which refines the basic arrangement geometry-traits concept described above. While models of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept still handle only <formula id="7">$x$</formula>-monotone curves, the curves are not restricted to be disjoint in their interiors. Such a model must be capable of computing points of intersection between <formula id="7">$x$</formula>-monotone curves, splitting curves at these intersection points to obtain pairs of interior-disjoint subcurves, and optionally merging pairs of subcurves. A point of intersection between two curves is also represented by the <ref refid="classArrangementBasicTraits__2_1a8cfc873dc62ce86f9479c4689845d4b3" kindref="member"><computeroutput>Point_2</computeroutput></ref> type. A model of the refined concept must define an additional type called <computeroutput>Multiplicity</computeroutput>. An object of this type indicates the multiplicity of the intersection point of two curves, also referred to as the <emphasis>intersection number</emphasis>.See, e.g., <ulink url="https://en.wikipedia.org/wiki/Intersection_number">https://en.wikipedia.org/wiki/Intersection_number</ulink> for more information about intersection numbers. Loosely speaking, if two curves intersect at a point <formula id="59">$p$</formula> but have different tangents (first derivatives) at <formula id="59">$p$</formula>, The point <formula id="59">$p$</formula> is of multiplicity 1. If the curve tangents are equal but their curvatures (second derivatives) are not, <formula id="59">$p$</formula> is of multiplicity 2, and so on. The multiplicity of points of intersection between line segments is always 1, and the multiplicity of a point of intersection between two polylines is 1 if the intersection point is interior to the corresponding two line segments of the polylines, and undefined (coded as 0) otherwise. A model of the refined concept thus has to support the following additional operations:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementXMonotoneTraits__2_1a2966f1d49ebda07d2de23a749259283f" kindref="member"><bold><computeroutput>Split_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Splits an <formula id="7">$x$</formula>-monotone curve <formula id="8">$c$</formula> into two subcurves at a given point <formula id="59">$p$</formula> that lies in the interior of <formula id="8">$c$</formula>.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementXMonotoneTraits__2_1a3d7c4f0cb7c04aa4cf124c10e556b066" kindref="member"><bold><computeroutput>Are_mergeable_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Determines whether two <formula id="211">$ x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> that share a common endpoint can be merged into a single continuous <formula id="7">$x$</formula>-monotone curve representable by the traits class.On the face of it this seems a difficult predicate to implement. In practice we use very simple tests to decide whether two curves are mergeable: We check whether their underlying curves are identical and whether they do not bend to form a non- <formula id="7">$x$</formula>-monotone curve.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementXMonotoneTraits__2_1a5fe8859feff75f588bf2000d72087fc9" kindref="member"><bold><computeroutput>Merge_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Merges two mergeable <formula id="7">$x$</formula>-monotone curves into a single curve.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementXMonotoneTraits__2_1a52bad98a97d6c02f8ea18e4a8eb78c2a" kindref="member"><bold><computeroutput>Intersect_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Computes all intersection points and overlapping sections of two given <formula id="7">$x$</formula>-monotone curves. If possible, computes also the multiplicity of each intersection point. Providing the multiplicity of an intersection point is not required, but it can expedite the arrangement construction. Typically, the multiplicity is a byproduct of the intersection computation. However, if it is not available, undefined multiplicity (coded as 0) is assumed. Having the multiplicity of intersection points while constructing arrangements enables the exploitation of the geometric knowledge intersection points may have.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>Using a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> it is possible to construct arrangements of sets of <formula id="7">$x$</formula>-monotone curves (and points) that may intersect one another. The two operations listed above, regarding the merging of curves, are optional, and should be provided only if the type <computeroutput>Has_merge_category</computeroutput> nested in a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept is defined as <computeroutput>Tag_true</computeroutput>. Otherwise, it is not possible to merge <formula id="7">$x$</formula>-monotone curve and redundant vertices may be left in the arrangement due to the removal of edges.</para>
</sect3>
<sect3 id="index_1aos_sssec-geom_traits-concepts_arbitrary">
<title>Supporting Arbitrary Curves</title>
<para>The concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> refines the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. A model of the refined concept must define an additional type that is used to represent general, not necessarily <formula id="7">$x$</formula>-monotone and not necessarily continuous, curves, named <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref>. It also has to support the subdivision of a curve of that type into a set of continuous <formula id="7">$x$</formula>-monotone curves and isolated points. For example, the curve <formula id="212">$c:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0$</formula> comprises the unit circle (the locus of all points for which <formula id="213">$x^2 + y^2 = 1$</formula>) and the origin (the singular point <formula id="214">$(0,0)$</formula>). <formula id="8">$c$</formula> should therefore be subdivided into two circular arcs, the upper part and the lower part of the unit circle, and a single isolated point. In particular a model of the refined concept has to support the following additional operation:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementTraits__2_1ae7fb20dc627766bd122192d6e5c1da57" kindref="member"><bold><computeroutput>Make_x_monotone_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Divides a given general curve of type <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref> into continuous weakly <formula id="7">$x$</formula>-monotone curves and isolated points.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>Note that a model of the refined concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> is required only when using the free <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> function templates (see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref>) that accept an object of type <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref> or a range of objects of that type. In all other cases it is sufficient to use a model of the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept.</para>
</sect3>
<sect3 id="index_1aos_sssec-tr_landmarks_concept">
<title>The Landmark Concept</title>
<para><anchor id="index_1fig__aos_fig-landmark_concept_cluster"/> <image type="html" name="landmark_concept_cluster.png"></image>
 <image type="latex" name="landmark_concept_cluster.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-landmark_concept_cluster" kindref="member">fig__aos_fig-landmark_concept_cluster</ref> The traits-concept hierarchy for arrangements associated with the landmark point-location strategy. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The type of an arrangement associated with the landmark point-location strategy (see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>) must be an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeomTraits, TopolTraits&gt;</computeroutput> class template, where the <computeroutput>GeomTraits</computeroutput> parameter is substituted by a model of the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>. (Naturally, it can also model either the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept or the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept.) The <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept refines the two concepts <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput>. Each of these two concepts, in turn, refines the concept <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput>.</para>
<para>A model of the <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> concept must define a fixed precision number type (typically the double-precision floating-point <computeroutput>double</computeroutput>) and support the operation below (in addition to fulfilling the requirements listed by the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept).</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementApproximateTraits__2_1a3551846d630a43eeb909df416f363b5f" kindref="member"><bold><computeroutput>Approximate_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given a point <computeroutput>p</computeroutput>, approximate the <formula id="7">$x$</formula> and <formula id="106">$y$</formula>-coordinates of <computeroutput>p</computeroutput> using a not necessarily multi-precision number type. We use this operation for approximate computations<mdash/>there are certain operations performed during the search for the location of the point that need not be exact, and that can be performed faster when carried out, for example, using a fixed-precision number type.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>A model of the <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> concept must support the operation below (in addition to fulfilling the requirements listed by the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept).</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementConstructXMonotoneCurveTraits__2_1addb559fd707a1be35f3f3e6a848d2d24" kindref="member"><bold><computeroutput>Construct_x_monotone_curve_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given two points <formula id="215">$p_1$</formula> and <formula id="216">$p_2$</formula>, construct an <formula id="7">$x$</formula>-monotone curve connecting <formula id="215">$p_1$</formula> and <formula id="216">$p_2$</formula>.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>Most traits classes model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept, and some also model the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept.</para>
</sect3>
<sect3 id="index_1aos_sssec-tr_additional_concepts">
<title>The Construct Curve Concept</title>
<para>The concept <computeroutput><ref refid="classArrangementConstructCurveTraits__2" kindref="compound">ArrangementConstructCurveTraits_2</ref></computeroutput> refines the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>. A model of the <computeroutput><ref refid="classArrangementConstructCurveTraits__2" kindref="compound">ArrangementConstructCurveTraits_2</ref></computeroutput> concept must support the operation below (in addition to fulfilling the requirements listed by the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept).</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementConstructCurveTraits__2_1a5240acc6e9026e8d7cd2da7e5cd2cc76" kindref="member"><bold><computeroutput>Construct_curve_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given two points <formula id="215">$p_1$</formula> and <formula id="216">$p_2$</formula>, construct a curve connecting <formula id="215">$p_1$</formula> and <formula id="216">$p_2$</formula>. </para>
</listitem>
</variablelist>
</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> class template handles polylines; see Section ~<ref refid="index_1arr_sssectr_polylines" kindref="member">The Polyline Traits Class</ref>. The type that substitutes the template parameter <computeroutput>SubcurveTraits_2</computeroutput> when <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> is instantiated must be a geometry-traits class that models the concept <computeroutput><ref refid="classArrangementConstructCurveTraits__2" kindref="compound">ArrangementConstructCurveTraits_2</ref></computeroutput> to enable the construction of polylines from a sequence of two or more points.</para>
</sect3>
<sect3 id="index_1aos_ssec-traits-curved">
<title>Supporting Unbounded Curves or Curved Surfaces</title>
<para>We descend to the bottom level of the hierarchy. The refinements described in this section provide the requirements imposed on traits classes used with arrangements induced by curves with boundary conditions. In particular, these requirements list additional operations that handle curves that either reach specific sides of the parameter-space boundary (the pre-images of their endpoints lie on boundary sides) or approach them (the pre-images of their endpoints approach boundary sides). These boundary conditions typically occur with unbounded curves or with arrangements embedded in curved surfaces. The category types <ref refid="classArrangementBasicTraits__2_1a71e663e1e6e125a70aedf6ab2c82e95f" kindref="member"><computeroutput>Left_side_category</computeroutput></ref>, <ref refid="classArrangementBasicTraits__2_1a51ec39783adcc206066f6075bee4ba77" kindref="member"><computeroutput>Right_side_category</computeroutput></ref>, <ref refid="classArrangementBasicTraits__2_1ad1c0c7aecbb67a46314b49271af64795" kindref="member"><computeroutput>Bottom_side_category</computeroutput></ref>, and <ref refid="classArrangementBasicTraits__2_1ad4077ad8b432735b265f25aa8aafa083" kindref="member"><computeroutput>Top_side_category</computeroutput></ref>, nested in every geometry traits class indicate whether the corresponding boundary side (i.e., left, right, bottom, and top) is open, closed, contracted, or identified, and whether this information is relevant at all. When all curves inserted into the arrangement are expected to neither approach nor reach that particular boundary side, the information is irrelevant. (Note that we explicitly distinguish closed-only, contracted, and identified sides, although the latter two are closed in the parameter space as well.) Each one of the categories above must be convertible to one of the tag types listed below according to the boundary condition that should be handled.</para>
<para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput> </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Arr__closed__side__tag" kindref="compound">Arr_closed_side_tag</ref></computeroutput> </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Arr__contracted__side__tag" kindref="compound">Arr_contracted_side_tag</ref></computeroutput> </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Arr__identified__side__tag" kindref="compound">Arr_identified_side_tag</ref></computeroutput> </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput></para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>For each of the four sides of the parameter space there are four available concepts, models of which can be used to handle open, closed, contracted, and identified sides, respectively. (When curves are expected to neither reach nor approach a particular side, special handling is not required; thus, there is no need for a corresponding concept.) For example, it is required that the category type <ref refid="classArrangementOpenBottomTraits__2_1ab62f6a0eb0874c017425cc84e7ec91c9" kindref="member"><computeroutput>Bottom_side_category</computeroutput></ref>, nested in models of the concept <computeroutput><ref refid="classArrangementOpenBottomTraits__2" kindref="compound">ArrangementOpenBottomTraits_2</ref></computeroutput>, is convertible to the tag type <computeroutput><ref refid="structCGAL_1_1Arr__open__side__tag" kindref="compound">Arr_open_side_tag</ref></computeroutput>. This makes for a total of 16 abstract concepts (combine one of left, right, bottom, and top with one of open, closed, contracted, identified). Any one of these individual abstract concept is useless on its own; only concepts that refine a combination of 0, 1, 2, 3, or 4 abstract concepts (which capture the conditions that occur in the four sides simultaneously) are purposeful. Theoretically, there are <formula id="217">$\sum_{i=0}^4\binom{i}{4} \cdot 4^i = 5^4 = 625$</formula> such concepts. However, only a subset of them is meaningful. If a side is identified, the opposite side must also be identified. In addition, a contracted side must be adjacent to two identified sides. While this narrows down the number of tangible concepts, the total number is still high; in practice we have used only two so far (not counting the &quot;plain&quot; concept, models of which do not handle boundary conditions at all), namely, <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementSphericalBoundaryTraits__2" kindref="compound">ArrangementSphericalBoundaryTraits_2</ref></computeroutput>; see below for more details. Many of the traits class-templates provided by the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package do not handle boundary conditions at all. Some of them, such as the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> traits (see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>) only handle bounded curves. Thus, the four category types nested in these models are defined to be <computeroutput><ref refid="structCGAL_1_1Arr__oblivious__side__tag" kindref="compound">Arr_oblivious_side_tag</ref></computeroutput>.</para>
<para><anchor id="index_1fig__aos_fig-open_concept_hierarchy"/> <image type="html" name="open_concept_hierarchy.png"></image>
 <image type="latex" name="open_concept_hierarchy.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-open_concept_hierarchy" kindref="member">fig__aos_fig-open_concept_hierarchy</ref> Bottom portion of the refinement hierarchy of the geometry-traits concepts for curves embedded in an open surface, for instance, the entire plane. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Several predicates are required to handle <formula id="7">$x$</formula>-monotone curves that approach the boundary of the parameter space. These predicates are sufficient to handle not only curves embedded in an unbounded parameter space, but also curves embedded in a bounded parameter space with open boundaries. The arrangement type instantiated with a traits class that models the combined concept <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> shown in <ref refid="index_1fig__aos_fig-open_concept_hierarchy" kindref="member">fig__aos_fig-open_concept_hierarchy</ref> can handle curves that are open in any direction. Recall that an arrangement that supports unbounded <formula id="7">$x$</formula>-monotone curves maintains an implicit bounding rectangle in the DCEL structure; see Section <ref refid="index_1aos_sec-unbounded" kindref="member">Arrangements of Unbounded Curves</ref>. If some curves inserted into an arrangement object are expected to be unbounded; namely, there exists <formula id="218">$d \in \{0,1\}$</formula> such that <formula id="219">$\lim_{t \rightarrow d}x(t) = \pm\infty$</formula> or <formula id="220">$\lim_{t
\rightarrow d}y(t) = \pm\infty$</formula> holds for at least one input curve <formula id="221">$c(t) = (x(t),y(t))$</formula>, the arrangement template must be instantiated with a model of the <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> concept.A curve that reaches the boundary of the parameter space in this case is open and unbounded.</para>
<para><anchor id="index_1fig__aos_fig-spherical_concept_hierarchy"/> <image type="html" name="spherical_concept_hierarchy.png"></image>
 <image type="latex" name="spherical_concept_hierarchy.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-spherical_concept_hierarchy" kindref="member">fig__aos_fig-spherical_concept_hierarchy</ref> Bottom portion of the refinement hierarchy of the geometry-traits concepts for curves embedded in a sphere-like parameterized surface <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>A suitable geometry-traits component for arrangements embedded in surfaces homeomorphic to a sphere is a model of the combined concept <computeroutput><ref refid="classArrangementSphericalBoundaryTraits__2" kindref="compound">ArrangementSphericalBoundaryTraits_2</ref></computeroutput> shown in <ref refid="index_1fig__aos_fig-spherical_concept_hierarchy" kindref="member">fig__aos_fig-spherical_concept_hierarchy</ref>. Here the two vertical sides of the parameter space are identified and the two horizontal sides are contracted.</para>
<para><anchor id="index_1fig__aos_fig-left_side_cluster"/> <image type="html" name="left_side_cluster.png"></image>
 <image type="latex" name="left_side_cluster.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-left_side_cluster" kindref="member">fig__aos_fig-left_side_cluster</ref> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that either reach the left side of the boundary of the parameter space or approach it. A similar hierarchy also exists for the right, bottom, and top sides. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The shared requirements for the four options of a side are collected in abstract layers called <computeroutput><ref refid="classArrangementLeftSideTraits__2" kindref="compound">ArrangementLeftSideTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementRightSideTraits__2" kindref="compound">ArrangementRightSideTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementBottomSideTraits__2" kindref="compound">ArrangementBottomSideTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementTopSideTraits__2" kindref="compound">ArrangementTopSideTraits_2</ref></computeroutput>; see, e.g., <ref refid="index_1fig__aos_fig-left_side_cluster" kindref="member">fig__aos_fig-left_side_cluster</ref>.</para>
<para><anchor id="index_1fig__aos_fig-side_clusters"/> <image type="html" name="side_clusters.png"></image>
 <image type="latex" name="side_clusters.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-side_clusters" kindref="member">fig__aos_fig-side_clusters</ref> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that either reach the vertical sides of the boundary of the parameter space or approach it, and similarly for curves that either reach or approach horizontal sides. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The shared requirements for the options of opposite sides are collected in two additional abstract layers called <computeroutput><ref refid="classArrangementVerticalSideTraits__2" kindref="compound">ArrangementVerticalSideTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementHorizontalSideTraits__2" kindref="compound">ArrangementHorizontalSideTraits_2</ref></computeroutput>; see <ref refid="index_1fig__aos_fig-side_clusters" kindref="member">fig__aos_fig-side_clusters</ref>.</para>
<para><anchor id="index_1fig__aos_fig-identified_clusters"/> <image type="html" name="identified_clusters.png"></image>
 <image type="latex" name="identified_clusters.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-identified_clusters" kindref="member">fig__aos_fig-identified_clusters</ref> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that reach the identified vertical sides of the parameter space and for curves that reach the identified horizontal sides of the parameter space. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Individual concepts for curves that reach the identified left side of the parameter space and for curves that reach the identified right side of the parameter space do not exist, because if one side is identified the opposite side must be identified as well. Similarly, individual concepts for curves that reach the identified bottom side of the parameter space and for curves that reach the identified top side of the parameter space do not exist either. Instead, the shared requirements for opposite identified sides are collected in two additional abstract concepts called <computeroutput><ref refid="classArrangementIdentifiedVerticalTraits__2" kindref="compound">ArrangementIdentifiedVerticalTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementIdentifiedHorizontalTraits__2" kindref="compound">ArrangementIdentifiedHorizontalTraits_2</ref></computeroutput>; see <ref refid="index_1fig__aos_fig-identified_clusters" kindref="member">fig__aos_fig-identified_clusters</ref>. The former lists requirements for operations that handle curves that reach identified vertical sides of the parameter space, and the latter lists requirements for operations that handle curves that reach identified horizontal sides of the parameter space.</para>
<para>In the following we list the specific requirements of all the aforementioned concepts.</para>
<para>The abstract concept <computeroutput><ref refid="classArrangementVerticalSideTraits__2" kindref="compound">ArrangementVerticalSideTraits_2</ref></computeroutput> requires the following predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementVerticalSideTraits__2_1aa5f28542a43863ce2d5d5d02d40b9b31" kindref="member"><bold><computeroutput>Parameter_space_in_x_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>This three-valued predicate is overloaded with two versions as follows:</para>
<para>(i) Given a curve <formula id="222">$c = (x(t), y(t))$</formula> and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="218">$d \in \{0,1\}$</formula>, determine the location of the <formula id="72">$d$</formula>-end of <formula id="8">$c$</formula> along the <formula id="7">$x$</formula>-dimension. Formally, if <formula id="8">$c$</formula> is open at its <formula id="72">$d$</formula>-end, determine whether <formula id="223">$\lim_{t \rightarrow d} x(t)$</formula> evaluates to <formula id="22">$x_{\rm min}$</formula>, <formula id="23">$x_{\rm max}$</formula>, or a value in between. If <formula id="8">$c$</formula> is not open at its <formula id="72">$d$</formula>-end, determine whether <formula id="224">$x(d)$</formula> is equal to <formula id="22">$x_{\rm min}$</formula>, <formula id="23">$x_{\rm max}$</formula>, or a value in between. Return <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref></computeroutput>, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput>, accordingly. If <formula id="8">$c$</formula> is vertical and lies on a vertical boundary; that is, either <formula id="225">$\forall p=(x_p, y_p) \in c$</formula> we have <formula id="226">$x_p = x_{\rm min}$</formula> or <formula id="225">$\forall p=(x_p, y_p) \in c$</formula> we have <formula id="227">$x_p = x_{\rm max}$</formula>, then the boundary side containing <formula id="8">$c$</formula> cannot be open.</para>
<para>(ii) Given a point <formula id="228">$p=(x_p, y_p)$</formula>, determine the location of the point with respect to the <formula id="7">$x$</formula>-axis. Formally, determine whether <formula id="229">$x_p$</formula> is equal to <formula id="22">$x_{\rm min}$</formula>, <formula id="23">$x_{\rm max}$</formula>, or a value in between. Return <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" kindref="member">CGAL::ARR_LEFT_BOUNDARY</ref></computeroutput>, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" kindref="member">CGAL::ARR_RIGHT_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput>, accordingly. If <formula id="59">$p$</formula> is on a vertical boundary; that is, <formula id="230">$x_p \in \{x_{\rm
min},x_{\rm max}\}$</formula>, then the boundary side containing <formula id="59">$p$</formula> cannot be open and must not be identified. In other words, this overloaded version is required only for the concepts <computeroutput><ref refid="classArrangementClosedLeftTraits__2" kindref="compound">ArrangementClosedLeftTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementClosedRightTraits__2" kindref="compound">ArrangementClosedRightTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementContractedLeftTraits__2" kindref="compound">ArrangementContractedLeftTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementContractedRightTraits__2" kindref="compound">ArrangementContractedRightTraits_2</ref></computeroutput>.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>The abstract concept <computeroutput><ref refid="classArrangementHorizontalSideTraits__2" kindref="compound">ArrangementHorizontalSideTraits_2</ref></computeroutput> requires the following predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementHorizontalSideTraits__2_1ade2b2e1b437891f6f570f64df975636f" kindref="member"><bold><computeroutput>Parameter_space_in_y_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>This three-valued predicate is overloaded with two versions as follows:</para>
<para>(i) Given a curve <formula id="222">$c = (x(t), y(t))$</formula> and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="218">$d \in \{0,1\}$</formula>, determine the location of the <formula id="72">$d$</formula>-end of <formula id="8">$c$</formula> along the <formula id="106">$y$</formula>-dimension. Formally, if <formula id="8">$c$</formula> is open at its <formula id="72">$d$</formula>-end, determine whether <formula id="231">$\lim_{t \rightarrow d} y(t)$</formula> evaluates to <formula id="24">$y_{\rm min}$</formula>, <formula id="25">$y_{\rm max}$</formula>, or a value in between. If <formula id="8">$c$</formula> is not open at its <formula id="72">$d$</formula>-end, determine whether <formula id="232">$y(d)$</formula> is equal to <formula id="24">$y_{\rm min}$</formula>, <formula id="25">$y_{\rm max}$</formula>, or a value in between. Return <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf276ca43e83c8791923154aba4584651" kindref="member">CGAL::ARR_BOTTOM_BOUNDARY</ref></computeroutput>, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf8d89294c23614f33351e94ff28e0d59" kindref="member">CGAL::ARR_TOP_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput>, accordingly. If <formula id="8">$c$</formula> is horizontal and lies on a horizontal boundary; that is, either <formula id="233">$\forall p=(x_p, y_p)
\in c, y_p = y_{\rm min}$</formula> or <formula id="234">$\forall p=(x_p, y_p) \in c, y_p =
y_{\rm max}$</formula>, then the boundary side containing <formula id="8">$c$</formula> cannot be open and must not be identified.</para>
<para>(ii) Given a point <formula id="228">$p=(x_p, y_p)$</formula>, determine the location of the point along the <formula id="106">$y$</formula>-dimension. Formally, determine whether <formula id="235">$y_p$</formula> is equal to <formula id="24">$y_{\rm min}$</formula>, <formula id="25">$y_{\rm max}$</formula>, or a value in between. Return <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf276ca43e83c8791923154aba4584651" kindref="member">CGAL::ARR_BOTTOM_BOUNDARY</ref></computeroutput>, <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gaf8d89294c23614f33351e94ff28e0d59" kindref="member">CGAL::ARR_TOP_BOUNDARY</ref></computeroutput>, or <computeroutput><ref refid="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" kindref="member">CGAL::ARR_INTERIOR</ref></computeroutput>, accordingly. If <formula id="59">$p$</formula> is on a horizontal boundary; that is, <formula id="236">$y_p \in \{y_{\rm
min},y_{\rm max}\}$</formula>, then the boundary side containing <formula id="59">$p$</formula> cannot be open and must not be identified. In other words, this overloaded version is required only for the concepts <computeroutput><ref refid="classArrangementClosedBottomTraits__2" kindref="compound">ArrangementClosedBottomTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementClosedTopTraits__2" kindref="compound">ArrangementClosedTopTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementContractedBottomTraits__2" kindref="compound">ArrangementContractedBottomTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementContractedTopTraits__2" kindref="compound">ArrangementContractedTopTraits_2</ref></computeroutput>.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>The two symmetric predicates above determine the location of a curve-end in the parameter space. However, in general, <formula id="7">$x$</formula>-coordinates and <formula id="106">$y$</formula>-coordinates are handled differently. This asymmetry is brought on by the various algorithms applied to arrangements, the input and output arguments of which are <formula id="7">$x$</formula>-monotone curves. Indeed, all curves maintained by any arrangement are continuous weakly <formula id="7">$x$</formula>-monotone curves. A non <formula id="7">$x$</formula>-monotone curve is divided into <formula id="7">$x$</formula>-monotone sub curves (and perhaps points) before it is inserted into an arrangement. This asymmetry is also reflected in the predicates listed below. They help determining the order of curve-ends lying on the boundary of the parameter space with respect to regular points and among each other.</para>
<para>The concepts <computeroutput><ref refid="classArrangementClosedLeftTraits__2" kindref="compound">ArrangementClosedLeftTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementClosedRightTraits__2" kindref="compound">ArrangementClosedRightTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementIdentifiedVerticalTraits__2" kindref="compound">ArrangementIdentifiedVerticalTraits_2</ref></computeroutput> require the following additional predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementIdentifiedVerticalTraits__2_1adfcd161dd6bea7754bec8c51a85a527e" kindref="member"><bold><computeroutput>Compare_y_on_boundary_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>Given two points <formula id="237">$p_1=(x_{p_1},y_{p_1})$</formula> and <formula id="238">$p_2=(x_{p_2},y_{p_2})$</formula>, such that at least one of them lies on a vertical boundary side, compare the <formula id="106">$y$</formula>-coordinates of the points. That is, compare <formula id="239">$y_{p_1}$</formula> and <formula id="240">$y_{p_2}$</formula>. If <formula id="215">$p_1$</formula> (resp. <formula id="216">$p_2$</formula>) is on the boundary; that is, <formula id="241">$x_{p_1} \in \{x_{\rm
min},x_{\rm max}\}$</formula> (resp. <formula id="242">$x_{p_2} \in \{x_{\rm min},x_{\rm
max}\}$</formula>), then the vertical boundary side containing <formula id="215">$p_1$</formula> (resp. <formula id="216">$p_2$</formula>) must be either closed or identified. In other words, this overloaded version is required only for the concepts <computeroutput><ref refid="classArrangementClosedLeftTraits__2" kindref="compound">ArrangementClosedLeftTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementClosedRightTraits__2" kindref="compound">ArrangementClosedRightTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementIdentifiedVerticalTraits__2" kindref="compound">ArrangementIdentifiedVerticalTraits_2</ref></computeroutput>.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>The concept <computeroutput><ref refid="classArrangementVerticalSideTraits__2" kindref="compound">ArrangementVerticalSideTraits_2</ref></computeroutput> requires the following additional predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementVerticalSideTraits__2_1a4c3194c1e03aa351ccb19a820ff3fcc9" kindref="member"><bold><computeroutput>Compare_y_near_boundary_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para><table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="compare_y_near_boundary.png"></image>
 <image type="latex" name="compare_y_near_boundary.png"></image>
  </para>
</entry><entry thead="no"><para></para>
<para>Given two <formula id="7">$x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula>, and an enumerator <formula id="243">$i$</formula> that specifies either the minimum ends or the maximum ends of the two curves, and thus maps to a parameter value <formula id="218">$d \in \{0,1\}$</formula>, compare the <formula id="106">$y$</formula>-coordinates of the curves near their respective ends. More precisely, compare the <formula id="106">$y$</formula>-coordinates of the vertical projections of a point <formula id="59">$p$</formula> onto <formula id="0">$c_1$</formula> and onto <formula id="1">$c_2$</formula>. If the enumerator <formula id="243">$i$</formula> specifies the minimum ends, the curves must approach the left boundary-side. In this case <formula id="59">$p$</formula> is located sufficiently close to the left boundary-side, such that the result is invariant under a translation of <formula id="59">$p$</formula> closer to the left boundary-side. If <formula id="243">$i$</formula> specifies the maximum ends, the curves must approach the right boundary-side. In that case <formula id="59">$p$</formula> is located sufficiently close to the right boundary-side in a similar manner.</para>
<para></para>
</entry></row>
</table>
</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>The concept <computeroutput><ref refid="classArrangementHorizontalSideTraits__2" kindref="compound">ArrangementHorizontalSideTraits_2</ref></computeroutput> requires two additional predicates:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementHorizontalSideTraits__2_1aa69f216050ce5fee135ae6130633ca97" kindref="member"><bold><computeroutput>Compare_x_on_boundary_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>This predicate is overloaded with three versions. We distinguish between open and non-open sides as explained below.</para>
<para>(i) Given a regular point <formula id="244">$p=(x_p,y_p)$</formula>, an <formula id="7">$x$</formula>-monotone curve <formula id="245">$c = (x(t),y(t))$</formula>, and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value <formula id="218">$d \in \{0,1\}$</formula>, compare the <formula id="7">$x$</formula>-coordinate of <formula id="59">$p$</formula> and the <formula id="7">$x$</formula>-coordinate of <formula id="8">$c$</formula> at its respective limit or end depending on whether it is open or non-open. More precisely, if <formula id="8">$c$</formula> is open at its <formula id="72">$d$</formula>-end, compare the values <formula id="229">$x_p$</formula> and <formula id="223">$\lim_{t \rightarrow d} x(t)$</formula>. A precondition assures that <formula id="8">$c$</formula> has a vertical asymptote at its <formula id="72">$d$</formula>-end; that is <formula id="246">$\lim_{t
\rightarrow d} x(t)$</formula> is a real value. If <formula id="8">$c$</formula> is not open, compare the values <formula id="229">$x_p$</formula> and <formula id="224">$x(d)$</formula>.</para>
<para><table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="compare_x_on_boundary.png"></image>
 <image type="latex" name="compare_x_on_boundary.png"></image>
  </para>
</entry><entry thead="no"><para></para>
<para>(ii) Given two curves <formula id="247">$c_1 = (x_1(t),y_1(t))$</formula> and <formula id="248">$c_2 =
(x_2(t),x_2(t))$</formula> and enumerators that specify either the minimum end or the maximum end of each curve, and thus map to parameter values <formula id="249">$d_1, d_2 \in \{0,1\}$</formula>, compare the <formula id="7">$x$</formula>-coordinates of the curves at their respective limits or ends. More precisely, if <formula id="0">$c_1$</formula> (resp. <formula id="1">$c_2$</formula>) is open at its <formula id="250">$d_1$</formula>-end (resp. <formula id="251">$d_2$</formula>-end), use the value <formula id="252">$\lim_{t \rightarrow d_1}
x_1(t)$</formula> (resp. <formula id="253">$\lim_{t \rightarrow d_2} x_2(t)$</formula>) for the comparison. A precondition assures that <formula id="0">$c_1$</formula> (resp. <formula id="1">$c_2$</formula>) has a vertical asymptote at its <formula id="250">$d_1$</formula>-end (resp. <formula id="251">$d_2$</formula>-end); that is <formula id="254">$\lim_{t \rightarrow d_1} x_1(t)$</formula> is (resp. <formula id="255">$\lim_{t
\rightarrow d_2} x_2(t)$</formula>) a real value. If <formula id="0">$c_1$</formula> (resp. <formula id="1">$c_2$</formula>) is not open at its <formula id="250">$d_1$</formula>-end (resp. <formula id="251">$d_2$</formula>-end), use the value <formula id="256">$x_1(d_1)$</formula> (resp. <formula id="257">$x_2(d_2)$</formula>) for the comparison.</para>
<para></para>
</entry></row>
</table>
</para>
<para>(iii) Given two points <formula id="237">$p_1=(x_{p_1},y_{p_1})$</formula> and <formula id="238">$p_2=(x_{p_2},y_{p_2})$</formula>, such that at least one of them lies on a horizontal boundary side, compare the <formula id="7">$x$</formula>-coordinates of the points. That is, compare <formula id="258">$x_{p_1}$</formula> and <formula id="259">$x_{p_2}$</formula>. If <formula id="215">$p_1$</formula> (resp. <formula id="216">$p_2$</formula>) is on the boundary; that is, <formula id="260">$y_{p_1} \in \{y_{\rm
min},y_{\rm max}\}$</formula> (resp. <formula id="261">$y_{p_2} \in \{y_{\rm min},y_{\rm
max}\}$</formula>), then the boundary side containing <formula id="215">$p_1$</formula> (resp. <formula id="216">$p_2$</formula>) must be either closed or identified. In other words, this overloaded version is required only for the concepts <computeroutput><ref refid="classArrangementClosedBottomTraits__2" kindref="compound">ArrangementClosedBottomTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementClosedTopTraits__2" kindref="compound">ArrangementClosedTopTraits_2</ref></computeroutput>, and <computeroutput><ref refid="classArrangementIdentifiedHorizontalTraits__2" kindref="compound">ArrangementIdentifiedHorizontalTraits_2</ref></computeroutput>.</para>
<para></para>
</listitem>
<varlistentry><term><ref refid="classArrangementHorizontalSideTraits__2_1a2209149517f07ed6f82db58d8d68f6e9" kindref="member"><bold><computeroutput>Compare_x_near_boundary_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para><table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="compare_x_near_boundary.png"></image>
 <image type="latex" name="compare_x_near_boundary.png"></image>
  </para>
</entry><entry thead="no"><para></para>
<para>Given two <formula id="7">$x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> and an enumerator <formula id="243">$i$</formula> that specifies either the minimum ends or the maximum ends of the two curves, and thus map to parameter values <formula id="249">$d_1, d_2 \in \{0,1\}$</formula>, respectively, compare the <formula id="7">$x$</formula>-coordinate of the curves near their respective limits or ends. A precondition assures that the <formula id="7">$x$</formula>-coordinates of the limits or ends of the curves at their respective ends are equal. That is, the predicate <computeroutput>Compare_x_on_boundary_2</computeroutput> applied to <formula id="0">$c_1$</formula>, <formula id="1">$c_2$</formula>, and <formula id="243">$i$</formula> evaluates to <computeroutput><ref refid="group__kernel__enums_1gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::EQUAL</ref></computeroutput>. Formally, compare the <formula id="7">$x$</formula>-coordinates of the horizontal projection of a point <formula id="59">$p$</formula> onto <formula id="0">$c_1$</formula> and onto <formula id="1">$c_2$</formula>. A precondition assures that <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> have vertical asymptotes at their respective ends. Furthermore, both curves approach the same boundary-side, either the bottom or the top, at their respective ends. If both curves approach the bottom boundary-side, <formula id="59">$p$</formula> is located far to the bottom, such that the result is invariant under a translation of <formula id="59">$p$</formula> farther to the bottom. If both curves approach the top boundary-side, <formula id="59">$p$</formula> is located far to the top in a similar manner.</para>
<para></para>
</entry></row>
</table>
</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>The concept <computeroutput><ref refid="classArrangementIdentifiedVerticalTraits__2" kindref="compound">ArrangementIdentifiedVerticalTraits_2</ref></computeroutput> requires the following additional predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementIdentifiedVerticalTraits__2_1a25e81de87d3f3fe7f50668c6efb0698a" kindref="member"><bold><computeroutput>Is_on_y_identification_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>This predicate is overloaded with two versions.</para>
<para>(i) Given a point <formula id="228">$p=(x_p, y_p)$</formula>, determine whether <formula id="59">$p$</formula> lies in the image of the vertical (and identified) sides of the boundary. More precisely, determine whether <formula id="230">$x_p \in \{x_{\rm
min},x_{\rm max}\}$</formula> for all pre-images of <formula id="59">$p$</formula>.</para>
<para>(ii) Given a curve <formula id="8">$c$</formula>, determine whether the entire curve <formula id="8">$c$</formula> lies in the image of the vertical (and identified) sides of the boundary.</para>
<para></para>
</listitem>
</variablelist>
</para>
<para>Similarly, the concept <computeroutput><ref refid="classArrangementIdentifiedHorizontalTraits__2" kindref="compound">ArrangementIdentifiedHorizontalTraits_2</ref></computeroutput> requires the following additional predicate:</para>
<para><variablelist>
<varlistentry><term><ref refid="classArrangementIdentifiedHorizontalTraits__2_1a27b52387b49e8e41a31383105b0e1271" kindref="member"><bold><computeroutput>Is_on_x_identification_2</computeroutput></bold></ref>: </term></varlistentry>
<listitem><para>This predicate is overloaded with two versions.</para>
<para>(i) Given a point <formula id="228">$p=(x_p, y_p)$</formula>, determine whether <formula id="59">$p$</formula> lies in the image of the horizontal (and identified) sides of the boundary. More precisely, determine whether <formula id="236">$y_p \in \{y_{\rm
min},y_{\rm max}\}$</formula> for all pre-images of <formula id="59">$p$</formula>.</para>
<para>(ii) Given a curve <formula id="8">$c$</formula>, determine whether the entire curve <formula id="8">$c$</formula> lies in the image of the horizontal (and identified) sides of the boundary.</para>
<para></para>
</listitem>
</variablelist>
</para>
</sect3>
</sect2>
<sect2 id="index_1aos_ssec-geom_traits-models">
<title>Models of the Geometry Traits Concepts</title>
<para>In this section we review the traits classes that are models of concepts introduced in the previous sections. They handle line segments, circular arcs, polylines, conic arcs, rational functions, arcs of B<eacute/>zier, and arcs of algebraic curves. The last subsection describes decorators for geometric traits classes distributed with CGAL, which extend geometric traits-classes by attaching auxiliary data with the geometric objects.</para>
<sect3 id="index_1arr_ssectr_segs">
<title>Traits Classes for Line Segments and Linear Objects</title>
<para>There are two distinct traits classes that handle line segments. One caches information in the curve records (see Section <ref refid="index_1arr_sssectr_caching_segs" kindref="member">The Caching Segment-Traits Class</ref>), while the other retains the minimal amount of data (see Section <ref refid="index_1arr_sssectr_non_caching_segs" kindref="member">The Non-Caching Segment-Traits Class</ref>). Operations on arrangements instantiated with the former traits class consume more space, but they are more efficient for dense arrangements (namely, arrangements induced by line segments with a large number of intersections). Another model handles not only (bounded) line segments, but also rays and lines; see Section <ref refid="index_1arr_sssectr_linear" kindref="member">The Linear-Traits Class</ref>.</para>
<sect4 id="index_1arr_sssectr_caching_segs">
<title>The Caching Segment-Traits Class</title>
<para>An instance of the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template used in most example programs so far is instantiated by substituting the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> template parameter with a geometric kernel that must conform to the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> concept; see Package <ref refid="group__PkgKernel23Concepts" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Concepts</ref>. This traits class defines its point type to be the <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> type. However, neither the <ref refid="classCGAL_1_1Arr__segment__traits__2_1ae9748d8e9803fc46af307d41f8613b79" kindref="member"><computeroutput>Curve_2</computeroutput></ref> nor the <ref refid="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> nested types of the traits are defined as the <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> type. A kernel segment is represented by its two endpoints, and these may have a large bit size representation when the segment is the result of several split operations in comparison with the representation of the original-segment endpoints. The large bit size representation may significantly slow down the various traits-class operations involving such segments. (A straightforward solution would be to repeatedly normalize the results of all computations. However, our experience shows that indiscriminate normalization considerably slows down the arrangement construction.)</para>
<para>In contrast, the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template represents a segment using its supporting line in addition to the two endpoints. Most computations are performed on the supporting line, which never changes as the segment is split. The <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template also caches some additional information with each segment to speed up various predicates, i.e., two Boolean flags indicating (i) whether the segment is vertical and (ii) whether the segment target-point is lexicographically larger than its source. The calculation of the supporting line and two Boolean flags is delayed to the point in time when needed to achieve further improvement in efficiency. An <ref refid="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> object is still constructible from two endpoints or from a kernel segment and converted to an <computeroutput>X_monotone_curve_2</computeroutput> object. Moreover, an <ref refid="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> instance can also be cast or to a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. The two types are thus convertible to one another.</para>
<para>Computing the intersection between two segments is preceded by an application of an efficient predicate that tests whether an intersection exists at all. This optimization has negligible overhead; Thus, using an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template is still very efficient when constructing arrangements induced by line segments with a large number of intersections. Efficiency is affected by the substituted geometric kernel. Using <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> as the kernel type is in general not a bad choice; the coordinates of the segment endpoints are represented as multi-precision rational numbers, which ensures the correctness of all computations regardless of the input. Computations on multi-precision number types (such as <computeroutput><ref refid="classCGAL_1_1Gmpq" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Gmpq</ref></computeroutput>) take longer than computations on machine-precision floating-point. A kernel object of the aforementioned type uses numerical filtering to expedite computation; see <computeroutput>Kernel_2</computeroutput> and <computeroutput>Kernel_3</computeroutput>. If the input set of line segments do not have degeneracies; namely, no two segments in the set share a common endpoint, and no three segments intersect at a common point, or at least, degeneracies exist but their number is relatively small, then filtered computation incurs only negligible overhead compared to floating-point arithmetic, which is error-prone. Indeed, in almost all examples and applications given in this manual, the predefined filtered kernel <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> is used to instantiate the line-segment traits class.</para>
<para><anchor id="index_1fig__aos_figpredef_kernels"/> <center> <table rows="1" cols="2"><row>
<entry thead="no"><para><image type="html" name="fan_grids.png"></image>
 <image type="latex" name="fan_grids.png" width="7.5cm"></image>
  </para>
</entry><entry thead="no"><para><image type="html" name="Europe.png"></image>
 <image type="latex" name="Europe.png" width="7.5cm"></image>
   </para>
</entry></row>
</table>
</center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_figpredef_kernels" kindref="member">fig__aos_figpredef_kernels</ref> (a) An arrangement of <formula id="262">$104$</formula> line segments from the input file <computeroutput>fan_grids.dat</computeroutput>. (b) An arrangement of more than <formula id="263">$3000$</formula> interior disjoint line segments, defined in the input file <computeroutput>Europe.dat</computeroutput>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In the following example we use the predefined <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput> for instantiating our segment-traits class. This kernel uses interval arithmetic to filter the exact computations. The program reads a set of line segments with integer coordinates from a file and computes their arrangement. By default it opens the <computeroutput>fan_grids.dat</computeroutput> input-file, located in the examples folder, which contains <formula id="262">$104$</formula> line segments that form four &quot;fan-like&quot; grids and induce a dense arrangement, as illustrated in <ref refid="index_1fig__aos_figpredef_kernels" kindref="member">fig__aos_figpredef_kernels</ref> (a):</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2predefined_kernel_8cpp-example" kindref="compound">Arrangement_on_surface_2/predefined_kernel.cpp</ref> <programlisting filename="Arrangement_on_surface_2/predefined_kernel.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>intersecting<sp/>line<sp/>segments<sp/>using<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>predefined<sp/>kernel<sp/>with<sp/>exact<sp/>constructions<sp/>and<sp/>exact<sp/>predicates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;chrono&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;read_objects.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>fan_grids.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;fan_grids.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment&gt;<sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>read_objects&lt;Segment&gt;(filename,<sp/>std::back_inserter(segments));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>all<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Performing<sp/>aggregated<sp/>insertion<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>segments.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>segments.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>start<sp/>=<sp/>std::chrono::system_clock::now();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segments.begin(),<sp/>segments.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::chrono::duration&lt;double&gt;<sp/>secs<sp/>=<sp/>std::chrono::system_clock::now()<sp/>-<sp/>start;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs.count()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1arr_sssectr_non_caching_segs">
<title>The Non-Caching Segment-Traits Class</title>
<para>The arrangement package offers an alternative segment-traits class template that handles line segments, namely the <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">Arr_non_caching_segment_basic_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template. This class template and the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class template are both parameterized by a geometric kernel and model the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>. They also model the refined concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>, which enables Boolean set operations; see Package <ref refid="group__PkgBooleanSetOperations2Ref" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations Reference</ref>. The class template <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> derives from the instance <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">Arr_non_caching_segment_basic_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput>, which models the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> traits concept but not the refined <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Like the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template it derives from the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> type. Unlike the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template it defines its point and segment types as <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> and <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput>, respectively, and most of its defined operations are delegations of the corresponding operations of the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> type. For example, the functor <computeroutput>Compare_xy_2</computeroutput> is defined as <computeroutput>Kernel::Compare_xy_2</computeroutput>. The remaining operations are defined in terms of just a few other kernel operations. For example, the <computeroutput>Compare_y_at_x_right_2</computeroutput> predicate is defined in terms of the <computeroutput>Kernel::Compare_slope_2</computeroutput> predicate (ignoring preconditions for the sake of clarity); see Section <ref refid="index_1aos_sssec-geom_traits-concepts_basic" kindref="member">The Basic Concept</ref> for the description of this predicate. The class template <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">Arr_non_caching_segment_basic_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> is slightly less efficient than the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template for constructing arrangements of pairwise interior-disjoint line-segments in many cases, as it does not exploit caching at all. Nevertheless, you may choose to use this traits class, as it consumes less memory. For arrangements of line segments that do intersect you may use the class template <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput>. However, the performance difference in favor of the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template is much larger, especially when the number of intersections is large.</para>
<para>In the following example we read an input file containing a set of line segments that are pairwise disjoint in their interior. As the segments do not intersect, no new points are constructed and we can instantiate the <computeroutput>Arr_non_caching_segment_traits_basic_2&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class-template with the predefined <computeroutput><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_inexact_constructions_kernel</ref></computeroutput>. Note that we use the <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves()</ref></computeroutput> function to construct the arrangement. By default, the example opens the <computeroutput>Europe.dat</computeroutput> input-file, located in the examples folder, which contains more than <formula id="263">$3000$</formula> line segments with floating-point coordinates that form the map of Europe, as depicted in <ref refid="index_1fig__aos_figpredef_kernels" kindref="member">fig__aos_figpredef_kernels</ref> (b):</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2predefined_kernel_non_intersecting_8cpp-example" kindref="compound">Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp</ref> <programlisting filename="Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>non-intersecting<sp/>line<sp/>segments<sp/>using<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>predefined<sp/>kernel<sp/>with<sp/>exact<sp/>predicates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;chrono&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_non_caching_segment_basic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Number_type<sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Traits_2<sp/>=<sp/><ref refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" kindref="compound">CGAL::Arr_non_caching_segment_basic_traits_2&lt;Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/>Traits_2::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Segment_2</ref><sp/>=<sp/>Traits_2::X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref><sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits_2&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Europe.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;Europe.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Open<sp/>the<sp/>input<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(filename);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>in_file.is_open())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Failed<sp/>to<sp/>open<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>filename<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>...\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>segments<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>input<sp/>file<sp/>format<sp/>should<sp/>be<sp/>(all<sp/>coordinate<sp/>values<sp/>are<sp/>double</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>precision<sp/>floating-point<sp/>numbers):</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>number<sp/>of<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_1&gt;<sp/>&lt;sy_1&gt;<sp/><sp/>&lt;tx_1&gt;<sp/>&lt;ty_1&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_2&gt;<sp/>&lt;sy_2&gt;<sp/><sp/>&lt;tx_2&gt;<sp/>&lt;ty_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/><sp/><sp/><sp/><sp/><sp/>:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>&lt;sx_n&gt;<sp/>&lt;sy_n&gt;<sp/><sp/>&lt;tx_n&gt;<sp/>&lt;ty_n&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>source<sp/>and<sp/>target<sp/>of<sp/>segment<sp/>#n.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Segment_2&gt;<sp/><sp/>segments;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sx,<sp/>sy,<sp/>tx,<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>sx<sp/>&gt;&gt;<sp/>sy<sp/>&gt;&gt;<sp/>tx<sp/>&gt;&gt;<sp/>ty;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segments.push_back(<ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Segment_2</ref>(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>(Number_type(sx),<sp/>Number_type(sy)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>(Number_type(tx),<sp/>Number_type(ty))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>all<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Performing<sp/>aggregated<sp/>insertion<sp/>of<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>n<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>segments.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>start<sp/>=<sp/>std::chrono::system_clock::now();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" kindref="member">insert_non_intersecting_curves</ref><sp/>(arr,<sp/>segments.begin(),<sp/>segments.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::chrono::duration&lt;double&gt;<sp/>secs<sp/>=<sp/>std::chrono::system_clock::now()<sp/>-<sp/>start;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>dimensions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;V<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_vertices()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>E<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_edges()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>F<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Construction<sp/>took<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>secs.count()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>seconds.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1arr_sssectr_linear">
<title>The Linear-Traits Class</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class used in Section <ref refid="index_1aos_sec-unbounded" kindref="member">Arrangements of Unbounded Curves</ref> for demonstrating the construction of arrangements of unbounded curves is capable of handling bounded and unbounded linear objects, namely, lines, rays, and line segments. It models the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>, <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>, and <computeroutput>{<ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput>. It is parameterized by a geometric kernel and its nested <ref refid="classCGAL_1_1Arr__linear__traits__2_1a0cfd7a27d192fbad2e7756429ed64ef8" kindref="member"><computeroutput>Point_2</computeroutput></ref> type is defined to be the kernel-point type. The <ref refid="classCGAL_1_1Arr__linear__traits__2_1aba0cbe450024e7b12c715869b974cbfd" kindref="member"><computeroutput>Curve_2</computeroutput></ref> (and <ref refid="classCGAL_1_1Arr__linear__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref>) nested types are constructible from a <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput>, a <computeroutput><ref refid="classKernel_1_1Ray__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Ray_2</ref></computeroutput>, or from a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. Given a linear-curve object <formula id="8">$c$</formula>, you can use the calls <computeroutput>c.is_line()</computeroutput>, <computeroutput>c.is_ray()</computeroutput>, and <computeroutput>c.is_segment()</computeroutput> to find out whether it has a source point or a target point. Based on the curve type, you can access its endpoints using the methods <computeroutput>c.source()</computeroutput> (for rays and for line segments) and <computeroutput>c.target()</computeroutput> (for segments only). It is also possible to cast a curve into a <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput>, a <computeroutput><ref refid="classKernel_1_1Ray__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Ray_2</ref></computeroutput>, or a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> type, using the methods <computeroutput>c.line()</computeroutput>, <computeroutput>c.ray()</computeroutput>, and <computeroutput>c.segment()</computeroutput>, respectively. Just like the default segment-traits class, the linear-curve traits class uses caching techniques to speed up its predicate evaluations and object constructions.</para>
</sect4>
</sect3>
<sect3 id="index_1arr_ssectr_polylines">
<title>The Polyline and Polycurve Traits Classes</title>
<para>Polylines are continuous piecewise linear curves. Polylines are of particular interest, as they can be used to approximate more complex curves in the plane. At the same time they are easier to handle in comparison to higher-degree algebraic curves, as rational arithmetic is sufficient to carry out computations on polylines, and to construct arrangements of polylines in an exact and robust manner. Here, we extend the notion of polylines and use the term to refer to chains of subcurves that are not necessarily linear. However, each subcurve must be uniquely defined by (and, thus, can be uniquely constructed from) two points within the handled family of curves; see Section <ref refid="index_1arr_sssectr_polylines" kindref="member">The Polyline Traits Class</ref>. We also provide a similar traits class that handles continuous piecewise curves that are not necessarily linear and are not subject to the aforementioned constraint; see Section <ref refid="index_1arr_sssectr_polycurves" kindref="member">The Polycurve Traits Class</ref>.</para>
<sect4 id="index_1arr_sssectr_polylines">
<title>The Polyline Traits Class</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> class template handles polylines. It models the following four concepts:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput>,</para>
</listitem><listitem><para><computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput></para>
</listitem><listitem><para><computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput>, and</para>
</listitem><listitem><para><computeroutput><ref refid="classArrangementConstructCurveTraits__2" kindref="compound">ArrangementConstructCurveTraits_2</ref></computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>The type that substitutes the template parameter <computeroutput>SubcurveTraits_2</computeroutput> when <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> is instantiated must be a geometry-traits class that models the same four concepts. We refer to the type that substitutes the template parameter <computeroutput>SubcurveTraits_2</computeroutput> as the <emphasis>subcurve traits</emphasis> hereafter. If, in addition, the subcurve traits also models the concept <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> then the instantiated <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits&gt;</computeroutput> type models the concept <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> as well. (By definition, modeling the concepts <computeroutput><ref refid="classArrangementApproximateTraits__2" kindref="compound">ArrangementApproximateTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> implies modeling the concept <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput>.) Similarly, if the subcurve traits also models the concept <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> then the instantiated <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits&gt;</computeroutput> type models the concept <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> as well. Modeling the <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> concept implies that the subcurve traits must support the construction of a unique ( <formula id="7">$x$</formula>-monotone) segment given two input points.</para>
<para>An instance of the polyline traits class-template inherits its nested point type, i.e., <ref refid="classCGAL_1_1Arr__polyline__traits__2_1a9bcf8e230ad3ac70bf14484ab47f606b" kindref="member"><computeroutput>Point_2</computeroutput></ref>, from the subcurve traits, and defines the nested types <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> and <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref>, which are used to represent polylines and <formula id="7">$x$</formula>-monotone polylines, respectively. A polyline of the nested type <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> is stored as a vector of <computeroutput>SubcurveTraits_2::Curve_2</computeroutput> objects, and an <formula id="7">$x$</formula>-monotone polyline of the nested type <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> is stored as a vector of <computeroutput>SubcurveTraits_2::X_monotone_curve_2</computeroutput> objects. The nested <computeroutput>X_monotone_curve_2</computeroutput> type inherits from the nested type <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref>. By default, <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> is used as the subcurve traits (in case where the <computeroutput>SubcurveTraits_2</computeroutput> parameter is omitted). In this case the nested types <computeroutput>SubcurveTraits_2::Curve_2</computeroutput> and <computeroutput>SubcurveTraits_2::X_monotone_curve_2</computeroutput> are identical types representing line segments.</para>
<para>A polyline can be constructed given one of the following inputs:</para>
<para><itemizedlist>
<listitem><para><bold>A range of <emphasis>points</emphasis></bold>, where two succeeding points in the range represent the endpoints of a segment of the polyline.</para>
</listitem><listitem><para><bold>A range of <emphasis>segments</emphasis></bold>.</para>
</listitem><listitem><para><bold>A pair of points <emphasis>or</emphasis> a single segment</bold>. In this case a polyline that consists of a single segment is constructed.</para>
</listitem></itemizedlist>
</para>
<para>Note that degenerate polylines are not supported. That is, it is impossible to construct a polyline that contains a segment of length zero, or an isolated point. Finally, a polyline is <bold><emphasis>continuous</emphasis></bold> and <bold><emphasis>well-oriented</emphasis></bold>. Moreover, the target of the <formula id="243">$i$</formula>th segment is the source of the <formula id="264">$i+1$</formula>st segment. If the macro <computeroutput>CGAL_ALWAYS_LEFT_TO_RIGHT</computeroutput> is set to 1, then <formula id="7">$x$</formula>-monotone polylines are always directed from left-to-right. (This option is retained for backward compatibility.) Also, note that a single polyline can be split into several <formula id="7">$x$</formula>-monotone polylines, and that the number of intersection points (or overlapping sections) between two polylines can be large.</para>
<para>For example, the general polyline</para>
<para><image type="html" name="generic-polyline.png"></image>
 <image type="latex" name="generic-polyline.png"></image>
</para>
<para>can be represented by one of the following two orientations.</para>
<para><image type="html" name="well_oriented_polyline.png"></image>
 <image type="latex" name="well_oriented_polyline.png"></image>
</para>
<para>Distinct <formula id="7">$x$</formula>-monotone polylines are rendered in different colors.</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>Technically speaking, it is possible to construct a general polyline that is neither well-oriented nor continuous. However, it is impossible to use such polylines for the purpose of computing an arrangement. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
<para>The polyline traits class also supports the traversal over the range of defining segments of a given polyline. The <emphasis>first</emphasis> and <emphasis>past-the-end</emphasis> iterators can be obtained through the access methods <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2_1a798dbec2fd852cf132a98f766ff4969d" kindref="member"><computeroutput>begin_segments()</computeroutput></ref> and <ref refid="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2_1a8dee766c44f0badadec0e269579d9261" kindref="member"><computeroutput>end_segments()</computeroutput></ref>, respectively, of a polyline <formula id="8">$c$</formula>. The vertices of an <formula id="7">$x$</formula>-monotone curve are always stored in a strongly monotonic lexicographical order. In other words, <formula id="7">$x$</formula>-monotone polylines can be directed <emphasis>either</emphasis> left-to-right <emphasis>or</emphasis> right-to-left.</para>
<para>The polyline-traits class does not perform any geometric operations directly. Instead, it solely relies on the functionality of the segment traits. For example, when we need to determine the position of a point with respect to an <formula id="7">$x$</formula>-monotone polyline, we use binary search to locate the relevant segment that contains the point in its <formula id="7">$x$</formula>-range. Then, we compute the position of the point with respect to this segment. Thus, operations on <formula id="7">$x$</formula>-monotone polylines of size <formula id="80">$m$</formula> typically take <formula id="265">$O(\log m)$</formula> time.</para>
<para>You are free to choose the underlying segment traits class. Your decision could be based, for example, on the number of expected intersection points; see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>. Moreover, it is possible to substitute the <computeroutput>SubcurveTraits_2</computeroutput> template parameter with a traits class that handles segments with some additional data attached to each individual segment; see Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>. This makes it possible to associate different data objects with the different segments that compose a polyline.</para>
<para><anchor id="index_1fig__aos_fig-polylines"/> <image type="html" name="polylines.png"></image>
 <image type="latex" name="polylines.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-polylines" kindref="member">fig__aos_fig-polylines</ref></para>
<para>An arrangement of three polylines, as constructed in <ref refid="Arrangement_on_surface_2_2polylines_8cpp-example" kindref="compound">Arrangement_on_surface_2/polylines.cpp</ref>. Red disks mark vertices associated with polyline endpoints, while rings mark vertices that correspond to intersection points. The target endpoint of <formula id="266">$\pi_3$</formula> is also an intersection point; it is rendered as a ring. Observe that the polyline <formula id="267">$\pi_2$</formula> is split into three <formula id="7">$x$</formula>-monotone polylines, and that the two curves <formula id="268">$\pi_1$</formula> and <formula id="266">$\pi_3$</formula> have two overlapping sections<mdash/>an impossible scenario in arrangements of line segments. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example program constructs an arrangement of three polylines, <formula id="268">$\pi_1$</formula>, <formula id="267">$\pi_2$</formula>, and <formula id="266">$\pi_3$</formula>, as depicted in <ref refid="index_1fig__aos_fig-polylines" kindref="member">fig__aos_fig-polylines</ref>. In this example, each polyline is constructed from points stored in a different container, i.e., array, list, and vector. Points defining the polylines are not necessarily associated with arrangement vertices. The arrangement vertices are either the extreme points of each <formula id="7">$x$</formula>-monotone polyline (drawn as red discs) or the intersection points between two polylines (drawn as rings).</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2polylines_8cpp-example" kindref="compound">Arrangement_on_surface_2/polylines.cpp</ref> <programlisting filename="Arrangement_on_surface_2/polylines.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>polylines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_polylines.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>polyline_construct<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>points1[5];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[0]<sp/>=<sp/>Point(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[1]<sp/>=<sp/>Point(2,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[2]<sp/>=<sp/>Point(3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[3]<sp/>=<sp/>Point(4,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points1[4]<sp/>=<sp/>Point(6,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>pi1<sp/>=<sp/>polyline_construct(&amp;points1[0],<sp/>&amp;points1[5]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point&gt;<sp/>points2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(1,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(0,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(1,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(2,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(3,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(4,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(5,<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(6,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>points2.push_back(Point(4,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>pi2<sp/>=<sp/>polyline_construct(points2.begin(),<sp/>points2.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Segment&gt;<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment(Point(0,<sp/>2),<sp/>Point(1,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment(Point(1,<sp/>2),<sp/>Point(3,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs.push_back(Segment(Point(3,<sp/>6),<sp/>Point(5,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>pi3<sp/>=<sp/>polyline_construct(segs.begin(),<sp/>segs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>pi3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>arrangement<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawPolygonSet2_1gac5ad1c3be15e88df46b096885a023ff4" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::draw</ref>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The common types used by the example programs involving arrangements of polylines are listed below, and defined in the header file <computeroutput>arr_polylines.h</computeroutput>. As we do in the case of segments and linear objects, we use the predefined kernel to instantiate our traits class. However, in this case we have yet another layer of template instantiation, namely the instantiation of the polyline-traits class-template with an instance of a subcurve traits class-template. Naturally, we use the <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> class template, instantiated with the predefined filtered kernel.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_polyline_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">CGAL::Arr_polyline_traits_2&lt;Segment_traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polyline;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1arr_sssectr_polycurves">
<title>The Polycurve Traits Class</title>
<para>The traits class <computeroutput><ref refid="classCGAL_1_1Arr__polycurve__traits__2" kindref="compound">Arr_polycurve_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> handles piecewise curves that are not necessarily linear, such as conic arcs, circular arcs, B<eacute/>zier curves, or line segments. We call such a compound curve a <emphasis>polycurve</emphasis>. Similar to a polyline, a polycurve is a chain of subcurves, where each two neighboring subcurves in the chain share a common endpoint; that is, the polycurve is continuous. As a matter of fact, most characteristics of the <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> traits class template apply also to the <computeroutput><ref refid="classCGAL_1_1Arr__polycurve__traits__2" kindref="compound">Arr_polycurve_traits_2</ref>&lt;SubcurveTraits_2&gt;</computeroutput> traits class template. The only difference between the two, is that the latter is not a model of the concepts <computeroutput><ref refid="classArrangementConstructXMonotoneCurveTraits__2" kindref="compound">ArrangementConstructXMonotoneCurveTraits_2</ref></computeroutput> nor <computeroutput><ref refid="classArrangementConstructCurveTraits__2" kindref="compound">ArrangementConstructCurveTraits_2</ref></computeroutput>, and as such, it is not able to construct a subcurve from only two points. As a consequence, it does not support the operations that (i) construct a polycurve from a sequence of points, and (ii) push a point at the back or at the front of a non-empty polycurve.</para>
</sect4>
</sect3>
<sect3 id="index_1arr_ssectr_algebraic">
<title>Traits Classes for Algebraic Curves</title>
<para>A curve in our context is typically (but not necessarily) defined as the zero set of a bivariate nonzero polynomial with rational (or, equivalently, integral) coefficients. We call such polynomials and the curves they define <emphasis>algebraic</emphasis>. When dealing with linear curves (e.g., line segments and polylines), having rational coefficients guarantees that all intersection points also have rational coordinates, such that the arrangement of such curves can be constructed and maintained using only rational arithmetic. The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package also offers geometry traits-classes that handle algebraic curves defined by algebraic polynomials of degree higher than~ <formula id="269">$1$</formula>. Unfortunately, the coordinates of the intersection points constructed by these traits models are in general algebraic numbersA number is called <emphasis>algebraic</emphasis>, if it is the root of a univariate algebraic polynomial with rational coefficients. of degree higher than <formula id="269">$1$</formula>. It is therefore clear that we have to use number types different from plain rational to represent point coordinates and be able to apply arithmetic operations on them.</para>
<para>Several types of algebraic curves are handled by more than one traits model. Section <ref refid="index_1arr_sssectr_linear" kindref="member">The Linear-Traits Class</ref> introduces a few different traits models that handle line segments. This duplication becomes more evident with the introduction of traits classes that handle algebraic curves. The different traits models have different properties. In some cases they were developed by different authors at different times exploiting different tools that were available at the time they were developed. As a general rule, you should always use the minimal traits model that still satisfies your needs, as the most dedicated model is most likely to be the most efficient.</para>
<sect4 id="index_1arr_sssectr_circ_seg">
<title>Circular Arcs and Line Segments</title>
<para>Arrangement of circular arcs and of line segments are very useful and frequently arise in applications, where curves of interleaved line segments and circular arcs are used to model the boundaries of complex shapes. Such curves can fit the original boundary more tightly and more compactly than, for example, a simple polyline. For example, when dilating a polygon by some radius we obtain a shape whose boundary comprises of line segments, which correspond to dilated polygon edges, and circular arcs, which result from dilated polygon vertices. Using the arrangement of the boundary curves it is possible, for example, to compute the union of a set of dilated polygons. Besides the importance of arrangements of circular arcs and line segments it turns out that it is possible to implement efficient traits models that handle curves restricted to circular arcs and line segments. Rational numbers cannot represent the coordinates of intersection points that may arise in such arrangements in an exact manner. Thus, algebraic numbers must be used. However, the performance impact that (general) algebraic numbers incur can be reduced by the use of an efficient type of exact algebraic numbers called <emphasis>square root extension</emphasis> that uses rational arithmetic in an almost straightforward fashion.</para>
<para>Square root numbers have the form <formula id="270">$\alpha + \beta\sqrt{\gamma}$</formula>, where <formula id="271">$\alpha$</formula>, <formula id="272">$\beta$</formula>, and <formula id="84">$\gamma$</formula> are rational numbers. (Square root numbers are also called one-root numbers.) The rational number <formula id="84">$\gamma$</formula> is referred to as the extension. Each subset that has a particular extension is closed under arithmetic operations and order relations; hence, it is a valid algebraic structure.The term algebraic structure refers to the set closed under one or more operations satisfying some axioms; see, e.g., <ulink url="https://en.wikipedia.org/wiki/Algebraic_structure">https://en.wikipedia.org/wiki/Algebraic_structure</ulink>. For example, all numbers that can be expressed as <formula id="273">$\alpha + \beta\sqrt{K}$</formula>, where <formula id="271">$\alpha$</formula> and <formula id="272">$\beta$</formula> are rational and <formula id="274">$K$</formula> is a rational constant, compose an algebraic structure. The class template <computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CGAL::Sqrt_extension</ref>&lt;NT,Root&gt;</computeroutput> implements the square root extension type. Instances of this template represent square root numbers. It is equipped with the implementation of a set of arithmetic operations and order relations that exploit identical extensions of operands. It also provides the ability to compare two numbers with different extensions <formula id="275">$\gamma_1 \neq \gamma_2$</formula> efficiently. Each operation is implemented using only few rational arithmetic operations. Here, <computeroutput>NT</computeroutput> is the type of <formula id="271">$\alpha$</formula> and <formula id="272">$\beta$</formula>, and <computeroutput>Root</computeroutput> is the type of <formula id="84">$\gamma$</formula>. The running times of the arithmetic operations and order relations provided by the square root extension when the identical-extension condition is met are comparable to the running times of the corresponding arithmetic operations of rational-number types. The running times of order relations when the condition is not met are only slightly larger. In practice, using number types that represent (arbitrary) algebraic numbers increases the running time of the application significantly.</para>
<para>We call circles whose center coordinates and squared radii are rational numbers <emphasis>rational circles</emphasis>. The equation of such a circle, that is, <formula id="276">$(x - x_0)^2 + (y - y_0)^2 = r^2$</formula>, where <formula id="277">$(x_0,y_0)$</formula> and <formula id="10">$r$</formula> denote the circle center and its radius, respectively, has rational coefficients. The coordinates of the points of intersection between two such circles are therefore solutions of quadratic equations with rational coefficients, in other words, algebraic numbers of degree~ <formula id="64">$2$</formula> or simply square root numbers. The same applies to intersection points between such a rational circle and a line, or a line segment, with rational coefficients (a line whose equation is <formula id="278">$ax + by + c = 0$</formula>, where <formula id="279">$a$</formula>, <formula id="280">$b$</formula>, and <formula id="8">$c$</formula> are rational).</para>
<para>The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package offers a traits class-template called <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> that exclusively handles line segments, circular arcs, and whole circles and models the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>; see Package <ref refid="group__PkgBooleanSetOperations2Ref" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations Reference</ref>. Note that it is not a model of the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept. It exploits efficient computations with square root numbers, which makes it attractive for arrangements induced by line segments, circular arcs, and whole circles. When the traits class-template is instantiated, the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> template parameter must be substituted by a geometric kernel that models the <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> concept. Always plug in a kernel that uses a rational number type, such as <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Exact_predicates_exact_constructions_kernel</ref></computeroutput>. Observe that the nested type <ref refid="classCGAL_1_1Arr__circle__segment__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref> defined by the traits class, whose coordinates are typically algebraic numbers of degree 2, is <emphasis>not</emphasis> the same as the <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> type. The coordinates of a point are represented using the number type <computeroutput>CoordNT</computeroutput>, nested in the traits class-template.</para>
<para><anchor id="index_1fig__aos_fig-circles"/> <image type="html" name="circles.png"></image>
 <image type="latex" name="circles.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-circles" kindref="member">fig__aos_fig-circles</ref> An arrangement of three circles constructed in <ref refid="Arrangement_on_surface_2_2circles_8cpp-example" kindref="compound">Arrangement_on_surface_2/circles.cpp</ref>. Each circle is split into two <formula id="7">$x$</formula>-monotone circular arcs, whose endpoints are drawn as red disks. Rings mark vertices that correspond to intersection points. The vertex <formula id="281">$v_{\rm max}$</formula> is a common intersection point of all three circles. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In the following example an arrangement of three full circles is constructed, as shown in <ref refid="index_1fig__aos_fig-circles" kindref="member">fig__aos_fig-circles</ref>. Each <ref refid="classIndex" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Index</ref> is split into two <formula id="7">$x$</formula>-monotone circular arcs, the endpoints of which are drawn as red discs; rings mark vertices that correspond to intersection points. Once the arrangement is constructed, we locate the vertex of maximal degree in the arrangement. The geometric mapping of this vertex, denoted by <formula id="281">$v_{\rm max}$</formula>, is the point <formula id="282">$(4,3)$</formula>, as all three circles intersect at this point and the associated vertex has six incident edges.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2circles_8cpp-example" kindref="compound">Arrangement_on_surface_2/circles.cpp</ref> <programlisting filename="Arrangement_on_surface_2/circles.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>circles<sp/>using<sp/>the<sp/>circle-segment<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_circular.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>radius<sp/>5<sp/>(C1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Curve(Circle(Rational_point(0,<sp/>0),<sp/>Number_type(25))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>(7,7)<sp/>with<sp/>radius<sp/>5<sp/>(C2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Curve(Circle(Rational_point(7,<sp/>7),<sp/>Number_type(25))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>(4,-0.5)<sp/>with<sp/>radius<sp/>3.5<sp/>(=<sp/>7/2)<sp/>(C3).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rational_point<sp/>c3(4,<sp/>Number_type(-1)<sp/>/<sp/>Number_type(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Curve(Circle(c3,<sp/>Number_type(49)<sp/>/<sp/>Number_type(4))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>vertex<sp/>with<sp/>maximal<sp/>degree.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement::Vertex_const_handle<sp/>v_max<sp/>=<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(++vit;<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>v_max-&gt;degree())<sp/>v_max<sp/>=<sp/>vit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>vertex<sp/>with<sp/>maximum<sp/>degree.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vertex<sp/>with<sp/>maximal<sp/>degree<sp/>in<sp/>the<sp/>arrangement<sp/>is:<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;v_max<sp/>=<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v_max-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;with<sp/>degree<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>v_max-&gt;degree()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawPolygonSet2_1gac5ad1c3be15e88df46b096885a023ff4" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::draw</ref>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The types common to the example programs that use the <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref></computeroutput> class template are listed below and defined in the header file <computeroutput>arr_circular.h</computeroutput>. Even though algebraic numbers are required to represent coordinates of points where the inducing curves are circles or circular arcs, such as the curves handled by the <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref></computeroutput> class template, an (exact) rational kernel suffices, and a filtered one improves the performance further.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_circle_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::CoordNT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CoordNT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Curve;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Rational_point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Rational_segment_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Rational_circle_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
</programlisting></para>
<para>The <ref refid="classCGAL_1_1Arr__circle__segment__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> type nested in <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref></computeroutput> can be used to represent circles, circular arcs, or line segments. We now describe and demonstrate a variety of ways in which the curves of this type can be constructed. A Curve object can be constructed from a <computeroutput><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref></computeroutput> object or from a <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> object. A circular arc is typically defined by a supporting circle and two endpoints, where the endpoints are of type <ref refid="classCGAL_1_1Arr__circle__segment__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref>, with rational or irrational coordinates. The orientation of the arc is determined by the orientation of the supporting circle. Similarly, we also support the construction of line segments given their supporting line (of type <computeroutput><ref refid="classKernel_1_1Line__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_2</ref></computeroutput>) and two endpoints, which may have irrational coordinates (unlike the <computeroutput><ref refid="classKernel_1_1Segment__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Segment_2</ref></computeroutput> type).</para>
<para>Note that the <computeroutput><ref refid="classKernel_1_1Circle__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Circle_2</ref></computeroutput> type is used to represent a circle whose <emphasis>squared radius</emphasis> is rational, where the radius itself may be irrational. However, if the radius is known to be rational, its use is recommended for efficiency. It is therefore also possible to construct a circle, or a circular arc specifying the circle center (a <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput>), its rational radius (of type <computeroutput>Kernel::FT</computeroutput>), and its orientation. Finally, we also support the construction of a circular arc that is defined by two endpoints and an arbitrary interior point that lies on the arc in between its endpoints. In this case, all three points are required to have rational coordinates; namely, they are all given as <computeroutput><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref></computeroutput> objects.</para>
<para><anchor id="index_1fig__aos_fig-circular_arcs"/> <image type="html" name="circular_arcs.png"></image>
 <image type="latex" name="circular_arcs.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-circular_arcs" kindref="member">fig__aos_fig-circular_arcs</ref> An arrangement of two full circles, two line segments, and three circular arcs as constructed in <ref refid="Arrangement_on_surface_2_2circular_arcs_8cpp-example" kindref="compound">Arrangement_on_surface_2/circular_arcs.cpp</ref>. Endpoints are drawn as red disks and intersection points are drawn as rings. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example demonstrates the usage of the various construction methods for circular arcs and line segments. The resulting arrangement is depicted in <ref refid="index_1fig__aos_fig-circular_arcs" kindref="member">fig__aos_fig-circular_arcs</ref>. Note the usage of the constructor of <computeroutput>CoordNT(alpha, beta, gamma)</computeroutput>, which creates a degree- <formula id="64">$2$</formula> algebraic number whose value is <formula id="283">$\alpha +
\beta\sqrt{\gamma}$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2circular_arcs_8cpp-example" kindref="compound">Arrangement_on_surface_2/circular_arcs.cpp</ref> <programlisting filename="Arrangement_on_surface_2/circular_arcs.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>various<sp/>circular<sp/>arcs<sp/>and<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_circular.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Curve&gt;<sp/>curves;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>(C1)<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>squared<sp/>radius<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(Circle(Rational_point(0,<sp/>0),<sp/>Number_type(2))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circle<sp/>(C2)<sp/>centered<sp/>at<sp/>(2,<sp/>3)<sp/>with<sp/>radius<sp/>3/2.<sp/>Note<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>the<sp/>radius<sp/>is<sp/>rational<sp/>we<sp/>use<sp/>a<sp/>different<sp/>curve<sp/>constructor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Number_type<sp/>three_halves<sp/>=<sp/>Number_type(3)<sp/>/<sp/>Number_type(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(Rational_point(2,<sp/>3),<sp/>three_halves));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>segment<sp/>(C3)<sp/>of<sp/>the<sp/>line<sp/>(y<sp/>=<sp/>x)<sp/>with<sp/>rational<sp/>endpoints.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s3<sp/>=<sp/>Segment(Rational_point(-2,<sp/>-2),<sp/>Rational_point(2,<sp/>2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(s3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>line<sp/>segment<sp/>(C4)<sp/>with<sp/>the<sp/>same<sp/>supporting<sp/>line<sp/>(y<sp/>=<sp/>x),<sp/>but</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>having<sp/>one<sp/>endpoint<sp/>with<sp/>irrational<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>sqrt_15<sp/>=<sp/>CoordNT(0,<sp/>1,<sp/>15);<sp/></highlight><highlight class="comment">//<sp/>=<sp/>sqrt(15)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(s3.supporting_line(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(3,<sp/>3),<sp/>Point(sqrt_15,<sp/>sqrt_15)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circular<sp/>arc<sp/>(C5)<sp/>that<sp/>is<sp/>the<sp/>upper<sp/>half<sp/>of<sp/>the<sp/>circle<sp/>centered<sp/>at</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(1,<sp/>1)<sp/>with<sp/>squared<sp/>radius<sp/>3.<sp/>Create<sp/>the<sp/>circle<sp/>with<sp/>clockwise<sp/>orientation,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>so<sp/>the<sp/>arc<sp/>is<sp/>directed<sp/>from<sp/>(1<sp/>-<sp/>sqrt(3),<sp/>1)<sp/>to<sp/>(1<sp/>+<sp/>sqrt(3),<sp/>1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rational_point<sp/>c5(1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Circle<sp/>circ5(c5,<sp/>3,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>one_minus_sqrt_3(1,<sp/>-1,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>one_plus_sqrt_3(1,<sp/>1,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>s5(one_minus_sqrt_3,<sp/>CoordNT(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>t5(one_plus_sqrt_3,<sp/>CoordNT(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(circ5,<sp/>s5,<sp/>t5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>(C6)<sp/>of<sp/>the<sp/>unit<sp/>circle,<sp/>directed<sp/>clockwise<sp/>from</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(-1/2,<sp/>sqrt(3)/2)<sp/>to<sp/>(1/2,<sp/>sqrt(3)/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>supporting<sp/>circle<sp/>is<sp/>oriented<sp/>accordingly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rational_point<sp/>c6(0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Number_type<sp/>half<sp/>=<sp/>Number_type(1)<sp/>/<sp/>Number_type(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CoordNT<sp/>sqrt_3_div_2(Number_type(0),<sp/>half,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>s6(-half,<sp/>sqrt_3_div_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>t6(half,<sp/>sqrt_3_div_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(c6,<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,<sp/>s6,<sp/>t6));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>circular<sp/>arc<sp/>(C7)<sp/>defined<sp/>by<sp/>two<sp/>endpoints<sp/>and<sp/>a<sp/>midpoint,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>having<sp/>rational<sp/>coordinates.<sp/>This<sp/>arc<sp/>is<sp/>the<sp/>upper<sp/>right</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>quarter<sp/>of<sp/>a<sp/>circle<sp/>centered<sp/>at<sp/>the<sp/>origin<sp/>with<sp/>radius<sp/>5.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>curves.push_back(Curve(Rational_point(0,<sp/>5),<sp/>Rational_point(3,<sp/>4),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational_point(5,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>curves<sp/>and<sp/>print<sp/>its<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>curves.begin(),<sp/>curves.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgDrawPolygonSet2_1gac5ad1c3be15e88df46b096885a023ff4" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::draw</ref>(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>It is also possible to construct <formula id="7">$x$</formula>-monotone curve objects that represent <formula id="7">$x$</formula>-monotone circular arcs or line segments using similar constructors. (Full circles are not <formula id="7">$x$</formula>-monotone.)</para>
<para>The traits class-template <computeroutput><ref refid="classCGAL_1_1Arr__circular__line__arc__traits__2" kindref="compound">Arr_circular_line_arc_traits_2</ref>&lt;<ref refid="classCircularKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Circular_kernel_2.tag">CircularKernel</ref>&gt;</computeroutput> offered by the arrangement package also handles circular arcs and line segments. It is an alternative to the <computeroutput><ref refid="classCGAL_1_1Arr__circle__segment__traits__2" kindref="compound">Arr_circle_segment_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>&gt;</computeroutput> class-template. These two class templates, while serve similar purposes, are based on different concepts, and posses different characteristics. You are encouraged to experiment with both, compare their performance, and use the most suitable for your case.</para>
</sect4>
<sect4 id="index_1arr_sssectr_conic">
<title>A Traits Class for Conic Arcs</title>
<para>A <emphasis>conic curve</emphasis> is an algebraic curve of degree 2. Namely, it is the locus of all points <formula id="284">$(x,y)$</formula> satisfying the equation <formula id="285">$c:\
r x^2 + s y^2 + t xy + u x + v y + w = 0$</formula>, where the six coefficients <formula id="286">$\langle r, s, t, u, v, w \rangle$</formula> completely characterize the curve. The sign of the expression <formula id="287">$\Delta_{c} = 4 r
s - t^2$</formula> determines the type of curve:</para>
<para><itemizedlist>
<listitem>
<para>If <formula id="288">$\Delta_{c} &gt; 0$</formula>, the curve is an ellipse. A circle is a special case of an ellipse, where <formula id="289">$r = s$</formula> and <formula id="290">$t = 0$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>If <formula id="291">$\Delta_{c} = 0$</formula>, the curve is a parabola<mdash/>an unbounded conic curve with a single connected branch. When <formula id="292">$r = s = t = 0$</formula> we have a line, which can be considered as a degenerate parabola.</para>
<para></para>
</listitem>
<listitem>
<para>If <formula id="293">$\Delta_{c} &lt; 0$</formula>, the curve is a hyperbola. That is, it comprises of two disconnected unbounded branches.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref>&lt;RatKernel, AlgKernel, NtTraits&gt;</computeroutput> class template is capable of handling only bounded arcs of conic curves, referred to as <emphasis>conic arcs</emphasis>. A conic arc <formula id="279">$a$</formula> may be either (i) a full ellipse, or (ii) defined by the tuple <formula id="294">$\langle \kappa,
p_s, p_t, o \rangle$</formula>, where <formula id="295">$\kappa$</formula> is a conic curve and <formula id="296">$p_s$</formula> and <formula id="297">$p_t$</formula> are two points on <formula id="8">$c$</formula> (namely <formula id="298">$\kappa(p_s) = \kappa(p_t) = 0$</formula>) that define the <emphasis>source</emphasis> and <emphasis>target</emphasis> of the arc, respectively. The arc is formed by traversing <formula id="295">$\kappa$</formula> from the source to the target going in the orientation specified by <formula id="299">$o$</formula>, which is typically clockwise or counterclockwise orientation, but may also be collinear in case of degenerate conic conic-curves, namely, lines or pairs of lines.</para>
<para>We always assume that the conic coefficients <formula id="300">$\langle r, s, t, u, v,
w \rangle$</formula> are rational. The coordinates of points of intersection between two conic curves with rational coefficients are in general algebraic numbers of degree 4. Namely, they are roots of algebraic polynomials of degree 4. In addition, conic arcs may not necessarily be <formula id="7">$x$</formula>-monotone, and must be split at points where the tangent to the arc is vertical. In the general case such points typically have coordinates that are algebraic numbers of degree 2. Note that as arrangement vertices induced by intersection points and points with vertical tangents are likely to have algebraic coordinates, we also allow the original endpoints of the input arcs <formula id="296">$p_s$</formula> and <formula id="297">$p_t$</formula> to have algebraic coordinates.</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref>&lt;RatKernel, AlgKernel, NtTraits&gt;</computeroutput> class template is designed for efficient handling of arrangements of bounded conic arcs. The template has three parameters, defined as follows:</para>
<para><itemizedlist>
<listitem>
<para>The <computeroutput>RatKernel</computeroutput> template parameter must be substituted by a geometric kernel whose field type is an exact rational type. It is used to define basic geometric entities (e.g., a line segment or a circle) with rational coefficients. Typically we use one of the standard CGAL kernels, instantiated with the number type <computeroutput>NtTraits::Rational</computeroutput> (see below).</para>
<para></para>
</listitem>
<listitem>
<para>The <computeroutput>AlgKernel</computeroutput> template parameter must be substituted by a geometric kernel whose field type is an exact algebraic type. It is used to define points with algebraic coordinates. Typically, we use one of the standard CGAL kernels, instantiated with the number type <computeroutput>NtTraits::Algebraic</computeroutput> (see below).</para>
<para></para>
</listitem>
<listitem>
<para>The <computeroutput>NtTraits</computeroutput> template parameter must be substituted by a type that encapsulates all the numeric operations needed for performing geometric computation carried out by the geometric traits class. It defines the <computeroutput>Integer</computeroutput>, <computeroutput>Rational</computeroutput>, and <computeroutput>Algebraic</computeroutput> number-types, and supports several operations on these types, such as conversion between these types, solving quadratic equations, and extracting the real roots of polynomials with integer coefficients. The use of the <computeroutput><ref refid="classCGAL_1_1CORE__algebraic__number__traits" kindref="compound">CORE_algebraic_number_traits</ref></computeroutput> class, which is included in the arrangement package, is highly recommended. The traits class-template relies on the multi-precision number types implemented in the Core library and performs exact computations on the number types it defines.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>The instantiation of the conic traits class-template is slightly more complicated than the instantiation of the traits classes you have encountered so far. This instantiation is exemplified in the header file <computeroutput>arr_conics.h</computeroutput>. Note how we first define the rational and algebraic kernels using the number types given by the Core number type traits-class, then use them to define the conic traits class-template. Also note the types defined by the rational kernels, which we need for conveniently constructing conic arcs.</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> models the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concepts. Its <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref> type is derived from <computeroutput>AlgKernel::Point_2</computeroutput>, while the <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> type represents a bounded, not necessarily <formula id="7">$x$</formula>-monotone, conic arc. The <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> type is derived from <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref>, but its constructors are used only by the traits class. Users should therefore construct only <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> objects and insert them into the arrangement using the <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> function.</para>
<para>Conic arcs are constructible from full ellipses or by specifying a supporting curve, two endpoints, and an orientation. However, several constructors of <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> are available to allow for some special cases, such as circular arcs or line segments. The <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> and the derived <ref refid="classCGAL_1_1Arr__conic__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> classes also support basic access functions such as <computeroutput>source()</computeroutput>, <computeroutput>target()</computeroutput>, and <computeroutput>orientation()</computeroutput>.</para>
<para><anchor id="index_1fig__aos_fig-conics"/> <image type="html" name="conics.png"></image>
 <image type="latex" name="conics.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-conics" kindref="member">fig__aos_fig-conics</ref> An arrangement of mixed conic arcs, as constructed in conics.cpp <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example demonstrates the usage of the various constructors for conic arcs. The resulting arrangement is depicted in <ref refid="index_1fig__aos_fig-conics" kindref="member">fig__aos_fig-conics</ref>. Especially noteworthy are the constructor of a circular arc that accepts three points, the constructor of a conic arc that accepts five points, and the constructor that allows specifying approximate endpoints, where the exact endpoints are given explicitly as intersections of the supporting conic with two other conic curves. The approximate endpoints are used to select the specific exact endpoints out of all intersection points of the pair of curves (the supporting conic curve and the auxiliary conic curve). Also note that as the preconditions required by some of these constructors are rather complicated (see the Reference Manual for the details), a precondition violation does not cause the program to terminate<mdash/>instead, an <emphasis>invalid</emphasis> arc is created. The call <computeroutput>a.is_valid()</computeroutput> verifies the validity of the arc <formula id="279">$a$</formula>. Naturally, inserting invalid arcs into an arrangement is not allowed, so the validity of an arc should be checked once it is constructed.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2conics_8cpp-example" kindref="compound">Arrangement_on_surface_2/conics.cpp</ref> <programlisting filename="Arrangement_on_surface_2/conics.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>various<sp/>conic<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_conics.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_cv<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>hyperbolic<sp/>arc<sp/>(C1),<sp/>supported<sp/>by<sp/>the<sp/>hyperbola<sp/>y<sp/>=<sp/>1/x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(or:<sp/>xy<sp/>-<sp/>1<sp/>=<sp/>0)<sp/>with<sp/>the<sp/>endpoints<sp/>(1/4,<sp/>4)<sp/>and<sp/>(2,<sp/>1/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>arc<sp/>is<sp/>counterclockwise<sp/>oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(0,<sp/>0,<sp/>1,<sp/>0,<sp/>0,<sp/>-1,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(Rational(1,4),<sp/>4),<sp/>Point(2,<sp/>Rational(1,2))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>full<sp/>ellipse<sp/>(C2),<sp/>which<sp/>is<sp/>(x/4)^2<sp/>+<sp/>(y/2)^2<sp/>=<sp/>0<sp/>rotated<sp/>by</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>phi<sp/>=<sp/>36.87<sp/>degrees<sp/>(such<sp/>that<sp/>sin(phi)<sp/>=<sp/>0.6,<sp/>cos(phi)<sp/>=<sp/>0.8),</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>yielding:<sp/>58x^2<sp/>+<sp/>72y^2<sp/>-<sp/>48xy<sp/>-<sp/>360<sp/>=<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(58,<sp/>72,<sp/>-48,<sp/>0,<sp/>0,<sp/>-360));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>segment<sp/>(C3)<sp/>(1,<sp/>1)<sp/>--<sp/>(0,<sp/>-3).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(Rat_segment(Rat_point(1,<sp/>1),<sp/>Rat_point(0,<sp/>-3))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>circular<sp/>arc<sp/>(C4)<sp/>supported<sp/>by<sp/>the<sp/>circle<sp/>x^2<sp/>+<sp/>y^2<sp/>=<sp/>5^2,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>with<sp/>(-3,<sp/>4)<sp/>and<sp/>(4,<sp/>3)<sp/>as<sp/>its<sp/>endpoints.<sp/>We<sp/>want<sp/>the<sp/>arc<sp/>to<sp/>be</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>clockwise-oriented,<sp/>so<sp/>it<sp/>passes<sp/>through<sp/>(0,<sp/>5)<sp/>as<sp/>well.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(Rat_point(-3,<sp/>4),<sp/>Rat_point(0,<sp/>5),<sp/>Rat_point(4,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>full<sp/>unit<sp/>circle<sp/>(C5)<sp/>that<sp/>is<sp/>centered<sp/>at<sp/>(0,<sp/>4).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(Rat_circle(Rat_point(0,4),<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>parabolic<sp/>arc<sp/>(C6)<sp/>supported<sp/>by<sp/>the<sp/>parabola<sp/>y<sp/>=<sp/>-x^2<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>endpoints<sp/>(-sqrt(3),-3)<sp/>(~(-1.73,-3))<sp/>and<sp/>(sqrt(2),-2)<sp/>(~(1.41,-2)).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Since<sp/>the<sp/>x-coordinates<sp/>of<sp/>the<sp/>endpoints<sp/>cannot<sp/>be<sp/>accurately<sp/>represented,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>specify<sp/>them<sp/>as<sp/>the<sp/>intersections<sp/>of<sp/>the<sp/>parabola<sp/>with<sp/>the<sp/>lines</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>y<sp/>=<sp/>-3<sp/>and<sp/>y<sp/>=<sp/>-2,<sp/>respectively.<sp/>The<sp/>arc<sp/>is<sp/>clockwise-oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc<sp/>c6<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ctr_cv(1,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>0,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,<sp/></highlight><highlight class="comment">//<sp/>The<sp/>parabola.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(-1.73,<sp/>-3),<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>approximation<sp/>of<sp/>the<sp/>source.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>3,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>line:<sp/>y<sp/>=<sp/>-3.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point(1.41,<sp/>-2),<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>approximation<sp/>of<sp/>the<sp/>target.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>1,<sp/>2);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>line:<sp/>y<sp/>=<sp/>-2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>c6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>right<sp/>half<sp/>of<sp/>the<sp/>circle<sp/>centered<sp/>at<sp/>(4,<sp/>2.5)<sp/>whose<sp/>radius</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>1/2<sp/>(therefore<sp/>its<sp/>squared<sp/>radius<sp/>is<sp/>1/4)<sp/>(C7).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_circle<sp/>circ7(Rat_point(4,<sp/>Rational(5,2)),<sp/>Rational(1,4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>ctr_cv(circ7,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>,<sp/>Point(4,<sp/>3),<sp/>Point(4,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>GMP<sp/>and<sp/>CORE\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para>The types common to the example programs that use the <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> class template are listed below and defined in the header file <computeroutput>arr_conics.h</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_conic_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Nt_traits<sp/>=<sp/><ref refid="classCGAL_1_1CORE__algebraic__number__traits" kindref="compound">CGAL::CORE_algebraic_number_traits</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Rational<sp/>=<sp/>Nt_traits::Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Rat_kernel<sp/>=<sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Rat_point<sp/>=<sp/>Rat_kernel::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Rat_segment<sp/>=<sp/>Rat_kernel::Segment_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Rat_circle<sp/>=<sp/>Rat_kernel::Circle_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Algebraic<sp/>=<sp/>Nt_traits::Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Alg_kernel<sp/>=<sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point<sp/>=<sp/>Traits::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Conic_arc<sp/>=<sp/>Traits::Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">X_monotone_conic_arc<sp/>=<sp/>Traits::X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref>;</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-conic_multiplicities"/> <image type="html" name="conic_multiplicities.png"></image>
 <image type="latex" name="conic_multiplicities.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-conic_multiplicities" kindref="member">fig__aos_fig-conic_multiplicities</ref> An arrangement of a circular arc and an hyperbolic arc, as constructed in <ref refid="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example" kindref="compound">Arrangement_on_surface_2/conic_multiplicities.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The last example in this section demonstrates how the conic-traits class can handle intersection points with multiplicity. The resulting arrangement is depicted in <ref refid="index_1fig__aos_fig-conic_multiplicities" kindref="member">fig__aos_fig-conic_multiplicities</ref>. The supporting curves of the two arcs, a circle centered at <formula id="301">$(0,\frac{1}{2})$</formula> with radius <formula id="302">$\frac{1}{2}$</formula>, and the hyperbola <formula id="303">$y =
\frac{x^2}{1-x}$</formula>,This curve can also be written as <formula id="304">$c: x^2 + xy - y = 0$</formula>. It is a hyperbola since <formula id="305">$\Delta_{c} =
-1$</formula>. intersect at the origin such that the intersection point has multiplicity <formula id="306">$3$</formula> (note that they both have the same horizontal tangent at <formula id="214">$(0,0)$</formula> and the same curvature <formula id="269">$1$</formula>). In addition, they have another intersection point at <formula id="307">$(\frac{1}{2},\frac{1}{2})$</formula> of multiplicity <formula id="269">$1$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example" kindref="compound">Arrangement_on_surface_2/conic_multiplicities.cpp</ref> <programlisting filename="Arrangement_on_surface_2/conic_multiplicities.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Handling<sp/>intersection<sp/>points<sp/>with<sp/>multiplicity<sp/>between<sp/>conic<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_naive_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_conics.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Naive_pl<sp/>=<sp/><ref refid="classCGAL_1_1Arr__naive__point__location" kindref="compound">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_cv<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Naive_pl<sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>hyperbolic<sp/>arc,<sp/>supported<sp/>by<sp/>the<sp/>hyperbola<sp/>y<sp/>=<sp/>x^2/(1-x)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(or:<sp/>x^2<sp/>+<sp/>xy<sp/>-<sp/>y<sp/>=<sp/>0)<sp/>with<sp/>the<sp/>endpoints<sp/>(-1,<sp/>1/2)<sp/>and<sp/>(1/2,<sp/>1/2).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>arc<sp/>is<sp/>counterclockwise<sp/>oriented.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>ps1(-1,<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pt1(Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc<sp/>cv1<sp/>=<sp/>ctr_cv(1,<sp/>0,<sp/>1,<sp/>0,<sp/>-1,<sp/>0,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,<sp/>ps1,<sp/>pt1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>insert(arr,<sp/>cv1,<sp/>pl);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>the<sp/>bottom<sp/>half<sp/>of<sp/>the<sp/>circle<sp/>centered<sp/>at<sp/>(0,<sp/>1/2)<sp/>whose<sp/>radius</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>is<sp/>1/2<sp/>(therefore<sp/>its<sp/>squared<sp/>radius<sp/>is<sp/>1/4).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Rat_circle<sp/>circ2(Rat_point(0,<sp/>Rational(1,2)),<sp/>Rational(1,4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>ps2(-Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pt2(Rational(1,2),<sp/>Rational(1,2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Conic_arc<sp/>cv2<sp/>=<sp/>ctr_cv(circ2,<sp/><ref refid="group__kernel__enums_1ga39fcfbab0b0f0ce9139ad1613e21d60d" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::COUNTERCLOCKWISE</ref>,<sp/>ps2,<sp/>pt2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>cv2,<sp/>pl);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>GMP<sp/>and<sp/>CORE\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1arr_sssectr_ratfunc">
<title>A Traits Class for Arcs of Rational Functions</title>
<para>A <emphasis>rational function</emphasis> is given by the equation <formula id="308">$y =
\frac{P(x)}{Q(x)}$</formula>, where <formula id="309">$P$</formula> and <formula id="310">$Q$</formula> are polynomials of arbitrary degrees. In particular, if <formula id="311">$ Q(x) = 1$</formula>, then the function is simply a polynomial function. A bounded <emphasis>rational arc</emphasis> is defined by the graph of a rational function over some interval <formula id="312">$[x_{\rm min}, x_{\rm max}]$</formula>, where <formula id="310">$Q$</formula> does not have any real roots in this interval (thus, the arc does not contain any singularities). However, we may consider functions defined over unbounded intervals, namely, over <formula id="313">$(-\infty, x_{\max}]$</formula>, <formula id="314">$[x_{\min}, \infty)$</formula>, or <formula id="315">$(-\infty, \infty)$</formula>. Rational functions, and polynomial functions in particular, are not only interesting in their own right, they are also useful for approximating more complicated curves and for interpolation; see, e.g., <ref refid="citelist_1CITEREF_cgal:ptvf-nrcpp-02" kindref="member">[12]</ref> Chapter 3.</para>
<para>Using the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class template it is possible to construct and maintain arrangements induced by rational arcs. Every instance of the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class template models the concepts <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput>, but it does not model the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept. It also models the refined concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>, which enables Boolean set operations; see Package <ref refid="group__PkgBooleanSetOperations2Ref" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations Reference</ref>. Note that it is not a model of <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept, so it is impossible to use the landmark point-location strategy with this traits class.</para>
<para><anchor id="index_1fig__aos_fig-rat_func_singular"/> <image type="html" name="rational_function_singular.png"></image>
 <image type="latex" name="rational_function_singular.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-rat_func_singular" kindref="member">fig__aos_fig-rat_func_singular</ref> An arrangement of an arc of a rational functions that has singularities at <formula id="316">$x = 1$</formula> and at <formula id="317">$x = 2$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>A rational arc is always <formula id="7">$x$</formula>-monotone in the mathematical sense. However, it is not necessarily continuous, as it may have singularities. An arc that has singularities must be split into continuous portions before being inserted into the arrangement. Consider, for example, the rational arc given by the equation <formula id="318">$y =
\frac{1}{(x-1)(2-x)}$</formula> defined over the interval <formula id="319">$[0,3]$</formula>, as depicted in <ref refid="index_1fig__aos_fig-rat_func_singular" kindref="member">fig__aos_fig-rat_func_singular</ref>. This arc has two singularities, at <formula id="316">$x = 1$</formula> and at <formula id="317">$x = 2$</formula>. It is split into three continuous portions defined over the intervals <formula id="320">$[0,1)$</formula>, <formula id="321">$(1,2)$</formula>, and <formula id="322">$(2,3]$</formula> by the traits operation <ref refid="classArrangementTraits__2_1ae7fb20dc627766bd122192d6e5c1da57" kindref="member"><computeroutput>Make_x_monotone_2</computeroutput></ref>. Arbitrary rational functions are represented by the nested type <ref refid="classCGAL_1_1Arr__rational__function__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> and continuous portions of rational functions are represented by the nested type <ref refid="classCGAL_1_1Arr__rational__function__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref>. Constructors for both types are provided by the traits in form of functors.</para>
<para>When the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref>&lt;<ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref>&gt;</computeroutput> class template is instantiated, the template parameter must be substituted by a model of the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput> concept. Models of this concept, such as the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref>&lt;Coefficient&gt;</computeroutput> class template provided by the package <ref refid="packages_1PkgAlgebraicFoundations" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Algebraic Foundations</ref> are meant to support algebraic functionalities on univariate polynomials of arbitrary degree. See the documentation of the concept <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput> for more information. A rational function is then represented as the quotient of two polynomials, <formula id="309">$P$</formula> and <formula id="310">$Q$</formula>, of type <computeroutput>Polynomial_1</computeroutput> nested in every model of the concept <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput> and in particular in the algebraic-kernel type that substitutes the template parameter <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput> when the traits class-template is instantiated. Such a rational function is constructible from a single polynomial <formula id="309">$P$</formula> (with <formula id="323">$Q(x) = 1$</formula>), or from two polynomials <formula id="309">$P$</formula> and <formula id="310">$Q$</formula>. The type of the polynomial coefficients, namely <computeroutput>Coefficient</computeroutput>, and the type of the interval bounds, namely <computeroutput>Bound</computeroutput>, are also nested in the algebraic-kernel type. If an instance of the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref>&lt;Coefficient&gt;</computeroutput> class template is used, for example, as the algebraic-kernel type, the type that substitutes its template parameter is defined as the <computeroutput>Coefficient</computeroutput> type. This type cannot be algebraic. Moreover, it is recommended that this type is not made rational either, since using rational (as opposed to integral) coefficients does not extend the range of the rational arcs and is typically less efficient.The <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref></computeroutput> class template uses the types provided by the <ref refid="packages_1PkgPolynomial" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Polynomial</ref> package to define its nested <computeroutput>Polynomial_1</computeroutput> type and conveniently expose it to the user. The <computeroutput>Bound</computeroutput> type, however, can be algebraic. A point of type <ref refid="classCGAL_1_1Arr__rational__function__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref> nested in the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class template is represented by a rational function and its <formula id="7">$x$</formula>-coordinate, which is derived from the type <computeroutput>Algebraic_real_1</computeroutput> nested in the algebraic-kernel type. An explicit representation by the nested type <computeroutput>Algebraic_real_1</computeroutput> of the <formula id="106">$y$</formula>-coordinate is only computed upon request, as it can be a rather costly operation.</para>
<para>The aforementioned types, <computeroutput>Polynomial_1</computeroutput>, <computeroutput>Coefficient</computeroutput>, <computeroutput>Bound</computeroutput>, and <computeroutput>Algebraic_real_1</computeroutput>, are conveniently nested in the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class template among the others and obtained from there in the type definitions used in the examples given in this section and listed below. These types are defined in the header file <computeroutput>arr_rat_functions.h</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="CORE__BigInt_8h.html" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CGAL/CORE_BigInt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Algebraic_kernel_d_1.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_rational_function_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</ref><sp/><sp/><sp/><sp/>AK1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</ref><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Polynomial_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polynomial;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Algebraic_real_1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_real;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Bound<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bound;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
</programlisting></para>
<para>The constructed rational functions are cached by the traits class. The cache is local to each traits class object. It is therefore necessary to construct curves using only the constructor objects provided by member functions of the traits class. Moreover, a curve must only be used by the traits class object that was used to construct it. The cache is automatically cleaned up from time to time. The amortized clean up costs are constant. In addition, there is also a separate member function that cleans up the cache upon request.</para>
<para><anchor id="index_1fig__aos_fig-rational_functions"/> <image type="html" name="rational_functions.png"></image>
 <image type="latex" name="rational_functions.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-rational_functions" kindref="member">fig__aos_fig-rational_functions</ref> An arrangement of four arcs of rational functions, as constructed in <ref refid="Arrangement_on_surface_2_2rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/rational_functions.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example demonstrates the construction of an arrangement induced by rational arcs depicted in <ref refid="index_1fig__aos_fig-rational_functions" kindref="member">fig__aos_fig-rational_functions</ref>. It uses constructors both for polynomial arcs and for rational arcs.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/rational_functions.cpp</ref> <programlisting filename="Arrangement_on_surface_2/rational_functions.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>arcs<sp/>of<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_rat_functions.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga2cbb865dd83eedd780f4a452635b1d28" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_pretty_mode</ref>(std::cout);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>nice<sp/>printouts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>traits<sp/>class<sp/>object<sp/>and<sp/>a<sp/>constructor<sp/>for<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>construct<sp/>=<sp/>traits.construct_x_monotone_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>polynomial<sp/>representing<sp/>x.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>container<sp/>storing<sp/>all<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Traits::X_monotone_curve_2&gt;<sp/>arcs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>(C1)<sp/>supported<sp/>by<sp/>the<sp/>polynomial<sp/>y<sp/>=<sp/>x^4<sp/>-<sp/>6x^2<sp/>+<sp/>8,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>(approximate)<sp/>interval<sp/>[-2.1,<sp/>2.1].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P1<sp/>=<sp/>CGAL::ipower(x,4)<sp/>-<sp/>6*x*x<sp/>+<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Alg_real<sp/>l(Bound(-2.1)),<sp/>r(Bound(2.1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P1,<sp/>l,<sp/>r));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>(C2)<sp/>supported<sp/>by<sp/>the<sp/>function<sp/>y<sp/>=<sp/>x<sp/>/<sp/>(1<sp/>+<sp/>x^2),</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-3,<sp/>3].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P2<sp/>=<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>Q2<sp/>=<sp/>1<sp/>+<sp/>x*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P2,<sp/>Q2,<sp/>Alg_real(-3),<sp/>Alg_real(3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>(C3)<sp/>supported<sp/>by<sp/>the<sp/>parbola<sp/>y<sp/>=<sp/>8<sp/>-<sp/>x^2,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-2,<sp/>3].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P3<sp/>=<sp/>8<sp/>-<sp/>x*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P3,<sp/>Alg_real(-2),<sp/>Alg_real(3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>arc<sp/>(C4)<sp/>supported<sp/>by<sp/>the<sp/>line<sp/>y<sp/>=<sp/>-2x,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>defined<sp/>over<sp/>the<sp/>interval<sp/>[-3,<sp/>0].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P4<sp/>=<sp/>-2*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P4,<sp/>Alg_real(-3),<sp/>Alg_real(0)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>four<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>arcs.begin(),<sp/>arcs.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-unbounded_rational_functions"/> <image type="html" name="unbounded_rational_functions.png"></image>
 <image type="latex" name="unbounded_rational_functions.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-unbounded_rational_functions" kindref="member">fig__aos_fig-unbounded_rational_functions</ref> An arrangement of six arcs of rational functions, as constructed in <ref refid="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_rational_functions.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example demonstrates the construction of an arrangement of six rational arcs, four unbounded arcs and two bounded ones, as depicted in <ref refid="index_1fig__aos_fig-unbounded_rational_functions" kindref="member">fig__aos_fig-unbounded_rational_functions</ref>. Note the usage of the constructors of an entire rational function and of an infinite &quot;ray&quot; of such a function. Also observe that the hyperbolas <formula id="324">$y = \pm\frac{1}{x}$</formula> and <formula id="325">$y = \pm\frac{1}{2x}$</formula> never intersect, although they have common vertical and horizontal asymptotes, so very &quot;thin&quot; unbounded faces are created between them:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example" kindref="compound">Arrangement_on_surface_2/unbounded_rational_functions.cpp</ref> <programlisting filename="Arrangement_on_surface_2/unbounded_rational_functions.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>unbounded<sp/>portions<sp/>of<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE<sp/>...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_rat_functions.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga2cbb865dd83eedd780f4a452635b1d28" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_pretty_mode</ref>(std::cout);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>nice<sp/>printouts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>traits<sp/>class<sp/>object<sp/>and<sp/>a<sp/>constructor<sp/>for<sp/>rational<sp/>functions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AK1<sp/>ak1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits(&amp;ak1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>construct<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>polynomial<sp/>representing<sp/>x.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>container<sp/>storing<sp/>all<sp/>arcs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Traits::Curve_2&gt;<sp/>arcs;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>arcs<sp/>(C1,<sp/>C&apos;1)<sp/>of<sp/>the<sp/>rational<sp/>functions<sp/>(y<sp/>=<sp/>1<sp/>/<sp/>x,<sp/>y<sp/>=<sp/>-1<sp/>/<sp/>x).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P1(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>minusP1(-P1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>Q1<sp/>=<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P1,<sp/>Q1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP1,<sp/>Q1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>bounded<sp/>segments<sp/>(C2,<sp/>C&apos;2)<sp/>of<sp/>the<sp/>parabolas<sp/>(y<sp/>=<sp/>-4*x^2<sp/>+<sp/>3)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>(y<sp/>=<sp/>4*x^2<sp/>-<sp/>3),<sp/>defined<sp/>over<sp/>[-sqrt(3)/2,<sp/>sqrt(3)/2].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P2<sp/>=<sp/>-4*x*x+3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>minusP2<sp/>=<sp/>-P2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;std::pair&lt;Alg_real,<sp/>int&gt;<sp/>&gt;<sp/>roots;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ak1.solve_1_object()(P2,<sp/>std::back_inserter(roots));</highlight><highlight class="comment">//<sp/>[-sqrt(3)/2,<sp/>sqrt(3)/2]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P2,<sp/>roots[0].first,<sp/>roots[1].first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP2,<sp/>roots[0].first,<sp/>roots[1].first));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>the<sp/>arcs<sp/>(C3,<sp/>C&apos;3)<sp/>of<sp/>(i)<sp/>the<sp/>rational<sp/>function<sp/>(y<sp/>=<sp/>1<sp/>/<sp/>2*x)<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>x<sp/>&gt;<sp/>0,<sp/>and<sp/>(ii)<sp/>the<sp/>rational<sp/>function<sp/>(y<sp/>=<sp/>-1<sp/>/<sp/>2*x)<sp/>for<sp/>x<sp/>&lt;<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>P3(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>minusP3(-P3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>Q3<sp/>=<sp/>2*x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(P3,<sp/>Q3,<sp/>Alg_real(0),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arcs.push_back(construct(minusP3,<sp/>Q3,<sp/>Alg_real(0),<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>six<sp/>arcs<sp/>and<sp/>print<sp/>its<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>arcs.begin(),<sp/>arcs.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_unbounded_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para>The curve constructors have an additional advantage. They conveniently enable the provision of two polynomials that define a rational arc using rational coefficients. For example, let <formula id="309">$P$</formula> and <formula id="310">$Q$</formula> denote two polynomials with integral coefficients that define a rational arc of interest, and let <formula id="326">$P&apos;$</formula> and <formula id="327">$Q&apos;$</formula> denote two polynomials with rational coefficients that define the same rational arc; that is, the quotients <formula id="328">$P/Q$</formula> and <formula id="329">$P&apos;/Q&apos;$</formula> are identical. You can construct the rational arc providing the coefficients of <formula id="326">$P&apos;$</formula> and <formula id="327">$Q&apos;$</formula> to the constructor. In this case the constructor normalizes the coefficients and generates the desired polynomials <formula id="309">$P$</formula> and <formula id="310">$Q$</formula>. To this end, the curve constructors of both types, namely <ref refid="classCGAL_1_1Arr__rational__function__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> and <ref refid="classCGAL_1_1Arr__rational__function__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref>, have operators that accept ranges of polynomial coefficients as well as polynomials. The coefficients in a given range must be in the order of the degrees of the corresponding variables starting from the constant term.</para>
</sect4>
<sect4 id="index_1arr_sssectr_bez">
<title>A Traits Class for Planar Bézier Curves</title>
<para>A planar <emphasis>B<eacute/>zier curve</emphasis> <formula id="330">$B$</formula> is a parametric curve defined by a sequence of <emphasis>control points</emphasis> <formula id="331">$p_0, \ldots,
p_n$</formula> as follows:</para>
<para><formula id="332">\begin{eqnarray*}
B(t) = \left(X(t), Y(t)\right)
= \ccSum{k=0}{n}{p_k \cdot \frac{n!}{k! (n-k)!} \cdot
t^k (1-t)^{n-k}}\ .
\end{eqnarray*}</formula></para>
<para>where <formula id="333">$t \in [0, 1]$</formula>. The degree of the curve is therefore <formula id="86">$n$</formula>; namely, <formula id="334">$X(t)$</formula> and <formula id="335">$Y(t)$</formula> are polynomials of degree <formula id="86">$n$</formula>. B<eacute/>zier curves have numerous applications in computer graphics and solid modeling. They are used, for example, in free-form sketches and for defining the true-type fonts.</para>
<para>Using the <computeroutput><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">Arr_Bezier_curve_traits_2</ref>&lt;RatKernel, AlgKernel, NtTraits&gt;</computeroutput> class template you can construct and maintain arrangements induced by B<eacute/>zier curves (including self-intersecting B<eacute/>zier curves) of arbitrary degree. The curves are given by rational control points, that is, a sequence of objects of the <computeroutput>RatKernel::Point_2</computeroutput> type. (In general, a sequence of <formula id="336">$n+1$</formula> control points define a B<eacute/>zier curve of degree <formula id="86">$n$</formula>.) The three types that substitute the template parameters <computeroutput>RatKernel</computeroutput>, <computeroutput>AlgKernel</computeroutput>, and <computeroutput>NtTraits</computeroutput>, respectively, when the traits is instantiated must fulfill the same requirements of the corresponding types used to instantiate the <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> class template. Here, the use of the <computeroutput><ref refid="classCGAL_1_1CORE__algebraic__number__traits" kindref="compound">CORE_algebraic_number_traits</ref></computeroutput> class is also recommended with Cartesian kernels instantiated with the <computeroutput>Rational</computeroutput> and <computeroutput>Algebraic</computeroutput> number types defined by this class. The examples given in this manual use the type definitions listed below. These types are defined in the header file <computeroutput>arr_Bezier.h</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/CORE_algebraic_number_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1CORE__algebraic__number__traits" kindref="compound">CGAL::CORE_algebraic_number_traits</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nt_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rational;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Nt_traits::Algebraic<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Rational&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;Algebraic&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Alg_kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Rat_kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Rat_point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Curve_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Bezier_curve;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement;</highlight></codeline>
</programlisting></para>
<para>As mentioned above, we assume that the coordinates of all control points that define a B<eacute/>zier curve are rational numbers, so both <formula id="334">$X(t)$</formula> and <formula id="335">$Y(t)$</formula> are polynomials with rational coefficients. The intersection points between curves are, however, algebraic numbers, and their exact computation is time-consuming. The traits class therefore contains a layer of geometric filtering that performs all computations in an approximate manner whenever possible. Thus, it resorts to exact computations only when the approximate computation fails to produce an unambiguous result. Most arrangement vertices are therefore associated with approximated points. You cannot access the coordinates of such points as algebraic numbers. However, access to the approximate coordinates is possible. See the Reference Manual for the exact interface of the <ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref>, <ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref>, and <ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> types defined by the traits class.</para>
<para>Every instance of the <computeroutput><ref refid="classCGAL_1_1Arr__Bezier__curve__traits__2" kindref="compound">Arr_Bezier_curve_traits_2</ref></computeroutput> class templates models the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> (but it does not model the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept). It also models the refined concept <computeroutput><ref refid="classArrangementDirectionalXMonotoneTraits__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">ArrangementDirectionalXMonotoneTraits_2</ref></computeroutput>, which enables Boolean set operations; see Package <ref refid="group__PkgBooleanSetOperations2Ref" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">2D Regularized Boolean Set-Operations Reference</ref>.</para>
<para><anchor id="index_1fig__aos_fig-bezier_curves"/> <image type="html" name="bezier_curves.png"></image>
 <image type="latex" name="bezier_curves.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-bezier_curves" kindref="member">fig__aos_fig-bezier_curves</ref> An arrangement of ten B<eacute/>zier curves of degree <formula id="337">$5$</formula>, as constructed in <ref refid="Arrangement_on_surface_2_2Bezier_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/Bezier_curves.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example reads a set of B<eacute/>zier curves from an input file, where each file is specified by an integer stating its number of control points, followed by the sequence of control points given as integer or rational coordinates. By default, the program uses the <computeroutput>Bezier.dat</computeroutput> file, which contains ten curves of degree <formula id="337">$5$</formula> each; their resulting arrangement is depicted in <ref refid="index_1fig__aos_fig-bezier_curves" kindref="member">fig__aos_fig-bezier_curves</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2Bezier_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/Bezier_curves.cpp</ref> <programlisting filename="Arrangement_on_surface_2/Bezier_curves.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>Bezier<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_CORE</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_Bezier.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;read_objects.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Bezier.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;Bezier.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>Bezier<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Bezier_curve&gt;<sp/><sp/>curves;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>read_objects&lt;Bezier_curve&gt;(filename,<sp/>std::back_inserter(curves));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>curves.begin(),<sp/>curves.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>GMP<sp/>and<sp/>CORE\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1arr_sssectr_alg">
<title>A Traits Class for Planar Algebraic Curves of Arbitrary Degree</title>
<para>The traits class, namely <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref></computeroutput>, is based on the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref></computeroutput> class template, which models the algebraic-kernel concept <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput>; see Section <ref refid="index_1arr_sssectr_ratfunc" kindref="member">A Traits Class for Arcs of Rational Functions</ref>. The traits class handles (i) algebraic curves and (ii) continuous (weakly) <formula id="7">$x$</formula>-monotone segments of algebraic curves, which, however, are not necessarily maximal. (A formal definition is given below.) Observe that non- <formula id="7">$x$</formula>-monotone segments are not supported. Still, it is the traits class that supports the most general type of curves among the traits classes included in the package.</para>
<para>Recall that an algebraic curve <formula id="8">$c$</formula> in the plane is defined as the (real) zero set of a bivariate polynomial <formula id="338">$f(x,y)$</formula>. The curve is uniquely defined by <formula id="46">$f$</formula>, although several polynomials might define the same curve. We call <formula id="46">$f$</formula> a <emphasis>defining polynomial</emphasis> of <formula id="8">$c$</formula>.</para>
<para>A formal definition of (weakly) <formula id="7">$x$</formula>-monotone segments of algebraic curves follows. A point <formula id="59">$p$</formula> on a curve <formula id="339">$c_f \subset \mathbb{R}^2$</formula> (with defining polynomial <formula id="46">$f$</formula>) is called <emphasis>semi-regular</emphasis> if, locally around <formula id="59">$p$</formula>, the curve <formula id="340">$c_f$</formula> can be written as a function graph of some continuous function in <formula id="7">$x$</formula> or in <formula id="106">$y$</formula>. (We also say that <formula id="59">$p$</formula> is parameterizable in <formula id="7">$x$</formula> or <formula id="106">$y$</formula>, respectively.) The only two cases of non-semi-regular points are isolated points and self-intersections. A <emphasis>segment</emphasis> of a curve in this context is a closed and continuous point set such that each interior point is semi-regular. It follows that a segment is either vertical or a closed connected point set, with all interior points parameterizable in <formula id="7">$x$</formula>.</para>
<para>Every instance of the <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref>&lt;Coefficient&gt;</computeroutput> class template models the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> and <computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> concepts (but it does not model the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept). The template argument <computeroutput>Coefficient</computeroutput> determines the type of the scalar coefficients of the polynomial. Currently supported integral number types are <computeroutput><ref refid="classCGAL_1_1Gmpz" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Gmpz</ref></computeroutput>, <computeroutput><ref refid="classleda__integer" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">leda_integer</ref></computeroutput>, and <computeroutput><ref refid="classCORE_1_1BigInt" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::BigInt</ref></computeroutput>. This is reflected in the statements included in the header file <computeroutput>integer_type.h</computeroutput>, the listings of which are omitted here. This header file is used by the two example programs listed in this section. The template parameter <computeroutput>Coefficient</computeroutput> can be substituted in addition by an instance of the <computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Sqrt_extension</ref>&lt;A,B&gt;</computeroutput> class template, where the template parameters <computeroutput>NT</computeroutput> and <computeroutput>Root</computeroutput> are substituted in turn by one of the integral number types above. Finally, the template parameter <computeroutput>Coefficient</computeroutput> can be substituted also by a rational number type, where the type of the numerator and denominator is one of the types above.</para>
<para>The type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> nested in the <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref></computeroutput> class template defines an algebraic curve. An object of this type can be constructed by the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__curve__2" kindref="compound"><computeroutput>Construct_curve_2</computeroutput></ref> functor also nested in the class template. Its function operator accepts as an argument an object of type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1a9305250a25724c9ecba59aca43aeda25" kindref="member"><computeroutput>Polynomial_2</computeroutput></ref>, nested as well in the traits class-template. The type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1a9305250a25724c9ecba59aca43aeda25" kindref="member"><computeroutput>Polynomial_2</computeroutput></ref> models the concept <computeroutput>Polynomial_d</computeroutput>. An object of the nested type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1a9305250a25724c9ecba59aca43aeda25" kindref="member"><computeroutput>Polynomial_2</computeroutput></ref> represents a bivariate polynomial. It can be constructed in a few convenient ways, some are exemplified by the programs listed below. Consult the reference guide for the complete set of options.</para>
<para><anchor id="index_1fig__aos_fig-algebraic_curves"/> <image type="html" name="algebraic_curves.png"></image>
 <image type="latex" name="algebraic_curves.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-algebraic_curves" kindref="member">fig__aos_fig-algebraic_curves</ref> An arrangement of algebraic curves of degrees <formula id="269">$1$</formula>, <formula id="64">$2$</formula>, <formula id="306">$3$</formula>, and <formula id="341">$6$</formula>, as constructed in <ref refid="Arrangement_on_surface_2_2algebraic_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_curves.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following examples computes the arrangement depicted in in <ref refid="index_1fig__aos_fig-algebraic_curves" kindref="member">fig__aos_fig-algebraic_curves</ref>. The arrangement is induced by four algebraic curves, <formula id="0">$c_1$</formula>, <formula id="1">$c_2$</formula>, <formula id="126">$c_3$</formula>, and <formula id="342">$c_4$</formula>, of degrees <formula id="269">$1$</formula>, <formula id="64">$2$</formula>, <formula id="306">$3$</formula>, and <formula id="341">$6$</formula>, respectively. For each curve the defining polynomial is constructed first. Then, the algebraic curve is constructed using the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__curve__2" kindref="compound"><computeroutput>Construct_curve_2</computeroutput></ref> functor. Finally, the curve is inserted into the arrangement.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2algebraic_curves_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_curves.cpp</ref> <programlisting filename="Arrangement_on_surface_2/algebraic_curves.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>algebraic<sp/>curves.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>(!CGAL_USE_CORE)<sp/>&amp;&amp;<sp/>(!CGAL_USE_LEDA)<sp/>&amp;&amp;<sp/>(!(CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI))</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE,<sp/>LEDA,<sp/>or<sp/>GMP+MPFI<sp/>...&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;integer_type.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Curve<sp/>=<sp/>Traits::Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Polynomial<sp/>=<sp/>Traits::Polynomial_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga2cbb865dd83eedd780f4a452635b1d28" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_pretty_mode</ref>(std::cout);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>nice<sp/>printouts.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Functor<sp/>to<sp/>create<sp/>a<sp/>curve<sp/>from<sp/>a<sp/>Polynomial.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>construct_cv<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>y<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>unbounded<sp/>line<sp/>(C1)<sp/>with<sp/>the<sp/>equation<sp/>3x<sp/>-<sp/>5y<sp/>-<sp/>2<sp/>=<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>f1<sp/>=<sp/>3*x<sp/>-<sp/>5*y<sp/>-<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv1<sp/>=<sp/>construct_cv(f1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f1<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>cv1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>ellipse<sp/>(C2)<sp/>with<sp/>the<sp/>equation<sp/>x^2<sp/>+<sp/>3*y^2<sp/>-<sp/>10<sp/>=<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>f2<sp/>=<sp/>CGAL::ipower(x,<sp/>2)<sp/>+<sp/>3*CGAL::ipower(y,<sp/>2)<sp/>-<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv2<sp/>=<sp/>construct_cv(f2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f2<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>cv2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>cubic<sp/>curve<sp/>(C3)<sp/>with<sp/>the<sp/>equation<sp/>x^2<sp/>+<sp/>y^2<sp/>+<sp/>xy^2<sp/>=<sp/>0,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>with<sp/>isolated<sp/>point<sp/>at<sp/>(0,0)<sp/>and<sp/>vertical<sp/>asymptote<sp/>at<sp/>x<sp/>=<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>f3<sp/>=<sp/>CGAL::ipower(x,<sp/>2)<sp/>+<sp/>CGAL::ipower(y,<sp/>2)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>x*CGAL::ipower(y,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv3<sp/>=<sp/>construct_cv(f3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f3<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>cv3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>curve<sp/>of<sp/>degree<sp/>6<sp/>(C4)<sp/>with<sp/>the<sp/>equation</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>x^6<sp/>+<sp/>y^6<sp/>-<sp/>x^3y^3<sp/>-<sp/>12<sp/>=<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>f4<sp/>=<sp/>CGAL::ipower(x,<sp/>6)<sp/>+<sp/>CGAL::ipower(y,<sp/>6)<sp/>-</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::ipower(x,<sp/>3)*CGAL::ipower(y,<sp/>3)<sp/>-<sp/>12;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv4<sp/>=<sp/>construct_cv(f4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Inserting<sp/>curve<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>f4<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>cv4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>arrangement<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref></computeroutput> class template carries state to expedite some of its computations. Thus, it is essential to have only one copy of the traits object during the life time of a program that utilizes this traits class. To this end, the example above uses the constructor of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> data structure that accepts the traits object as input. Carrying state is not a unique property of the <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref></computeroutput> class template; it is common to many traits classes, especially to traits classes that handle algebraic curves. Therefore, as a general rule, if your application requires direct access to a traits object, define it locally, and pass it to the constructor of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> data structure to avoid the construction of a duplicate traits-class object.</para>
<para>A weakly <formula id="7">$x$</formula>-monotone segment of an algebraic curve is represented by the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> type nested in the traits class-template. You can construct such segments in two ways as follows: (i) using the <ref refid="classArrangementTraits__2_1ae7fb20dc627766bd122192d6e5c1da57" kindref="member"><computeroutput>Make_x_monotone_2</computeroutput></ref> functor or (ii) using the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2" kindref="compound"><computeroutput>Construct_x_monotone_segment_2</computeroutput></ref> functor. Both functors are nested in the traits class-template. The former is required by the concept <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> our traits class models; see Section <ref refid="index_1aos_sssec-geom_traits-concepts_arbitrary" kindref="member">Supporting Arbitrary Curves</ref>. The latter enables the construction of individual segments. The <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> type represents weakly <formula id="7">$x$</formula>-monotone segments of a curve; however, for technical reasons, segments may need to be further subdivided into several sub-segments, called terminal segments. Therefore, <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2" kindref="compound"><computeroutput>Construct_x_monotone_segment_2</computeroutput></ref> constructs a sequence of <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> objects, whose union represents the desired weakly <formula id="7">$x$</formula>-monotone segment. The function operator of the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2" kindref="compound"><computeroutput>Construct_x_monotone_segment_2</computeroutput></ref> functor accepts as arguments the underlying algebraic curve, the leftmost point of the segment, the rightmost point of the segment, and an output iterator associated with a container of output terminal segments. The function operator is overloaded. In addition to the variant above, there is one that accepts the underlying algebraic curve, a single point <formula id="59">$p$</formula>, an enumerator that delimits the segment, and an output iterator. It returns the maximal <formula id="7">$x$</formula>-monotone segment that contains <formula id="59">$p$</formula>. The enumerator specifies whether <formula id="59">$p$</formula> is interior to the returned segment, its left endpoint, or its right endpoint. The third variant accepts only two delimiting points and an output iterator. It constructs line segments.</para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly>  The subdivision terminal segments is due to the internal representation of <formula id="7">$x$</formula>-monotone segments, which is based on a vertical decomposition. We assume the defining polynomial <formula id="46">$f$</formula> of the curve <formula id="8">$c$</formula> to be <emphasis>square-free</emphasis>. That is, it contains no divisor <formula id="343">$g^2$</formula> of total degree greater than zero. We define a <emphasis>(complex) critical point</emphasis> <formula id="344">$p\in\mathbb{C}^2$</formula> by <formula id="345">\[ f(p)=0=\frac{\partial f}{\partial y}(p). \]</formula> An <formula id="7">$x$</formula>-coordinate <formula id="346">$\alpha\in\mathbb{R}$</formula> is <emphasis>critical</emphasis> either if some critical point has <formula id="7">$x$</formula>-coordinate <formula id="271">$\alpha$</formula>, or if the leading coefficient of <formula id="46">$f$</formula>, considered as a polynomial in <formula id="106">$y$</formula>, vanishes. In particular, vertical lines and isolated points of <formula id="8">$c$</formula> can only take place at critical <formula id="7">$x$</formula>-coordinates. Between two consecutive critical <formula id="7">$x$</formula>-coordinates the curve decomposes into a finite number of <formula id="7">$x$</formula>-monotone segments (the same holds to the left of the leftmost, and to the right of the rightmost critical <formula id="7">$x$</formula>-coordinate). The type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> is only capable of representing such segments (and sub-segments of them). Formally, a terminal segment is either a vertical line-segment or a segment of an <formula id="7">$x$</formula>-monotone curve whose <formula id="7">$x$</formula>-range does not contain critical points in its interior. See <ref refid="index_1fig__aos_fig-algebraic_curves_decomposition" kindref="member">fig__aos_fig-algebraic_curves_decomposition</ref> for an example of a quartic curve and its decomposition into terminal segments. Notice that six vertices split the curve into <formula id="7">$x$</formula>-monotone segments, and four additional vertices further split the corresponding <formula id="7">$x$</formula>-monotone segments into terminal segments. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
<para><anchor id="index_1fig__aos_fig-algebraic_curves_decomposition"/> <image type="html" name="algebraic_curves_decomposition.png"></image>
 <image type="latex" name="algebraic_curves_decomposition.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-algebraic_curves_decomposition" kindref="member">fig__aos_fig-algebraic_curves_decomposition</ref></para>
<para>The critical <formula id="7">$x$</formula>-coordinates of an algebraic curve (dashed lines), and its decomposition into terminal segments (in different colors). The segment from <formula id="59">$p$</formula> to <formula id="79">$q$</formula> consists of the union of three terminal segments. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The type <computeroutput>Algebraic_real_1</computeroutput> must be defined by any model of the <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput> concept. The traits class-template <computeroutput><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">Arr_algebraic_segment_traits_2</ref></computeroutput> exploits an instance of the <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref></computeroutput> class template, which models the concept <computeroutput><ref refid="classAlgebraicKernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">AlgebraicKernel_d_1</ref></computeroutput>. The exploited instance is nested in the traits class-template. You can use this model to create algebraic numbers as roots of univariate polynomials, and process them, for instance, compare them or approximate them to any precision. See the documentation of the concept <computeroutput>AlgebraicKernel_1</computeroutput> for more information. Coordinates of points are represented by the type <computeroutput>Algebraic_real_1</computeroutput> nested in the traits class-template. This type is defined as the corresponding type nested in the instance of <computeroutput><ref refid="classCGAL_1_1Algebraic__kernel__d__1" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_kernel_d.tag">Algebraic_kernel_d_1</ref></computeroutput>.</para>
<para>You can construct an object of type <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Point__2" kindref="compound"><computeroutput>Point_2</computeroutput></ref> using the <ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__point__2" kindref="compound"><computeroutput>Construct_point_2</computeroutput></ref> functor nested in the traits class-template. Its function operator is overloaded with a couple of variants that accepts the <formula id="7">$x$</formula> and <formula id="106">$y$</formula> coordinates of the point. Their types must be either <computeroutput>Algebraic_real_1</computeroutput> or <computeroutput>Coefficient</computeroutput>. Another efficient variant accepts a triple <formula id="347">$(x_0,c,i)$</formula>, which identifies the <formula id="243">$i$</formula>-th point (counted from below) in the fiber of <formula id="8">$c$</formula> at the <formula id="7">$x$</formula>-coordinate <formula id="348">$x_0$</formula>. The fiber of a curve <formula id="8">$c$</formula> at some <formula id="7">$x$</formula>-coordinate <formula id="349">$x&apos;$</formula> is the set of all points on <formula id="8">$c$</formula> with <formula id="7">$x$</formula>-coordinate <formula id="349">$x&apos;$</formula>. Formally, for a curve <formula id="8">$c$</formula> and <formula id="350">$x&apos;
\in \mathbb{R}$</formula>, the fiber of <formula id="8">$c$</formula> at <formula id="349">$x&apos;$</formula> is <formula id="351">$c \cap
{(x&apos;,b),|,b \in \mathbb{R}}$</formula>. In the example depicted in <ref refid="index_1fig__aos_fig-algebraic_curves_decomposition" kindref="member">fig__aos_fig-algebraic_curves_decomposition</ref>, if <formula id="352">$x_1$</formula> denotes the <formula id="7">$x$</formula>-coordinate of <formula id="59">$p$</formula>, and <formula id="8">$c$</formula> represents the algebraic curve, then <formula id="59">$p$</formula> could be represented by <formula id="353">$(x_1,c,3)$</formula>. If <formula id="354">$x_2$</formula> is the <formula id="7">$x$</formula>-coordinate of <formula id="79">$q$</formula>, then <formula id="355">$(x_2,c,1)$</formula> is a valid representation of <formula id="79">$q$</formula>. Points are represented internally using the triple described above. Although the <formula id="106">$y$</formula>-coordinate of a point represented by an object of the nested type <computeroutput>Algebraic_real_1</computeroutput> can be obtained, we advise caution with that option, since computing an explicit representation of the <formula id="106">$y$</formula>-coordinate can be rather expensive.</para>
<para><anchor id="index_1fig__aos_fig-algebraic_segments"/> <image type="html" name="algebraic_segments.png"></image>
 <image type="latex" name="algebraic_segments.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-algebraic_segments" kindref="member">fig__aos_fig-algebraic_segments</ref> An arrangement of algebraic segments (solid lines), as constructed in <ref refid="Arrangement_on_surface_2_2algebraic_segments_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_segments.cpp</ref>. The supporting curves are drawn as dashed lines. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following code exemplifies the method to construct points and the various methods to construct algebraic segments. The computed arrangement is depicted in <ref refid="index_1fig__aos_fig-algebraic_segments" kindref="member">fig__aos_fig-algebraic_segments</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2algebraic_segments_8cpp-example" kindref="compound">Arrangement_on_surface_2/algebraic_segments.cpp</ref> <programlisting filename="Arrangement_on_surface_2/algebraic_segments.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>algebraic<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>(!CGAL_USE_CORE)<sp/>&amp;&amp;<sp/>(!CGAL_USE_LEDA)<sp/>&amp;&amp;<sp/>(!(CGAL_USE_GMP<sp/>&amp;&amp;<sp/>CGAL_USE_MPFI))</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Sorry,<sp/>this<sp/>example<sp/>needs<sp/>CORE,<sp/>LEDA,<sp/>or<sp/>GMP+MPFI<sp/>...&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;integer_type.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__algebraic__segment__traits__2" kindref="compound">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Curve<sp/>=<sp/>Traits::Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Polynomial<sp/>=<sp/>Traits::Polynomial_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Algebraic_real<sp/>=<sp/>Traits::Algebraic_real_1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">X_monotone_curve<sp/>=<sp/>Traits::X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point<sp/>=<sp/>Traits::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Make_x_monotone_result<sp/>=<sp/>std::variant&lt;Point,<sp/>X_monotone_curve&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>make_xmon<sp/>=<sp/>traits.make_x_monotone_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_cv<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_pt<sp/>=<sp/>traits.construct_point_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>construct_xseg<sp/>=<sp/>traits.construct_x_monotone_segment_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>x<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polynomial<sp/>y<sp/>=<sp/>CGAL::shift(Polynomial(1),<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>curve<sp/>(C1)<sp/>with<sp/>the<sp/>equation<sp/>x^4+y^3-1=0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv1<sp/>=<sp/>ctr_cv(CGAL::ipower(x,<sp/>4)<sp/>+<sp/>CGAL::ipower(y,<sp/>3)<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>all<sp/>x-monotone<sp/>segments<sp/>using<sp/>the<sp/>Make_x_mononotone<sp/>functor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Make_x_monotone_result&gt;<sp/>pre_segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>make_xmon(cv1,<sp/>std::back_inserter(pre_segs));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Cast<sp/>all<sp/>CGAL::Objects<sp/>into<sp/>X_monotone_segment</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>(the<sp/>vector<sp/>might<sp/>also<sp/>contain<sp/>Point<sp/>objects<sp/>for<sp/>isolated<sp/>points,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>but<sp/>not<sp/>in<sp/>this<sp/>case).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;X_monotone_curve&gt;<sp/>segs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>pre_segs.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>curr_p<sp/>=<sp/>std::get_if&lt;X_monotone_curve&gt;(&amp;pre_segs[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(curr_p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segs.push_back(*curr_p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>ellipse<sp/>(C2)<sp/>with<sp/>the<sp/>equation<sp/>2*x^2+5*y^2-7=0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv2<sp/>=<sp/>ctr_cv(2*CGAL::ipower(x,2)+5*CGAL::ipower(y,2)-7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>point<sp/>on<sp/>the<sp/>upper<sp/>arc<sp/>(counting<sp/>of<sp/>arc<sp/>numbers<sp/>starts<sp/>with<sp/>0).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p11<sp/>=<sp/>ctr_pt(Algebraic_real(0),<sp/>cv2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_xseg(cv2,<sp/>p11,<sp/>Traits::POINT_IN_INTERIOR,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>vertical<sp/>cusp<sp/>(C3)<sp/>with<sp/>the<sp/>equation<sp/>x^2-y^3=0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv3<sp/>=<sp/>ctr_cv(CGAL::ipower(x,<sp/>2)-CGAL::ipower(y,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>segment<sp/>containing<sp/>the<sp/>cusp<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>adds<sp/>two<sp/>X_monotone_curve<sp/>objects<sp/>to<sp/>the<sp/>vector,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>because<sp/>the<sp/>cusp<sp/>is<sp/>a<sp/>critical<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p21<sp/>=<sp/>ctr_pt(Algebraic_real(-2),<sp/>cv3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p22<sp/>=<sp/>ctr_pt(Algebraic_real(2),<sp/>cv3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_xseg(cv3<sp/>,p21,<sp/>p22,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>unbounded<sp/>curve,<sp/>starting<sp/>at<sp/>x=3.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p23<sp/>=<sp/>ctr_pt(Algebraic_real(3),<sp/>cv3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_xseg(cv3,<sp/>p23,<sp/>Traits::MIN_ENDPOINT,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>another<sp/>conic<sp/>(C4)<sp/>with<sp/>the<sp/>equation<sp/>y^2-x^2+1=0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv4<sp/>=<sp/>ctr_cv(CGAL::ipower(y,2)-CGAL::ipower(x,2)+1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p31<sp/>=<sp/>ctr_pt(Algebraic_real(2),<sp/>cv4,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_xseg(cv4,<sp/>p31,<sp/>Traits::MAX_ENDPOINT,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>vertical<sp/>segment<sp/>(C5).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>cv5<sp/>=<sp/>ctr_cv(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>v1<sp/>=<sp/>ctr_pt(Algebraic_real(0),<sp/>cv3,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>v2<sp/>=<sp/>ctr_pt(Algebraic_real(0),<sp/>cv2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_xseg(cv5,<sp/>v1,<sp/>v2,<sp/>std::back_inserter(segs));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>segs.begin(),<sp/>segs.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>some<sp/>isolated<sp/>points<sp/>(must<sp/>be<sp/>wrapped<sp/>into<sp/>CGAL::Object).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;CGAL::Object&gt;<sp/>isolated_pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isolated_pts.push_back(CGAL::make_object(ctr_pt(Algebraic_real(2),<sp/>cv4,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isolated_pts.push_back(CGAL::make_object(ctr_pt(Integer(1),<sp/>Integer(2))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isolated_pts.push_back(CGAL::make_object(ctr_pt(Algebraic_real(-1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algebraic_real(2))));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>isolated_pts.begin(),<sp/>isolated_pts.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>the<sp/>arrangement<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
</sect4>
</sect3>
<sect3 id="index_1arr_ssectr_spherical">
<title>Arcs of Great Circles Embedded in the Sphere</title>
<para>A great circle of a sphere is the intersection of the sphere and a plane that passes through the center point of the sphere. For all pairs of distinct points on the sphere except for antipodal points, there is a unique great circle through the two points. There are infinitely many great circles through antipodal points. The minor arc of a great circle between two points is the shortest spherical-path between them. In this sense, minor arcs are analogous to line segments in Euclidean geometry.</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,X,Y&gt;</computeroutput> class template handles arcs of great circles (also known as geodesic arcs) of a unit sphere (centered at the origin in <formula id="4">$\mathbb{R}^3$</formula>). It is a model of the concept <computeroutput><ref refid="classArrangementSphericalBoundaryTraits__2" kindref="compound">ArrangementSphericalBoundaryTraits_2</ref></computeroutput>; see Section <ref refid="index_1aos_ssec-traits-curved" kindref="member">Supporting Unbounded Curves or Curved Surfaces</ref>. An arrangement type (an instance of the template <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeomTraits, TopolTraits&gt;</computeroutput>) that uses an instance of this traits class as the geometry traits must use a matching topology traits. Currently, this package provides one template, namely, <computeroutput><ref refid="classCGAL_1_1Arr__spherical__topology__traits__2" kindref="compound">Arr_spherical_topology_traits_2</ref>&lt;GeometryTraits_2, Dcel&gt;</computeroutput> an instance of which can be used as the topology traits.</para>
<para>The unit sphere is defined over a parameter space <formula id="356">$\Phi =
[\tau,2\pi+\tau] \times [-\frac{\pi}{2}, \frac{\pi}{2}]$</formula>, where <formula id="357">$\tau = \arctan(X, Y)$</formula>. By default, <formula id="358">$X = -1, Y = 0$</formula>, which implies <formula id="359">$\tau = -\pi$</formula>, which implies a default parameterization <formula id="166">$\Phi = [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}]$</formula>. The equator curve, for example, is given by <formula id="360">$\gamma(t) = (2t\pi + \tau,
0)$</formula>, for <formula id="194">$t \in [0,1]$</formula>. The surface is given by  <formula id="361">$\phi_S(\alpha,\beta) = (\cos \alpha \cos \beta, \sin \alpha \cos
\beta, \sin \beta)$</formula>; see Section <ref refid="index_1aos_sec-curved_surfaces" kindref="member">Arrangements on Curved Surfaces</ref> for more details. This parameterization induces two contraction points <formula id="362">$(0,0,-1) = \phi_S(\alpha,-\frac{\pi}{2})$</formula> and <formula id="363">$(0,0,1) =
\phi_S(\alpha,\frac{\pi}{2})$</formula>, for all <formula id="271">$\alpha$</formula>, referred to as the south and north poles, respectively, and an identification curve  <formula id="364">$\{\phi_S(\alpha,\beta)\,|\,-\frac{\pi}{2} \leq \beta \leq
\frac{\pi}{2}\}$</formula>, as <formula id="365">$\phi_S(\pi,\beta) = \phi_S(2\pi +
\tau,\beta)$</formula> for all <formula id="272">$\beta$</formula>. When <formula id="359">$\tau = -\pi$</formula> (the default), the identification curve coincides with the opposite Prime (Greenwich) Meridian. In other words, the left and right boundary sides of the parameter space are identified and the top and bottom boundary sides are contracted. The arguments that substitute the template parameters <computeroutput>X</computeroutput> and <computeroutput>Y</computeroutput> when <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2</ref>&lt;<ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>, X, Y&gt;</computeroutput> is instantiated determine the value of <formula id="366">$\tau$</formula>. Essentially, overriding their default values rotates the identification curve about the vertical axes of the image coordinate system (that is, the sphere coordinate system). These arguments must be integral values. They define a not-necessarily normalized vector <formula id="284">$(x,y)$</formula> in the <formula id="29">$xy$</formula>-plane in the image coordinate system, that bisects the identification curve. The explicit expression for the surface above is not used at all in the implementation of the traits. Indeed, all the required geometric operations listed in the traits concept are implemented using only rational arithmetic.</para>
<para>The following example constructs an arrangement induced by 12 arcs of great circles embedded in the sphere. The arrangement is depicted in <ref refid="index_1fig__spherical_insert" kindref="member">fig__spherical_insert</ref>.</para>
<para><anchor id="index_1fig__spherical_insert"/> <image type="html" name="spherical_insert.png"></image>
 <image type="latex" name="spherical_insert.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__spherical_insert" kindref="member">fig__spherical_insert</ref> An arrangement induced by 12 arcs of great circles, as constructed in <ref refid="Arrangement_on_surface_2_2spherical_insert_8cpp-example" kindref="compound">Arrangement_on_surface_2/spherical_insert.cpp</ref>. The number of vertices, edges, and faces of the arrangement is 7, 13, and 8, respectively. The intersection of the curve <formula id="367">$(-1,0,0),(0,1,0)$</formula> with the identification curve induces a vertex at <formula id="368">$(\frac{-11}{\sqrt{11^2+7^2}},\frac{7}{\sqrt{11^2+7^2}},0)$</formula> drawn in green. The north and south poles are drawn as little spheres. The identification curve is drawn as a gray tube. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2spherical_insert_8cpp-example" kindref="compound">Arrangement_on_surface_2/spherical_insert.cpp</ref> <programlisting filename="Arrangement_on_surface_2/spherical_insert.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>of<sp/>arcs<sp/>of<sp/>great<sp/>circles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdio&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_on_surface_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_geodesic_arc_on_sphere_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_spherical_topology_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_geodesic.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Geom_traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_p<sp/>=<sp/>traits.construct_point_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_cv<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1<sp/>=<sp/>ctr_p(0,<sp/>0,<sp/>-1),<sp/>p3<sp/>=<sp/>ctr_p(0,<sp/>-1,<sp/>0),<sp/>p5<sp/>=<sp/>ctr_p(-1,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p2<sp/>=<sp/>ctr_p(0,<sp/>0,<sp/><sp/>1),<sp/>p4<sp/>=<sp/>ctr_p(0,<sp/><sp/>1,<sp/>0),<sp/>p6<sp/>=<sp/>ctr_p(<sp/>1,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>arcs[]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ctr_cv(p6,<sp/>p1),<sp/>ctr_cv(p6,<sp/>p2),<sp/>ctr_cv(p4,<sp/>p1),<sp/>ctr_cv(p4,<sp/>p2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ctr_cv(p5,<sp/>p1),<sp/>ctr_cv(p5,<sp/>p2),<sp/>ctr_cv(p3,<sp/>p1),<sp/>ctr_cv(p3,<sp/>p2),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ctr_cv(p6,<sp/>p4),<sp/>ctr_cv(p6,<sp/>p3),<sp/>ctr_cv(p5,<sp/>p4),<sp/>ctr_cv(p5,<sp/>p3)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>arcs,<sp/>arcs<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(arcs)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Curve));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Use the <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__point__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2::Construct_point_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__x__monotone__curve__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2::Construct_x_monotone_curve_2</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__curve__2" kindref="compound">Arr_geodesic_arc_on_sphere_traits_2::Construct_curve_2</ref></computeroutput> functors to construct a point, an <formula id="143">$X$</formula>-monotone curve and a curve objects, respectively. Observe that an <formula id="143">$X$</formula>-monotone curve cannot intersect the identification curve in its interior. A curve can be constructed from either (i) two endpoints, (ii) two endpoints and a normal, or (iii) a normal. The two endpoints determine the plane. The normal determines the orientation of the plane and the final arc (whether it is the minor arc or the major arc). If the normal is not provided, the minor arc is constructed. If a curve is constructed and only the normal is provided a full great circle is constructed. If an <formula id="143">$X$</formula>-monotone curve is constructed and only the normal is provided an arc that resembles a full circle is constructed; this arc has one endpoint that lies on the identification curve; this point is considered both the source and target (and also the left and right) point of the arc. See <ref refid="index_1fig__aos_fig-right_hand_rule" kindref="member">fig__aos_fig-right_hand_rule</ref> for an illustration of the right-hand rule, which depicts the relation between the arc and the normal.</para>
<para><anchor id="index_1fig__aos_fig-right_hand_rule"/> <image type="html" name="right_hand_rule.png"></image>
 <image type="latex" name="right_hand_rule.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-right_hand_rule" kindref="member">fig__aos_fig-right_hand_rule</ref> To use the right hand rule, point your right thumb in the direction of the normal and curl your fingers in the direction of the arc starting with source endpoint and ending at the target endpoint. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect3>
</sect2>
<sect2 id="index_1arr_ssecmeta_tr">
<title>Traits-Class Decorators</title>
<para>Geometric traits-class decorators allow you to attach auxiliary data to the geometric objects (curves and to points). The data is automatically manipulated by the decorators and distributed to the constructed geometric entities. Additional information can alternatively be maintained by extending the vertex, halfedge, or face types provided by the DCEL class used by the arrangement; see Section <ref refid="index_1arr_ssecex_dcel" kindref="member">Extending the DCEL</ref> for details. In many cases, however, it is convenient to attach the data to the curve itself, exploiting the automatic proliferation of the additional data fields from each curve to all its induced subcurves. Moreover, as two halfedges are associated with a single curve, storing the data once in the curve record either saves space or avoids an indirect access from one halfedge to its twin.</para>
<para>The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package includes a traits-class decorator used to attach a data field to curves and to <formula id="7">$x$</formula>-monotone curves. It is a class template named <computeroutput><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">Arr_curve_data_traits_2</ref>&lt;BaseTraits, XMonotoneCurveData, Merge, CurveData, Convert&gt;</computeroutput> parameterized by a base-traits class, which must be substituted by one of the geometric traits models described in the previous subsections or with a user-defined traits model, when the decorator is instantiated. The curve-data decorator derives from the base-traits class, and in particular inherits its <ref refid="classCGAL_1_1Arr__curve__data__traits__2_1a77fe4ede82d2bb99f4212f0476e43d6d" kindref="member"><computeroutput>Point_2</computeroutput></ref> type. The remaining nested types are defined as follows:</para>
<para><itemizedlist>
<listitem>
<para><ref refid="classCGAL_1_1Arr__curve__data__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> is derived from the basic <computeroutput>BaseTraits::Curve_2</computeroutput> class, extending it by an extra field of type <computeroutput>CurveData</computeroutput>.</para>
<para></para>
</listitem>
<listitem>
<para><ref refid="classCGAL_1_1Arr__curve__data__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> is derived from the basic <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> class, extending it by an extra field of type <computeroutput>XMonotoneCurveData</computeroutput>, which must model the concepts <ref refid="classCopyConstructible" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CopyConstructible</ref>, <ref refid="classEqualityComparable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">EqualityComparable</ref>, and <ref refid="classDefaultConstructible" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">DefaultConstructible</ref>. The latter ensures that every instance of the class template <computeroutput><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">Arr_curve_data_traits_2</ref></computeroutput> obtained by substituting the <computeroutput>BaseTraits</computeroutput> template parameter with a model of the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept models the <computeroutput><ref refid="classArrangementLandmarkTraits__2" kindref="compound">ArrangementLandmarkTraits_2</ref></computeroutput> concept as well</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>Note that the nested <ref refid="classCGAL_1_1Arr__curve__data__traits__2_1_1Curve__2" kindref="compound"><computeroutput>Curve_2</computeroutput></ref> and <ref refid="classCGAL_1_1Arr__curve__data__traits__2_1_1X__monotone__curve__2" kindref="compound"><computeroutput>X_monotone_curve_2</computeroutput></ref> are not the same, even if the <computeroutput>BaseTraits::Curve_2</computeroutput> and <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> are (as in the case of the segment-traits class, for example). The extended curve types support the additional methods <ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">&lt;Tr, XData, Mrg, CData, Cnv&gt;::Curve_2::data() <computeroutput>data()</computeroutput></ref> and <ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">&lt;Tr, XData, Mrg, CData, Cnv&gt;::Curve_2::set_data() <computeroutput>set_data()</computeroutput></ref> for accessing and modifying the data field.</para>
<para>You can create an extended curve (or an extended <formula id="7">$x$</formula>-monotone curve) from a basic curve and a curve-data object. When curves are inserted into an arrangement, they may be split, and the decorator handles their data fields automatically as follows:</para>
<para><itemizedlist>
<listitem>
<para>When a curve is subdivided into <formula id="7">$x$</formula>-monotone subcurves, its data field of type <computeroutput>CurveData</computeroutput> is converted to an object of type <computeroutput>XMonotoneCurveData</computeroutput> using the <computeroutput>Convert</computeroutput> functor. The object is automatically associated with each of the resulting <formula id="7">$x$</formula>-monotone subcurves.</para>
<para>Note that by default, the <computeroutput>CurveData</computeroutput> type is identical to the <computeroutput>XMonotoneCurveData</computeroutput> type (and the conversion functor <computeroutput>Convert</computeroutput> is trivially defined). Thus, the data field associated with the original curve is just duplicated and stored with the <formula id="7">$x$</formula>-monotone subcurves.</para>
<para></para>
</listitem>
<listitem>
<para>When an <formula id="7">$x$</formula>-monotone curve is split into two (typically, when it intersects another curve), the decorator class automatically copies its data field to both resulting subcurves.</para>
<para></para>
</listitem>
<listitem>
<para>When two <formula id="7">$x$</formula>-monotone curves, <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula>, intersect, the result may include overlapping sections represented as <formula id="7">$x$</formula>-monotone curves. In this case the data fields of <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> are merged into a single <computeroutput>XMonotoneCurveData</computeroutput> object using the <computeroutput>Merge</computeroutput> functor, which is supplied as a parameter to the traits class-template. The resulting object is assigned to the data field of the overlapping subcurves.</para>
<para></para>
</listitem>
<listitem>
<para>Merging two <formula id="7">$x$</formula>-monotone curves is allowed only when (i) the two curves are geometrically mergeable<mdash/>that is, the base-traits class allows to merge them, and (ii) the two curves store the same data field.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>Another decorator supported by the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package is the <computeroutput><ref refid="classCGAL_1_1Arr__consolidated__curve__data__traits__2" kindref="compound">Arr_consolidated_curve_data_traits_2</ref>&lt;BaseTraits, Data&gt;</computeroutput> class template. It derives from the <computeroutput><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">Arr_curve_data_traits_2</ref></computeroutput> class template, and it extends the basic type <computeroutput>BaseTraits::Curve_2</computeroutput> by a single <computeroutput>Data</computeroutput> field, and the basic <computeroutput>BaseTraits::X_monotone_curve_2</computeroutput> with a <emphasis>set</emphasis> of (distinct) data objects. The <computeroutput>Data</computeroutput> type must model the concept <computeroutput><ref refid="classEqualityComparable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">EqualityComparable</ref></computeroutput> to ensure that each set contains only distinct data objects with no duplicates. When a curve with a data field <formula id="72">$d$</formula> is subdivided into <formula id="7">$x$</formula>-monotone subcurves, each subcurve is associated with a set <formula id="369">$S = \{d\}$</formula>. In the case of an overlap between two <formula id="7">$x$</formula>-monotone curves <formula id="0">$c_1$</formula> and <formula id="1">$c_2$</formula> with associated data sets <formula id="370">$S_1$</formula> and <formula id="371">$S_2$</formula>, respectively, the overlapping subcurve is associated with the consolidated set <formula id="372">$S_1 \cup S_2$</formula>.</para>
<para><anchor id="index_1fig__aos_fig-consolidated_curve_data"/> <image type="html" name="consolidated_curve_data.png"></image>
 <image type="latex" name="consolidated_curve_data.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-consolidated_curve_data" kindref="member">fig__aos_fig-consolidated_curve_data</ref> An arrangement of six red and blue segments, as constructed in <ref refid="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/consolidated_curve_data.cpp</ref>. Disks correspond to red-blue intersection points, while circles mark the endpoints of red-blue overlaps. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example uses <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> as the base-traits class, attaching an additional <emphasis>color</emphasis> field to the segments using the consolidated curve-data traits class. A color may be either <emphasis>blue</emphasis> or <emphasis>red</emphasis>. Having constructed the arrangement of colored segments, as depicted in <ref refid="index_1fig__aos_fig-consolidated_curve_data" kindref="member">fig__aos_fig-consolidated_curve_data</ref>, we detect the vertices that have incident edges mapped to both blue and red segments. These vertices, drawn as black discs in the figure, correspond to red-blue intersection points. We also locate the edge that corresponds to overlap between a red and a blue line segment (its endpoints are also drawn as black discs)</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/consolidated_curve_data.cpp</ref> <programlisting filename="Arrangement_on_surface_2/consolidated_curve_data.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Associating<sp/>a<sp/>color<sp/>attribute<sp/>with<sp/>segments<sp/>using<sp/>the<sp/>consolidated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>curve-data<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_consolidated_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Segment_color<sp/>{RED,<sp/>BLUE};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Data_traits<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arr__consolidated__curve__data__traits__2" kindref="compound">CGAL::Arr_consolidated_curve_data_traits_2&lt;Traits, Segment_color&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Colored_segment<sp/>=<sp/>Data_traits::Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Colored_arr<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Data_traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Colored_arr<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>containing<sp/>three<sp/>RED<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(-1,<sp/>-1),<sp/>Point(1,<sp/>3)),<sp/>RED));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(2,<sp/>0),<sp/>Point(3,<sp/>3)),<sp/>RED));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(0,<sp/>3),<sp/>Point(2,<sp/>5)),<sp/>RED));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>BLUE<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(-1,<sp/>3),<sp/>Point(4,<sp/>1)),<sp/>BLUE));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(-1,<sp/>0),<sp/>Point(4,<sp/>1)),<sp/>BLUE));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Colored_segment(Segment(Point(-2,<sp/>1),<sp/>Point(1,<sp/>4)),<sp/>BLUE));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>vertices<sp/>and<sp/>print<sp/>just<sp/>the<sp/>ones<sp/>corresponding<sp/>to<sp/>intersection</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points<sp/>between<sp/>RED<sp/>segments<sp/>and<sp/>BLUE<sp/>segments.<sp/>Skip<sp/>endpoints<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>overlapping<sp/>sections.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>current-vertex<sp/>incident-halfedges<sp/>and<sp/>examine<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Colored_arr::Halfedge_around_vertex_const_circulator<sp/>eit,<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit<sp/>=<sp/>first<sp/>=<sp/>vit-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>color<sp/>of<sp/>the<sp/>current<sp/>halfedge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(eit-&gt;curve().data().size()<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment_color<sp/>color<sp/>=<sp/>eit-&gt;curve().data().front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(color<sp/>==<sp/>RED)<sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(color<sp/>==<sp/>BLUE)<sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++eit<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>vertex<sp/>only<sp/>if<sp/>incident<sp/>RED<sp/>and<sp/>BLUE<sp/>edges<sp/>were<sp/>found.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(has_red<sp/>&amp;&amp;<sp/>has_blue)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Red<sp/>intersect<sp/>blue<sp/>at<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>edges<sp/>that<sp/>correspond<sp/>to<sp/>a<sp/>red-blue<sp/>overlap.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>incident<sp/>edges<sp/>of<sp/>the<sp/>current<sp/>vertex<sp/>and<sp/>examine<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>has_red{</highlight><highlight class="keyword">false</highlight><highlight class="normal">},<sp/>has_blue{</highlight><highlight class="keyword">false</highlight><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>eit-&gt;curve().data().begin();<sp/>it<sp/>!=<sp/>eit-&gt;curve().data().end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++it)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*it<sp/>==<sp/>RED)<sp/>has_red<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*it<sp/>==<sp/>BLUE)<sp/>has_blue<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>edge<sp/>only<sp/>if<sp/>it<sp/>corresponds<sp/>to<sp/>a<sp/>red-blue<sp/>overlap.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(has_red<sp/>&amp;&amp;<sp/>has_blue)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Red<sp/>overlap<sp/>blue<sp/>at<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-generic_curve_data"/> <image type="html" name="generic_curve_data.png"></image>
 <image type="latex" name="generic_curve_data.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-generic_curve_data" kindref="member">fig__aos_fig-generic_curve_data</ref> An arrangement of four polylines, named A-D, as constructed in <ref refid="Arrangement_on_surface_2_2generic_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/generic_curve_data.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example uses <computeroutput><ref refid="classCGAL_1_1Arr__polyline__traits__2" kindref="compound">Arr_polyline_traits_2</ref></computeroutput> as the base-traits class, attaching an additional <emphasis>name</emphasis> field to each polyline using the generic curve-data traits class. It constructs an arrangement of four polylines, named <formula id="373">$A$</formula>, <formula id="330">$B$</formula>, <formula id="8">$c$</formula>, and <formula id="374">$D$</formula>, as illustrated in <ref refid="index_1fig__aos_fig-generic_curve_data" kindref="member">fig__aos_fig-generic_curve_data</ref>. In the case of overlaps, it simply concatenate the names of the overlapping polylines. At the end of the program the curve associated with the edges that correspond to overlapping polylines are replaced with geometrically equivalent curves, but with different data fields.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2generic_curve_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/generic_curve_data.cpp</ref> <programlisting filename="Arrangement_on_surface_2/generic_curve_data.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Associating<sp/>a<sp/>name<sp/>attribute<sp/>with<sp/>segments<sp/>using<sp/>the<sp/>generic<sp/>curve-data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>traits.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_polylines.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Name<sp/>=<sp/>std::string;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>name-field<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Merge_names<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Name<sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Name&amp;<sp/>s1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Name&amp;<sp/>s2)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(s1<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>s2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">CGAL::Arr_curve_data_traits_2&lt;Traits, Name, Merge_names&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_polyline<sp/>=<sp/>Ex_traits::Curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_x_monotone_polyline<sp/>=<sp/>Ex_traits::X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Ex_traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>four<sp/>polylines<sp/>named<sp/>A--D.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_curve<sp/>=<sp/>traits.construct_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pts1[5]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{Point(0,<sp/>0),<sp/>Point(2,<sp/>4),<sp/>Point(3,<sp/>3),<sp/>Point(4,<sp/>4),<sp/>Point(6,<sp/>0)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Ex_polyline(ctr_curve(pts1,<sp/>pts1<sp/>+<sp/>5),<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pts2[3]<sp/>=<sp/>{Point(1,<sp/>5),<sp/>Point(3,<sp/>3),<sp/>Point(5,<sp/>5)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Ex_polyline(ctr_curve(pts2,<sp/>pts2<sp/>+<sp/>3),<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pts3[4]<sp/>=<sp/>{Point(1,<sp/>0),<sp/>Point(2,<sp/>2),<sp/>Point(4,<sp/>2),<sp/>Point(5,<sp/>0)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Ex_polyline(ctr_curve(pts3,<sp/>pts3<sp/>+<sp/>4),<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>pts4[2]<sp/>=<sp/>{Point(0,<sp/>2),<sp/>Point(6,<sp/>2)};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Ex_polyline(ctr_curve(pts4,<sp/>pts4<sp/>+<sp/>2),<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>all<sp/>edges<sp/>that<sp/>correspond<sp/>to<sp/>an<sp/>overlapping<sp/>polyline.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>overlapping<sp/>subcurves:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(eit-&gt;curve().data().length()<sp/>&gt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/><sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;named:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve().data()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Modify<sp/>the<sp/>curve<sp/>associated<sp/>with<sp/>the<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>arr.modify_edge(eit,<sp/>Ex_x_monotone_polyline(eit-&gt;curve(),<sp/></highlight><highlight class="stringliteral">&quot;overlap&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The third example we give in this section is based on <ref refid="Arrangement_on_surface_2_2dual_lines_8cpp-example" kindref="compound">Arrangement_on_surface_2/dual_lines.cpp</ref> given in Section <ref refid="index_1arr_ssec-unb_duality" kindref="member">Point-Line Duality</ref>. It constructs the arrangement of the dual lines for a set of point given in an input file (by default we use <computeroutput>coll_points.dat</computeroutput>, which contains <formula id="375">$50$</formula> points randomly selected on the grid <formula id="376">$[-100,100]\times[-100,100]$</formula>; the file contains two distinct triplets of collinear points). Here we use the generic curve-data decorator to attach the index of the primal point to each of the lines. Doing so, we can go over the incident edges of each vertex whose degree is greater than <formula id="132">$4$</formula> and report the subsets of collinear points (if we have a vertex of degree <formula id="72">$d$</formula>, we actually need to go over <formula id="377">$\frac{d}{2}$</formula> edges, as each incident line contributes exactly <formula id="64">$2$</formula> edges). Note that in this case the dual line cannot overlap, so we use a dummy merge functor to instantiate the curve-data traits:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dual_with_data_8cpp-example" kindref="compound">Arrangement_on_surface_2/dual_with_data.cpp</ref> <programlisting filename="Arrangement_on_surface_2/dual_with_data.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Checking<sp/>whether<sp/>there<sp/>are<sp/>three<sp/>collinear<sp/>points<sp/>in<sp/>a<sp/>given<sp/>input<sp/>set</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>using<sp/>the<sp/>arrangement<sp/>of<sp/>the<sp/>dual<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_curve_data_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;read_objects.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Data_traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__curve__data__traits__2" kindref="compound">CGAL::Arr_curve_data_traits_2&lt;Traits, size_t&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Data_x_monotone_curve_2<sp/>=<sp/>Data_traits::X_monotone_curve_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Data_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Data_traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>name<sp/>of<sp/>the<sp/>input<sp/>file<sp/>from<sp/>the<sp/>command<sp/>line,<sp/>or<sp/>use<sp/>the<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>points.dat<sp/>file<sp/>if<sp/>no<sp/>command-line<sp/>parameters<sp/>are<sp/>given.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;coll_points.dat&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>read_objects&lt;Point&gt;(filename,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Data_x_monotone_curve_2&gt;<sp/>dual_lines(points.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>k{0};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::transform(points.begin(),<sp/>points.end(),<sp/>dual_lines.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line<sp/>dual_line(p.x(),<sp/>-1,<sp/>-(p.y()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>Data_x_monotone_curve_2(dual_line,<sp/>k++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>dual<sp/>arrangement<sp/>by<sp/>aggregately<sp/>inserting<sp/>the<sp/>lines.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Data_arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>dual_lines.begin(),<sp/>dual_lines.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Look<sp/>for<sp/>vertices<sp/>whose<sp/>degree<sp/>is<sp/>greater<sp/>than<sp/>4.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vit-&gt;degree()<sp/>&gt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>should<sp/>be<sp/>vit-&gt;degree()/2<sp/>lines<sp/>intersecting<sp/>at<sp/>the<sp/>current</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>vertex.<sp/>We<sp/>print<sp/>their<sp/>primal<sp/>points<sp/>and<sp/>their<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>circ<sp/>=<sp/>vit-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>d<sp/>=<sp/>0;<sp/>d<sp/>&lt;<sp/>vit-&gt;degree()<sp/>/<sp/>2;<sp/>++d)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k<sp/>=<sp/>circ-&gt;curve().data();<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>index<sp/>of<sp/>the<sp/>primal<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Point<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>k+1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[k]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;),<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++circ;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;are<sp/>collinear.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-topol_traits">
<title>The Topology Traits</title>
<para>A topology traits class encapsulates the definitions of the topological entities and the implementation of the functions that handle these topological entities, used by the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits_2, TopologyTraits&gt;</computeroutput> class template and by the peripheral modules. Every topology traits class must model the basic concept <computeroutput><ref refid="classArrangementBasicTopologyTraits" kindref="compound">ArrangementBasicTopologyTraits</ref></computeroutput>. A model of this basic concept holds the (DCEL) data structure used to represent the arrangement cells (i.e., vertices, edges, and facets) and the incidence relations between them. At this point we do not expose the concepts that refine the basic concept. The package contains three topology traits class templates, namely, <computeroutput><ref refid="classCGAL_1_1Arr__bounded__planar__topology__traits__2" kindref="compound">Arr_bounded_planar_topology_traits_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__unb__planar__topology__traits__2" kindref="compound">Arr_unb_planar_topology_traits_2</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Arr__spherical__topology__traits__2" kindref="compound">Arr_spherical_topology_traits_2</ref></computeroutput>. The first two are internally used to define any instance of the class template <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;GeometryTraits_2, Dcel&gt;</computeroutput>. In particular, an instance <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Geometry_traits_2, Dcel_&gt;</computeroutput> is derived from the instance <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;Geometry_traits_2,Topology_traits&gt;</computeroutput>, where the <computeroutput>Topology_traits</computeroutput> type is selected based on the provided geometry traits <computeroutput>Geometry_traits_2</computeroutput>, or more precisely, on the boundary conditions defined by the geometry traits. If all sides of the boundary of the parameter space are closed, the instance <computeroutput><ref refid="classCGAL_1_1Arr__bounded__planar__topology__traits__2" kindref="compound">Arr_bounded_planar_topology_traits_2</ref>&lt;Geometry_traits_2,Dcel_&gt;</computeroutput> is selected; otherwise the instance <computeroutput><ref refid="classCGAL_1_1Arr__unb__planar__topology__traits__2" kindref="compound">Arr_unb_planar_topology_traits_2</ref>&lt;Geometry_traits_2,Dcel_&gt;</computeroutput> is selected. The third topology traits serves as a topology traits for an arrangement embedded on a sphere. More precisely, for an arrangement embedded on a sphere defined over a parameter space, the left and right boundary sides of which are identified, and the top and bottom boundary sides are contracted.</para>
</sect1>
<sect1 id="index_1arr_sec_extending">
<title>Extending the Arrangement</title>
<para>Developing applications that use arrangements to solve problems that are a bit more complicated than the problems presented in previous chapters requires the ability to adapt the arrangement data structure to the application needs. One technique to do this is to extend the arrangement with auxiliary, usually non-geometric, data. In this chapter we describe several ways to extend an arrangement data structure.</para>
<sect2 id="index_1arr_ssecnotif">
<title>The Notification Mechanism</title>
<para>In some cases it is essential to know exactly what happens inside a specific arrangement object. For example, when a new curve is inserted into an arrangement, it may be necessary to keep track of the faces that are split due to this insertion operation. Other important examples are the point-location strategies that require auxiliary data structures (see Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>), which must be kept up-to-date when the arrangement changes. The <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package offers a mechanism that uses <emphasis>observers</emphasis> (see <ref refid="citelist_1CITEREF_cgal:ghjv-dpero-95" kindref="member">[7]</ref>). The objective behind this mechanism is to define a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically. The observed object does not know anything about the observers. It merely &quot;publishes&quot; information about changes when they occur. In our case observers can be attached to an arrangement object.</para>
<para>An observer object that observes changes in an arrangement object stores a pointer to the attached arrangement object. It receives notifications about the changes this arrangement undergoes. The observer receives notifications <emphasis>just before</emphasis> a structural change occurs in the arrangement and <emphasis>immediately after</emphasis> such a change takes place. An observer object that observes changes in an arrangement object of type <computeroutput>Arrangement</computeroutput> must be of a type derived from <computeroutput>Arrangement::Observer</computeroutput>, which is an alias to <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&gt;</computeroutput>, where <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput> is the type of the arrangement object or its base type. An instance of <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref>&lt;&gt;</computeroutput> serves as a base type for other observer classes and defines a set of virtual notification functions, with default empty implementations. You can also use the template alias <computeroutput>Arr_observer&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput>, where <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> is the type of the arrangement object in case it is derived from an instance of the template <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref></computeroutput>. The set of functions can be divided into three categories, as follows:</para>
<para><orderedlist>
<listitem>
<para>Notifiers of changes that affect the entire topological structure of the arrangement. This category consists of two pairs (<emphasis>before</emphasis> and <emphasis>after</emphasis>) that notify the observer of the following changes:</para>
<para><itemizedlist>
<listitem>
<para>The arrangement is cleared. </para>
</listitem>
<listitem>
<para>The arrangement is assigned with the contents of another arrangement. </para>
</listitem>
</itemizedlist>
</para>
<para></para>
</listitem>
<listitem>
<para>Pairs of notifiers before and after a local change that occurs in the topological structure. Most notifier functions belong to this category. The relevant local changes include:</para>
<para><itemizedlist>
<listitem>
<para>A new vertex is constructed and associated with a point.</para>
<para></para>
</listitem>
<listitem>
<para>An edgeThe term &quot;edge&quot; refers here to a pair of twin halfedges. is constructed and associated with an <formula id="7">$x$</formula>-monotone curve.</para>
<para></para>
</listitem>
<listitem>
<para>An edge is split into two edges.</para>
<para></para>
</listitem>
<listitem>
<para>An existing face is split into two faces, as a consequence of the insertion of a new edge.</para>
<para></para>
</listitem>
<listitem>
<para>A hole is created in the interior of a face.</para>
<para></para>
</listitem>
<listitem>
<para>Two holes are merged to form a single hole, as a consequence of the insertion of a new edge.</para>
<para></para>
</listitem>
<listitem>
<para>A hole is moved from one face to another, as a consequence of a face split.</para>
<para></para>
</listitem>
<listitem>
<para>Two edges are merged into one edge.</para>
<para></para>
</listitem>
<listitem>
<para>Two faces are merged into one face, as a consequence of the removal of an edge that used to separate them.</para>
<para></para>
</listitem>
<listitem>
<para>One hole is split into two, as a consequence of the deletion of an edge that used to connect the two components.</para>
<para></para>
</listitem>
<listitem>
<para>A vertex is removed. </para>
</listitem>
<listitem>
<para>An edge is removed. </para>
</listitem>
<listitem>
<para>A hole is deleted from the interior of a face.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para></para>
</listitem>
<listitem>
<para>Notifiers about a change caused by a free function; see Section <ref refid="index_1arr_secgl_funcs" kindref="member">Free Functions</ref> for a discussion on the free functions. This category consists of a single pair of notifiers, namely <computeroutput>before_global_change()</computeroutput> and <computeroutput>after_global_change()</computeroutput>. Neither of these functions is invoked by methods of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template. Instead, they are called by the free functions themselves. It is implied that no point-location queries (or any other queries for that matter) are issued between the call to <computeroutput>before_global_change()</computeroutput> and the call to <computeroutput>after_global_change()</computeroutput>.</para>
<para></para>
</listitem>
</orderedlist>
</para>
<para>See the Reference Manual for a detailed specification of the <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref></computeroutput> class template and the prototypes of all notification functions.</para>
<para>Each arrangement object stores a list of pointers to <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref></computeroutput> objects. This list may be empty, in which case the arrangement does not have to notify any external class on the structural changes it undergoes. If, however, there are observers associated with the arrangement object, then whenever one of the structural changes listed in the first two categories above is about to take place, the arrangement object performs a <emphasis>forward</emphasis> traversal on this list and invokes the appropriate function of each observer. After the change takes place the observer list is traversed <emphasis>backward</emphasis> (from tail to head), and the appropriate notification function is invoked for each observer.</para>
<para>Concrete arrangement-observer classes should inherit from <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref></computeroutput>. When an observer is constructed, it is attached to a valid arrangement supplied to the observed constructor, or alternatively the observer can be attached to the arrangement at a later time. When this happens, the observer object inserts itself into the observer list of the associated arrangement and starts receiving notifications whenever this arrangement changes thereafter. Subsequently, the observer object unregisters itself by removing itself from this list just before it is destroyed. Most concrete observer-classes do not need to use the full set of notifications. Thus, the bodies of all notification methods defined in the base class <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref></computeroutput> are empty. A concrete observer that inherits from <computeroutput><ref refid="classCGAL_1_1Aos__observer" kindref="compound">Aos_observer</ref></computeroutput> needs to override only the relevant notification methods. The remaining methods are invoked when corresponding changes occur, but they do nothing.</para>
<para>The trapezoidal map RIC and the landmark point-location strategies both use observers to keep their auxiliary data structures up-to-date. In addition, you can define your own observer classes, inheriting from the base observer class and overriding the relevant notification functions, as required by their applications.</para>
<para><anchor id="index_1fig__aos_fig-observer"/> <image type="html" name="observer.png"></image>
 <image type="latex" name="observer.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-observer" kindref="member">fig__aos_fig-observer</ref> An arrangement of six line segments, as constructed in <ref refid="Arrangement_on_surface_2_2observer_8cpp-example" kindref="compound">Arrangement_on_surface_2/observer.cpp</ref>. The halfedge <formula id="378">$e_v$</formula> (dashed) is eventually removed, so that the final arrangement consists of four faces (one unbounded and three bounded ones). <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example shows how to define and use an observer class. The observer in the example responds to changes in the arrangement faces. It prints a message whenever a face is split into two due to the insertion of an edge and whenever two faces merge into one due to the removal of an edge. The layout of the arrangement is depicted in <ref refid="index_1fig__aos_fig-observer" kindref="member">fig__aos_fig-observer</ref>; it comprises six line segments and eight edges (the horizontal segment <formula id="379">$s_h$</formula> and the vertical segment <formula id="380">$s_v$</formula> induce two edges each). The halfedge <formula id="378">$e_v$</formula> is induced by the vertical segment <formula id="380">$s_v$</formula>. First, it is associated with the (entire) segment, as obtained by the <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> function; see Line 40 in the code excerpt below. After the insertion of <formula id="379">$s_h$</formula> (see Line 41) the halfedge is split. After the split <formula id="378">$e_v$</formula> (drawn dashed in the figure) is associated with the lower split curve. Eventually, it is removed (along with its twin halfedge). Note the face-split notifications that are invoked as a consequence of the insertion of <formula id="380">$s_v$</formula> and <formula id="379">$s_h$</formula> and the face-merge notification that is invoked as a consequent of the removal of <formula id="378">$e_v$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2observer_8cpp-example" kindref="compound">Arrangement_on_surface_2/observer.cpp</ref> <programlisting filename="Arrangement_on_surface_2/observer.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>a<sp/>simple<sp/>arrangement<sp/>observer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_observer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>observer<sp/>that<sp/>receives<sp/>notifications<sp/>of<sp/>face<sp/>splits<sp/>and<sp/>face<sp/>mergers.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_observer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="group__PkgArrangementOnSurface2Ref_1ga8019f986f5469920136c4b92290b7b1b" kindref="member">CGAL::Arr_observer</ref>&lt;Arrangement&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_observer(Arrangement&amp;<sp/>arr)<sp/>:<sp/><ref refid="namespaceCGAL" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL</ref>::<ref refid="group__PkgArrangementOnSurface2Ref_1ga8019f986f5469920136c4b92290b7b1b" kindref="member">Arr_observer</ref>&lt;Arrangement&gt;(arr)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>before_split_face(Face_handle,<sp/>Halfedge_handle<sp/>e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-&gt;<sp/>The<sp/>insertion<sp/>of<sp/>:<sp/><sp/>[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]<sp/><sp/>causes<sp/>a<sp/>face<sp/>to<sp/>split.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>before_merge_face(Face_handle,<sp/>Face_handle,<sp/>Halfedge_handle<sp/>e)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-&gt;<sp/>The<sp/>removal<sp/>of<sp/>:<sp/><sp/>[<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>e-&gt;curve()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>]<sp/><sp/>causes<sp/>two<sp/>faces<sp/>to<sp/>merge.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>one<sp/>diamond-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_observer<sp/>obs(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(-1,<sp/>0),<sp/>Point(0,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(0,<sp/>1),<sp/>Point(1,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(1,<sp/>0),<sp/>Point(0,<sp/>-1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(0,<sp/>-1),<sp/>Point(-1,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>a<sp/>vertical<sp/>segment<sp/>dividing<sp/>the<sp/>diamond<sp/>into<sp/>two,<sp/>and<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>horizontal<sp/>segment<sp/>further<sp/>dividing<sp/>the<sp/>diamond<sp/>into<sp/>four.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s_v(Point(0,<sp/>-1),<sp/>Point(0,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Halfedge_handle<sp/>e_v<sp/>=<sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s_v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(-1,<sp/>0),<sp/>Point(1,<sp/>0)));<sp/></highlight><highlight class="comment">/*<sp/>\label{lst:observer:insertion}<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>remove<sp/>a<sp/>portion<sp/>of<sp/>the<sp/>vertical<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" kindref="member">remove_edge</ref>(arr,<sp/>e_v);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>observer<sp/>will<sp/>make<sp/>a<sp/>notification</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Observers are especially useful when the DCEL records are extended and store additional data-fields, since they help update this data stored in these fields, as the following sections reveal.</para>
</sect2>
<sect2 id="index_1arr_ssecex_dcel">
<title>Extending the DCEL</title>
<para>For many applications of the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package it is necessary to store additional information (perhaps of non-geometric nature) with the arrangement features. Vertices are associated with <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aed833c3b69b94eae54994439d70a83a2" kindref="member"><computeroutput>Point_2</computeroutput></ref> objects and edges (halfedge pairs) are associated with <ref refid="classCGAL_1_1Arrangement__on__surface__2_1ad7f12c4c83fa1d83a3f0d5ceb16c21e1" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> objects, both defined by the traits class. Extending the geometric traits-class types by using a traits-class decorator, as explained in Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>, might be a sufficient solution for some applications. However, the DCEL faces are not associated with any geometric object, so traits-class decorators cannot help here. Extending the DCEL face records comes in handy is such cases. As a matter of fact, it is possible to conveniently extend all DCEL records (namely vertices, halfedges, and faces), which is advantageous for some applications.</para>
<para>All examples presented so far use the default DCEL; namely, they employ the <computeroutput>Arr_default_dcel&lt;Traits&gt;</computeroutput> instance. This is done implicitly, as this instance of the <computeroutput>Arr_default_dcel</computeroutput> class template serves as the default parameter for the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template; see Section <ref refid="index_1aos_ssec-basic-arr_class" kindref="member">The Arrangement Class Template</ref>. The default DCEL class associates points with vertices and <formula id="7">$x$</formula>-monotone curves with halfedges, but nothing more. In this section we show how to use alternative DCEL types to extend the desired DCEL records.</para>
<sect3 id="index_1arr_sssecex_dcel_face">
<title>Extending the DCEL Faces</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref>&lt;Traits, FaceData&gt;</computeroutput> class-template is used to associate auxiliary data field of type <computeroutput>FaceData</computeroutput> to each face record in the DCEL. When the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template is instantiated, substituting the DCEL parameter with an instance of this class template, the interface of the nested <computeroutput>Face</computeroutput> type is extended with the access function <computeroutput>data()</computeroutput> and with the modifier <computeroutput>set_data()</computeroutput>. Using these extra functions it is straightforward to access and maintain the auxiliary face-data field.</para>
<para>Note that the extra data-fields must be maintained by the user application. User may choose to construct their arrangement, and may only then go over the faces and store data in the appropriate data-fields of the arrangement faces. However, in some cases the face data can only be computed when the face is created (split from another face or merged with another face). In such cases one can use an arrangement observer tailored for this task, which receives updates whenever a face is modified and sets its data field accordingly.</para>
<para><anchor id="index_1fig__aos_fig-dcel_extension"/> <image type="html" name="dcel_extension.png"></image>
 <image type="latex" name="dcel_extension.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-dcel_extension" kindref="member">fig__aos_fig-dcel_extension</ref> An arrangement of six line segments, as constructed in <ref refid="Arrangement_on_surface_2_2face_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension.cpp</ref> and <ref refid="Arrangement_on_surface_2_2dcel_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension.cpp</ref> (in <ref refid="Arrangement_on_surface_2_2dcel_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension.cpp</ref> we treat the segments as directed, so they are drawn as arrows directed from the source to the target). The indices associated with the halfedges in <ref refid="Arrangement_on_surface_2_2face_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension.cpp</ref> are shown in brackets. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The next example constructs an arrangement that contains seven bounded faces induced by six line segments, <formula id="381">$s_1, \ldots, s_6$</formula>, as shown in <ref refid="index_1fig__aos_fig-dcel_extension" kindref="member">fig__aos_fig-dcel_extension</ref>. An observer gets notified each time a new face <formula id="46">$f$</formula> is created, and it associates <formula id="46">$f$</formula> with a running index, where the index of the unbounded face is 0. As a result, the faces are numbered according to their creation order, These numbers are shown in brackets, and their order can easily be verified by examining the insertion order of the segments.For simplicity, the particular observer used must be attached to an empty arrangement. It is not difficult however to modify the program to handle the general case of attaching a similar observer to a non-empty arrangement.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2face_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension.cpp</ref> <programlisting filename="Arrangement_on_surface_2/face_extension.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Extending<sp/>the<sp/>arrangement-face<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_observer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, size_t&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>arrangement<sp/>observer,<sp/>used<sp/>to<sp/>receive<sp/>notifications<sp/>of<sp/>face<sp/>splits<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>to<sp/>update<sp/>the<sp/>indices<sp/>of<sp/>the<sp/>newly<sp/>created<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Face_index_observer<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="group__PkgArrangementOnSurface2Ref_1ga8019f986f5469920136c4b92290b7b1b" kindref="member">CGAL::Arr_observer</ref>&lt;Ex_arrangement&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n_faces;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>current<sp/>number<sp/>of<sp/>faces</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_observer(Ex_arrangement&amp;<sp/>arr)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL</ref>::<ref refid="group__PkgArrangementOnSurface2Ref_1ga8019f986f5469920136c4b92290b7b1b" kindref="member">Arr_observer</ref>&lt;Ex_arrangement&gt;(arr),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>n_faces(0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL_precondition(arr.is_empty());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>arr.unbounded_face()-&gt;set_data<sp/>(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>after_split_face(Face_handle,<sp/>Face_handle<sp/>new_face,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>new_face-&gt;set_data(++n_faces);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assign<sp/>index<sp/>to<sp/>the<sp/>new<sp/>face</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_observer<sp/>obs(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(7,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(1,<sp/>6),<sp/>Point(7,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(1,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(1,<sp/>3),<sp/>Point(7,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(1,<sp/>3),<sp/>Point(4,<sp/>8)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(4,<sp/>8),<sp/>Point(7,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces<sp/>and<sp/>print<sp/>the<sp/>index<sp/>of<sp/>each<sp/>face<sp/>and<sp/>its</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>outer<sp/>boundary.<sp/>The<sp/>face<sp/>index<sp/>is<sp/>stored<sp/>in<sp/>the<sp/>data<sp/>field.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>faces:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Face<sp/>no.<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit-&gt;is_unbounded())<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Unbounded.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--&gt;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;target()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1arr_sssecex_dcel_all">
<title>Extending All DCEL Records</title>
<para>As you continue to use arrangements to solve various problems you will find out that the ability to extend the face records is crucial. Perhaps less common, but also important to satisfy, is the need to extend the vertex and halfedge records as well. The <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</computeroutput> class-template is used to associate auxiliary data fields of types <computeroutput>VertexData</computeroutput>, <computeroutput>HalfedgeData</computeroutput>, and <computeroutput>FaceData</computeroutput> with DCEL vertex, halfedge, and face record types, respectively. When the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template is instantiated, substituting the <computeroutput>Dcel</computeroutput> parameter with an instance of this DCEL class-template, the interfaces of the nested types Vertex, Halfedge, and Face are extended with the access function <computeroutput>data()</computeroutput> and with the modifier <computeroutput>set_data()</computeroutput>.</para>
<para>The next example shows how to use a DCEL with extended vertex, halfedge, and face records. In this example each vertex is associated with a color, which is either blue, red, or white, depending on whether the vertex is isolated, represents a segment endpoint, or represents an intersection point. (Notice that the coloring rules suggested here apply only to non-degenerate arrangements, where the sets of isolated points, curve endpoints, and intersection points are mutually exclusive.) In this example segments are treated as directed objects. Each halfedge is associated with Boolean flag indicating whether its direction is the same as the direction of its associated segment. Each face is also extended to store the size of its outer boundary, that is, the number of halfedges along its outer boundary.</para>
<para>The constructed arrangement, depicted in <ref refid="index_1fig__aos_fig-dcel_extension" kindref="member">fig__aos_fig-dcel_extension</ref>, is similar to the arrangement constructed in the previous example. In this case, however, we do not use an observer; instead, all auxiliary data-fields are set after the construction phase. Also note that the data fields are properly maintained when the arrangement is copied to another arrangement object.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dcel_extension_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension.cpp</ref> <programlisting filename="Arrangement_on_surface_2/dcel_extension.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Extending<sp/>all<sp/>DCEL<sp/>records<sp/>(vertices,<sp/>edges<sp/>and<sp/>faces).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Color<sp/>{BLUE,<sp/>RED,<sp/>WHITE};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">CGAL::Arr_extended_dcel&lt;Traits, Color, bool, size_t&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(7,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(1,<sp/>6),<sp/>Point(7,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(1,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(1,<sp/>3),<sp/>Point(7,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(1,<sp/>3),<sp/>Point(4,<sp/>8)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(4,<sp/>8),<sp/>Point(7,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gabfaca749e7d8c9547c143032a0e9df08" kindref="member">insert_point</ref>(arr,<sp/>Point(4,<sp/>4.5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>edges<sp/>and<sp/>set<sp/>their<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Recall<sp/>that<sp/>the<sp/>value<sp/>type<sp/>of<sp/>the<sp/>edge<sp/>iterator<sp/>is<sp/>the<sp/>halfedge<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>degree<sp/>=<sp/>vit-&gt;degree();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vit-&gt;set_data((degree<sp/>==<sp/>0)<sp/>?<sp/>BLUE<sp/>:<sp/>((degree<sp/>&lt;=<sp/>2)<sp/>?<sp/>RED<sp/>:<sp/>WHITE));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>equal<sp/>=<sp/>traits.equal_2_object();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>whether<sp/>the<sp/>halfedge<sp/>has<sp/>the<sp/>same<sp/>direction<sp/>as<sp/>its<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>flag<sp/>=<sp/>equal(eit-&gt;source()-&gt;point(),eit-&gt;curve().source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;set_data(flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;twin()-&gt;set_data(!flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Store<sp/>the<sp/>size<sp/>of<sp/>the<sp/>outer<sp/>boundary<sp/>of<sp/>every<sp/>face<sp/>of<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>boundary_size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;is_unbounded())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Ex_arrangement::Ccb_halfedge_circulator<sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boundary_size<sp/>=<sp/>std::distance(++curr,<sp/>fit-&gt;outer_ccb())+1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(boundary_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Copy<sp/>the<sp/>arrangement<sp/>and<sp/>print<sp/>the<sp/>vertices<sp/>along<sp/>with<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr2<sp/>=<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>vertices:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr2.vertices_begin();<sp/>vit<sp/>!=<sp/>arr2.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>-<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(vit-&gt;data())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>BLUE<sp/><sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;BLUE.\n&quot;</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>RED<sp/><sp/><sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;RED.\n&quot;</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>WHITE<sp/>:<sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;WHITE.\n&quot;</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>outer-boundary<sp/>sizes:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>The various DCEL classes presented in this section are well suited for most applications based on the <ref refid="packages_1PkgArrangementOnSurface2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Arrangements</ref> package. They are all defined using helper constructs, and in particular the base DCEL class-template <computeroutput><ref refid="classCGAL_1_1Arr__dcel__base" kindref="compound">Arr_dcel_base</ref>}</computeroutput>. However, there are cases where special requirements, not addressed by these DCEL classes, are needed. In such cases you may explicitly extend the base DCEL class-template, as described in the next paragraph, or implement your own DCEL class from scratch and use the resulting DCEL to instantiate the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template. In any case such a class must model the concept <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> or its refinement <computeroutput><ref refid="classArrangementDcelWithRebind" kindref="compound">ArrangementDcelWithRebind</ref></computeroutput>. The latter requires a <computeroutput>rebind</computeroutput> struct template, which implements a policy-clone idiom. Here, the DCEL class is the policy class and the <computeroutput>rebind</computeroutput> member template struct is used to pass a different traits type parameter to the policy class template.</para>
<para>In some cases you may want to extend a certain feature type with several fields. You can gather all these fields (and perhaps methods that access and retrieve these fields) in a single construct, and substitute the appropriate parameter of the class template <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</computeroutput> with this construct. Naturally, you can define three constructs, one for each feature type, and substitute all the three corresponding template parameters appropriately. For example, consider an arrangement that represents a map where features of the same type represent different cartographic entities, e.g., an edge represents a road, a river, or a railway. We would like to associate two strings with each feature, namely, the name and the type of the feature. Following the solution above, accessing or retrieving a specific field will always require an indirection through one of the member functions <computeroutput>set_data()</computeroutput> and <computeroutput>data()</computeroutput>. While this indirection is typically resolved at compile time, and thus has no negative effect on the running time of the generated code, it may have some implication on the space consumption due to compiler padding.Compilers add pad bytes into user-defined constructs to comply with alignment restrictions imposed by target microprocessors. Moreover, the code may look cumbersome.</para>
<para>The extended DCEL class that addresses the problem raised above is listed below. Here, each feature type is explicitly extended with two strings, namely, <computeroutput>name</computeroutput> and <computeroutput>type</computeroutput>, eliminating the data constructs.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_dcel_base.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>map-extended<sp/>dcel<sp/>vertex.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Po</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">_2&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Arr_map_vertex<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CGAL::Arr_vertex_base&lt;Point_2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>name,<sp/>type;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>map-extended<sp/>dcel<sp/>halfedge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>X_monotone_curve_2&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Arr_map_halfedge<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CGAL::Arr_halfedge_base&lt;X_monotone_curve_2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>name,<sp/>type;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>map-extended<sp/>dcel<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Arr_map_face<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>CGAL::Arr_face_base<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>name,<sp/>type;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>map-extended<sp/>dcel.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Arr_map_dcel<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arr__dcel__base" kindref="compound">CGAL::Arr_dcel_base</ref>&lt;Arr_map_vertex&lt;typename<sp/>Traits::Point_2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arr_map_halfedge&lt;typename<sp/>Traits::X_monotone_curve_2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arr_map_face&gt;</highlight></codeline>
<codeline><highlight class="normal">{};</highlight></codeline>
</programlisting></para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect3>
</sect2>
<sect2 id="index_1arr_ssecoverlay">
<title>Overlaying Arrangements</title>
<para>Assume that we are given two geographic maps represented as arrangements, with some data objects attached to their faces, representing some geographic information<mdash/>for instance, a map of the annual precipitation in some country and a map of the vegetation in the same country<mdash/>and you are asked to locate, for example, places where there is a pine forest <emphasis>and</emphasis> the annual precipitation is between 1,000mm and 1,500mm. Overlaying the two maps may help you figure out the answer. Computing the overlay of two two-dimensional arrangements is also useful for supporting Boolean set operations on polygons or general polygons; see e.g., <ref refid="citelist_1CITEREF_cgal:behhms-cbcab-02" kindref="member">[2]</ref>).</para>
<para>Formally, the <emphasis>map overlay</emphasis> of two two-dimensional subdivisions <formula id="91">$\mathcal{S}_1$</formula> and <formula id="92">$\mathcal{S}_2$</formula> is a two-dimensional subdivision <formula id="382">$\mathcal{S}$</formula>, such that there is a face <formula id="46">$f$</formula> in <formula id="382">$\mathcal{S}$</formula> iff there are faces <formula id="2">$f_1$</formula> and <formula id="3">$f_2$</formula> in <formula id="91">$\mathcal{S}_1$</formula> and <formula id="92">$\mathcal{S}_2$</formula>, respectively, such that <formula id="46">$f$</formula> is a maximal connected component of <formula id="383">$f_1 \cap f_2$</formula>.</para>
<para>The overlay of two given arrangements, conveniently referred to as the &quot;blue&quot; and the &quot;red&quot; arrangements, is implemented as a plane-sweep algorithm employing a dedicated visitor; see Section <ref refid="index_1arr_ssec_sweep" kindref="member">The Surface-Sweep Algorithm</ref>. The <formula id="7">$x$</formula>-monotone curve type is extended with a color attribute (whose value is either blue or red); see Section <ref refid="index_1arr_ssecmeta_tr" kindref="member">Traits-Class Decorators</ref>. With the help of the extended type unnecessary computations are filtered out while the plane is swept, yielding an efficient process. For example, monochromatic intersections are not computed.</para>
<para>The plane-sweep visitor that concretizes the overlay operation needs to construct a DCEL that properly represents the overlay of two input arrangements. A face in the overlay arrangement corresponds to overlapping regions of the blue and red faces. An edge in the overlay arrangement is due to a blue edge, a red edge, or an overlap of two differently colored edges. An overlay vertex is due to a blue vertex, a red vertex, a coincidence of two differently colored vertices, or an intersection of a blue and a red curve.</para>
<para>The call <ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member"><computeroutput>overlay(arr_r, arr_b, arr_o,
ovl_traits)</computeroutput></ref> constructs the arrangement <computeroutput>arr_o</computeroutput>, which is the overlay of two input arrangement <computeroutput>arr_r</computeroutput> and <computeroutput>arr_b</computeroutput>. All three arrangements must use the same geometric primitives. In other words, their types are instances of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Traits</computeroutput> parameter is substituted by three geometry-traits classes, respectively. The geometry-traits classes of the input arrangements must be convertible to the geometry-traits class of the resulting arrangement.It is sufficient that all three geometry-traits classes used to instantiate the three types of arrangements derive from a common ancestor that models the geometry-traits concept. Typically, all three arrangements use the same geometry-traits class.</para>
<para>The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> function template is suitable for arrangements that do not store any additional data with their DCEL records; namely, arrangements defined using the default DCEL, which is the instance <computeroutput>Arr_default_dcel&lt;Traits&gt;</computeroutput>. Typically, the overlay arrangement in this case does not store extra data with its DCEL records as well. (If it does, the additional data-fields cannot be computed by the overlay operation in this case.) The overlay arrangement is equivalent to the arrangement induced by all curves of <computeroutput>arr_r</computeroutput> and <computeroutput>arr_b</computeroutput>. Indeed, it is possible to obtain the same result using the standard insertion-operations instead, but, as mentioned above, this is less efficient.</para>
<para><anchor id="index_1fig__aos_figex_overlay"/> <image type="html" name="overlay.png"></image>
 <image type="latex" name="overlay.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_figex_overlay" kindref="member">fig__aos_figex_overlay</ref> Overlaying two simple arrangements of line segments, as done in <ref refid="Arrangement_on_surface_2_2overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay.cpp</ref> and <ref refid="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension_overlay.cpp</ref>. In <ref refid="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension_overlay.cpp</ref> the two bounded faces are considered as <emphasis>marked</emphasis>, and the octagonal face which is the intersection of the two marked faces is denoted by <formula id="98">$f_0$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The next program constructs two simple arrangements; each comprises four line segments that form a square, as depicted in <ref refid="index_1fig__aos_figex_overlay" kindref="member">fig__aos_figex_overlay</ref>. The program computes the overlay of the two arrangements. The resulting arrangement has 16 vertices, 24 edges, and 10 faces (including the unbounded one.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay.cpp</ref> <programlisting filename="Arrangement_on_surface_2/overlay.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>simple<sp/>overlay<sp/>of<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>containing<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(2,<sp/>2),<sp/>Point(6,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(6,<sp/>2),<sp/>Point(6,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(6,<sp/>6),<sp/>Point(2,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(2,<sp/>6),<sp/>Point(2,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>rhombus-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(7,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(7,<sp/>4),<sp/>Point(4,<sp/>7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(4,<sp/>7),<sp/>Point(1,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(1,<sp/>4),<sp/>Point(4,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">CGAL::overlay</ref>(arr1,<sp/>arr2,<sp/>overlay_arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(overlay_arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> function template is overloaded with a variant that accepts four arguments, that is, <computeroutput>overlay(arr_r, arr_b, arr_o,
ovl_traits)</computeroutput>. The type of the <computeroutput>ovl_traits</computeroutput> additional argument, referred to as the overlay traits, must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept described below. Assume that <computeroutput>arr_r</computeroutput> is of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel_R&gt;</computeroutput>, <computeroutput>arr_b</computeroutput> is of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel_B&gt;</computeroutput>, and the resulting <computeroutput>arr_o</computeroutput> is of type <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel_O&gt;</computeroutput>. The overlay traits enables the creation of <computeroutput>Dcel_O</computeroutput> records in the overlay arrangement from the features of <computeroutput>Dcel_R</computeroutput> and <computeroutput>Dcel_B</computeroutput> records from the arrangements <computeroutput>arr_r</computeroutput> and <computeroutput>arr_b</computeroutput>, respectively.</para>
<para>We distinguish between (i) an overlay of two arrangements that store additional data-fields only with their faces e.g., the geographic-map example given at the beginning of this section) and (ii) an overlay of two arrangements that store additional data fields with all their DCEL records (or at least not only with their faces). The arrangement that results from overlaying two face-extended arrangements typically also stores additional data-fields with its faces. The types of such arrangements, for example, could be instances of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Dcel</computeroutput> parameters are substituted by instances of the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref></computeroutput> class template (see Section <ref refid="index_1arr_sssecex_dcel_face" kindref="member">Extending the DCEL Faces</ref>). The data field that is attached to an overlay face can be computed from the data fields of the two faces (in <computeroutput>arr_r</computeroutput> and <computeroutput>arr_b</computeroutput>) that induce the overlay face. Similarly, the arrangement that results from overlaying two arrangements that store additional data fields with all their DCEL records typically also stores additional data-fields with all its DCEL records. The types of such arrangements, for example, could be instances of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the <computeroutput>Dcel</computeroutput> parameters are substituted by instances of the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref></computeroutput> class template (see Section <ref refid="index_1arr_sssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>). The data field attached to an overlay feature can be computed from the data fields of the two features (in <computeroutput>arr_r</computeroutput> and <computeroutput>arr_b</computeroutput>) that induce the overlay feature.</para>
<para>As mentioned in the previous paragraph, if any of the DCEL records of your arrangements are extended, you can pass a fourth argument to the <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> call, also referred to as the overlay traits, to control the generation of the extended data in the resulting arrangement. If only the face records are extended, the type of the overlay traits can be an instance of the class template <computeroutput><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">Arr_face_overlay_traits</ref>&lt;ArrangementR,ArrangementB,ArrangementO,OverlayFaceData&gt;</computeroutput>, which models the concept <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput>. An object of this type operates on face-extended arrangements. When instantiated, the <computeroutput>OverlayFaceData</computeroutput> parameter must be substituted by a functor that is capable of combining two face-data fields of types <computeroutput>ArrangementR::Dcel::Face_data</computeroutput> and <computeroutput>ArrangementB::Dcel::Face_data</computeroutput> and computing the output <computeroutput>ArrangementO::Dcel::Face_data</computeroutput> object. The face-overlay traits-class uses this functor to properly construct the overlay faces.</para>
<para>The following example shows how to compute the intersection of two polygons using the <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> function template. It uses a face-extended DCEL type to instantiate the arrangement classes. Each face of the the DCEL is extended with a Boolean flag. A polygon is represented as a <emphasis>marked</emphasis> arrangement face (whose flag is set). The example uses an instance of the <computeroutput><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">Arr_face_overlay_traits</ref>&lt;ArrR,ArrB,ArrO,OverlayFaceData&gt;</computeroutput> class template as the face-overlay traits class where the <computeroutput>OverlayFaceData</computeroutput> template parameter is substituted by a functor that simply performs a logical <emphasis>and</emphasis> operation on Boolean flags. As a result, a face in the overlay arrangement is marked only when it corresponds to an overlapping region of two marked faces in the input arrangements. Namely, it is part of the intersection of the two polygons. The example computes the intersection between a parallel-axis square and a congruent square rotated <formula id="384">$45^\circ$</formula>. The resulting polygon from the intersection operation is an octagon, which corresponds to the face~ <formula id="385">$\hat{f}$</formula> in the arrangement depicted in <ref refid="index_1fig__aos_figex_overlay" kindref="member">fig__aos_figex_overlay</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example" kindref="compound">Arrangement_on_surface_2/face_extension_overlay.cpp</ref> <programlisting filename="Arrangement_on_surface_2/face_extension_overlay.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>face<sp/>overlay<sp/>of<sp/>two<sp/>arrangements<sp/>with<sp/>extended<sp/>face<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, bool&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Overlay_traits<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">CGAL::Arr_face_overlay_traits</ref>&lt;Ex_arrangement,<sp/>Ex_arrangement,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ex_arrangement,<sp/>std::logical_and&lt;bool&gt;&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>containing<sp/>a<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(2,<sp/>2),<sp/>Point(6,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(6,<sp/>2),<sp/>Point(6,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(6,<sp/>6),<sp/>Point(2,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(2,<sp/>6),<sp/>Point(2,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>2<sp/>because<sp/>the<sp/>bounded<sp/>and<sp/>the<sp/>unbounded<sp/>one</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(arr1.number_of_faces()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Mark<sp/>just<sp/>the<sp/>bounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr1.faces_begin();<sp/>fit<sp/>!=<sp/>arr1.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(fit<sp/>!=<sp/>arr1.unbounded_face());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>rhombus-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(4,<sp/>1),<sp/>Point(7,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(7,<sp/>4),<sp/>Point(4,<sp/>7)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(4,<sp/>7),<sp/>Point(1,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(1,<sp/>4),<sp/>Point(4,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(fit<sp/>!=<sp/>arr2.unbounded_face());<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>mark<sp/>the<sp/>bounded<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements,<sp/>marking<sp/>only<sp/>the<sp/>faces<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>are<sp/>intersections<sp/>of<sp/>two<sp/>marked<sp/>faces<sp/>in<sp/>arr1<sp/>and<sp/>arr2,<sp/>respectively.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_traits<sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">CGAL::overlay</ref>(arr1,<sp/>arr2,<sp/>overlay_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>faces<sp/>of<sp/>the<sp/>resulting<sp/>arrangement<sp/>and<sp/>print<sp/>the<sp/>marked<sp/>ones.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>intersection<sp/>is:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>overlay_arr.faces_begin();<sp/>fit<sp/>!=<sp/>overlay_arr.faces_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;data())<sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Ex_arrangement::Ccb_halfedge_circulator<sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>curr-&gt;source()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>--&gt;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>curr-&gt;target()-&gt;point();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_figex_overlay_unbounded"/> <image type="html" name="overlay_unbounded.png"></image>
 <image type="latex" name="overlay_unbounded.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_figex_overlay_unbounded" kindref="member">fig__aos_figex_overlay_unbounded</ref> Overlaying two arrangements of lines that have unbounded faces, as done in <ref refid="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay_unbounded.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The next example, depicted in <ref refid="index_1fig__aos_figex_overlay_unbounded" kindref="member">fig__aos_figex_overlay_unbounded</ref>, demonstrates the face overlay of two arrangements that have unbounded faces as well as bounded ones. The first arrangement (blue) is induced by the two lines <formula id="386">$y = x$</formula> and <formula id="387">$y = -x$</formula>, which subdivide the plane into four unbounded faces, labeled <formula id="373">$A$</formula>, <formula id="330">$B$</formula>, <formula id="85">$C$</formula> and <formula id="374">$D$</formula>. The second arrangement (red) comprises four line segments that form a square-shaped face indexed <formula id="269">$1$</formula>. The unbounded face is indexed 2. When the two arrangements are overlaid, each of the four faces <formula id="373">$A$</formula>, <formula id="330">$B$</formula>, <formula id="85">$C$</formula> and <formula id="374">$D$</formula> is split into an unbounded face (indexed 2) and a bounded face (indexed 1), so the faces of the resulting arrangement are labeled <formula id="388">$A_1, A_2, \ldots, D_1,
D_2$</formula>. <computeroutput>boost::lexical_cast</computeroutput> is used to cast the integral indices into strings to produce the final labels.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay_unbounded.cpp</ref> <programlisting filename="Arrangement_on_surface_2/overlay_unbounded.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>face<sp/>overlay<sp/>of<sp/>two<sp/>arrangements<sp/>with<sp/>unbounded<sp/>faces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_linear.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>functor<sp/>for<sp/>creating<sp/>a<sp/>label<sp/>from<sp/>a<sp/>character<sp/>and<sp/>an<sp/>integer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Overlay_label<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>operator()(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>c<sp/>+<sp/>std::to_string(i);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel_dlue<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, char&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement_blue<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel_dlue&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel_red<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, unsigned int&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement_red<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel_red&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel_res<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, std::string&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arrangement_res<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel_res&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Overlay_traits<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Arr__face__overlay__traits" kindref="compound">CGAL::Arr_face_overlay_traits</ref>&lt;Arrangement_blue,<sp/>Arrangement_red,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Arrangement_res,<sp/>Overlay_label&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement,<sp/>induced<sp/>by<sp/>two<sp/>lines<sp/>y<sp/>=<sp/>x<sp/>and<sp/>y<sp/>=<sp/>-x.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_blue<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>Line(Point(0,<sp/>0),<sp/>Point(1,<sp/>1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>Line(Point(0,<sp/>0),<sp/>Point(1,<sp/>-1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Label<sp/>the<sp/>four<sp/>(unbounded)<sp/>faces<sp/>of<sp/>the<sp/>arrangement<sp/>as<sp/>&apos;A&apos;<sp/>to<sp/>&apos;D&apos;<sp/>by</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>traversing<sp/>the<sp/>faces<sp/>incident<sp/>to<sp/>the<sp/>halfedges<sp/>around<sp/>the<sp/>single</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>arrangement<sp/>vertex<sp/>(0,<sp/>0).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>clabel<sp/>=<sp/></highlight><highlight class="charliteral">&apos;A&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>first<sp/>=<sp/>arr1.vertices_begin()-&gt;incident_halfedges();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>curr<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>curr-&gt;face()-&gt;set_data(clabel++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement,<sp/>containing<sp/>a<sp/>single<sp/>square-shaped<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_red<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(-3,<sp/>-3),<sp/>Point(3,<sp/>-3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(3,<sp/>-3),<sp/>Point(3,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(3,<sp/>3),<sp/>Point(-3,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(-3,<sp/>3),<sp/>Point(-3,<sp/>-3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Give<sp/>the<sp/>unbounded<sp/>face<sp/>the<sp/>index<sp/>1,<sp/>and<sp/>the<sp/>bounded<sp/>face<sp/>the<sp/>index<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data((fit<sp/>==<sp/>arr2.unbounded_face())<sp/>?<sp/>1<sp/>:<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_res<sp/>overlay_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_traits<sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">CGAL::overlay</ref>(arr1,<sp/>arr2,<sp/>overlay_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>the<sp/>faces<sp/>of<sp/>the<sp/>overlay<sp/>arrangement<sp/>and<sp/>print<sp/>their<sp/>labels.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>overlay<sp/>faces<sp/>are:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>res_fit<sp/>=<sp/>overlay_arr.faces_begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_fit<sp/>!=<sp/>overlay_arr.faces_end();<sp/>++res_fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>res_fit-&gt;data().c_str()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>(res_fit-&gt;is_unbounded()<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;unbounded&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;bounded&quot;</highlight><highlight class="normal">)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;).\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If the red and blue arrangements store additional data-fields with all their DCEL records, and the data associated with the overlay DCEL features should be computed from the red and blue DCEL features that induce it, then an appropriate overlay-traits argument must be passed to the <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">overlay()</ref></computeroutput> call. The overlay-traits type models the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which requires the provision of ten functions that handle all possible cases as listed below. Let <formula id="389">$v_r$</formula>, <formula id="390">$e_r$</formula>, and <formula id="391">$f_r$</formula> denote input red features, i.e., a vertex, an edge, and a face, respectively, <formula id="392">$v_b$</formula>, <formula id="393">$e_b$</formula>, and <formula id="394">$f_b$</formula> denote input blue features, and <formula id="30">$v$</formula>, <formula id="31">$e$</formula>, and <formula id="46">$f$</formula> denote output features.</para>
<para><orderedlist>
<listitem>
<para>A new vertex <formula id="30">$v$</formula> is induced by coinciding vertices <formula id="389">$v_r$</formula> and <formula id="392">$v_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new vertex <formula id="30">$v$</formula> is induced by a vertex <formula id="389">$v_r$</formula> that lies on an edge <formula id="393">$e_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>An analogous case of a vertex <formula id="392">$v_b$</formula> that lies on an edge <formula id="390">$e_r$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new vertex <formula id="30">$v$</formula> is induced by a vertex <formula id="389">$v_r$</formula> that is contained in a face <formula id="394">$f_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>An analogous case of a vertex <formula id="392">$v_b$</formula> contained in a face <formula id="391">$f_r$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new vertex <formula id="30">$v$</formula> is induced by the intersection of two edges <formula id="390">$e_r$</formula> and <formula id="393">$e_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new edge <formula id="31">$e$</formula> is induced by the (possibly partial) overlap of two edges <formula id="390">$e_r$</formula> and <formula id="393">$e_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new edge <formula id="31">$e$</formula> is induced by the an edge <formula id="390">$e_r$</formula> that is contained in a face <formula id="394">$f_b$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>An analogous case of an edge <formula id="393">$e_b$</formula> contained in a face <formula id="391">$f_r$</formula>.</para>
<para></para>
</listitem>
<listitem>
<para>A new face <formula id="46">$f$</formula> is induced by the overlap of two faces <formula id="391">$f_r$</formula> and <formula id="394">$f_b$</formula>.</para>
<para></para>
</listitem>
</orderedlist>
</para>
<para>The <computeroutput>Overlay_color_traits</computeroutput> class template listed below models the concept <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput>. It assumes that each feature of the input arrangements and of the overlay arrangement is extended with an RGB color stored as an <computeroutput>unsigned int</computeroutput>. It defines ten member functions that correspond to the ten cases listed above. Each of these functions accepts three handles as follows: two handles to the two features of the input arrangements, respectively, that induce a feature of the overlay arrangement and a handle to the induced overlay-arrangement feature. Each of these member functions blends the colors attached to the inducing features and assigns the resulting color to the induced feature. The <computeroutput>Overlay_color_traits</computeroutput> class template is defined in the header file <computeroutput>Overlay_color_traits.h</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Overlay_color_traits<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Color;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Vertex_const_handle<sp/><sp/><sp/><sp/><sp/>V_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_const_handle<sp/><sp/><sp/>H_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_const_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>F_const_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Vertex_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>V_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>H_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>F_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>average<sp/>of<sp/>the<sp/>red,<sp/>green,<sp/>and<sp/>blue<sp/>components<sp/>separately.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Color<sp/>blend(Color<sp/>color1,<sp/>Color<sp/>color2)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((((color1<sp/>&amp;<sp/>0x000000ff)<sp/>+<sp/>(color2<sp/>&amp;<sp/>0x000000ff))<sp/>/<sp/>2)<sp/>&amp;<sp/>0x000000ff)<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((((color1<sp/>&amp;<sp/>0x0000ff00)<sp/>+<sp/>(color2<sp/>&amp;<sp/>0x0000ff00))<sp/>/<sp/>2)<sp/>&amp;<sp/>0x0000ff00)<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((((color1<sp/>&amp;<sp/>0x00ff0000)<sp/>+<sp/>(color2<sp/>&amp;<sp/>0x00ff0000))<sp/>/<sp/>2)<sp/>&amp;<sp/>0x00ff0000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_face(F_const_handle<sp/>f1,<sp/>F_const_handle<sp/>f2,<sp/>F_handle<sp/>f)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>f-&gt;set_data(blend(f1-&gt;data(),<sp/>f2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(H_const_handle<sp/>h1,<sp/>H_const_handle<sp/>h2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(h1-&gt;data(),<sp/>h2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(V_const_handle<sp/>v1,<sp/>V_const_handle<sp/>v2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(v1-&gt;data(),<sp/>v2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(V_const_handle<sp/>v1,<sp/>H_const_handle<sp/>h2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(v1-&gt;data(),<sp/>h2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(H_const_handle<sp/>h1,<sp/>V_const_handle<sp/>v2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(h1-&gt;data(),<sp/>v2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(F_const_handle<sp/>f1,<sp/>V_const_handle<sp/>v2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(f1-&gt;data(),<sp/>v2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_vertex(V_const_handle<sp/>v1,<sp/>F_const_handle<sp/>f2,<sp/>V_handle<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{<sp/>v-&gt;set_data(blend(v1-&gt;data(),<sp/>f2-&gt;data()));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_edge(H_const_handle<sp/>h1,<sp/>H_const_handle<sp/>h2,<sp/>H_handle<sp/>h)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;set_data(blend(h1-&gt;data(),<sp/>h2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;twin()-&gt;set_data(blend(h1-&gt;data(),<sp/>h2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_edge(H_const_handle<sp/>h1,<sp/>F_const_handle<sp/>f2,<sp/>H_handle<sp/>h)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;set_data(blend(h1-&gt;data(),<sp/>f2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;twin()-&gt;set_data(blend(h1-&gt;data(),<sp/>f2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_edge(F_const_handle<sp/>f1,<sp/>H_const_handle<sp/>h2,<sp/>H_handle<sp/>h)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;set_data(blend(f1-&gt;data(),<sp/>h2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>h-&gt;twin()-&gt;set_data(blend(f1-&gt;data(),<sp/>h2-&gt;data()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_figex_overlay_color"/> <image type="html" name="overlay_color.png"></image>
 <image type="latex" name="overlay_color.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_figex_overlay_color" kindref="member">fig__aos_figex_overlay_color</ref></para>
<para>The overlay of two extended arrangements]{The overlay (c) of two arrangements (a) and (b). Each feature of the arrangements is extended with a color. The color of each feature of the overlay arrangement is the blend of the colors of the two inducing features.</para>
<para><htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The example program listed below computes the overlay, depicted in <ref refid="index_1fig__aos_figex_overlay_color" kindref="member">fig__aos_figex_overlay_color</ref>, of the two arrangements depicted in (a) and (d). Each feature of the input arrangements and of the overlay arrangement is extended with an RGB color stored as an <computeroutput>unsigned int</computeroutput>. The vertices, halfedges, and faces of the red arrangement are assigned three different shades of red. Similarly, the vertices, halfedges, and faces of the blue arrangement are assigned three different shades of blue. Using an instance of the <computeroutput>Overlay_color_traits</computeroutput> class template as the overlay traits, each feature of the overlay arrangement is assigned a color that is a blend of the colors attached to the inducing features.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2overlay_color_8cpp-example" kindref="compound">Arrangement_on_surface_2/overlay_color.cpp</ref> <programlisting filename="Arrangement_on_surface_2/overlay_color.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>overlay<sp/>of<sp/>two<sp/>arrangement<sp/>with<sp/>extended<sp/>dcel<sp/>structures</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_overlay_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_default_overlay_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;Overlay_color_traits.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Color<sp/>=<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>int;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">CGAL::Arr_extended_dcel&lt;Traits, Color, Color, Color&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Color<sp/>vcol1(0x00000080),<sp/>hcol1(0x000000ff),<sp/>fcol1(0x00ccccff);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Color<sp/>vcol2(0x00800000),<sp/>hcol2(0x00ff0000),<sp/>fcol2(0x00ffcccc);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>first<sp/>arrangement<sp/>and<sp/>assign<sp/>colors<sp/>to<sp/>its<sp/>features.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(0,<sp/>0),<sp/>Point(4,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(0,<sp/>2),<sp/>Point(4,<sp/>2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr1,<sp/>Segment(Point(0,<sp/>4),<sp/>Point(4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>Segment(Point(0,<sp/>0),<sp/>Point(0,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>Segment(Point(2,<sp/>0),<sp/>Point(2,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>Segment(Point(4,<sp/>0),<sp/>Point(4,<sp/>4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(arr1.number_of_faces()<sp/>==<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr1.vertices_begin();<sp/>vit<sp/>!=<sp/>arr1.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vit-&gt;set_data(vcol1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>hit<sp/>=<sp/>arr1.halfedges_begin();<sp/>hit<sp/>!=<sp/>arr1.halfedges_end();<sp/>++hit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>hit-&gt;set_data(hcol1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr1.faces_begin();<sp/>fit<sp/>!=<sp/>arr1.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(fcol1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>second<sp/>arrangement<sp/>and<sp/>assign<sp/>colors<sp/>to<sp/>its<sp/>features.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/><sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(0,<sp/>0),<sp/>Point(6,<sp/>0)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(0,<sp/>3),<sp/>Point(6,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr2,<sp/>Segment(Point(0,<sp/>6),<sp/>Point(6,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr2,<sp/>Segment(Point(0,<sp/>0),<sp/>Point(0,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr2,<sp/>Segment(Point(3,<sp/>0),<sp/>Point(3,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr2,<sp/>Segment(Point(6,<sp/>0),<sp/>Point(6,<sp/>6)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(arr2.number_of_faces()<sp/>==<sp/>5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr2.vertices_begin();<sp/>vit<sp/>!=<sp/>arr2.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vit-&gt;set_data(vcol2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>hit<sp/>=<sp/>arr2.halfedges_begin();<sp/>hit<sp/>!=<sp/>arr2.halfedges_end();<sp/>++hit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>hit-&gt;set_data(hcol2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr2.faces_begin();<sp/>fit<sp/>!=<sp/>arr2.faces_end();<sp/>++fit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(fcol2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>overlay<sp/>of<sp/>the<sp/>two<sp/>arrangements,<sp/>while<sp/>blending<sp/>the<sp/>colors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>their<sp/>features.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/>ovl_arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Overlay_color_traits&lt;Ex_arrangement&gt;<sp/>overlay_traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" kindref="member">CGAL::overlay</ref>(arr1,<sp/>arr2,<sp/>ovl_arr,<sp/>overlay_traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>overlay-arrangement<sp/>vertices<sp/>and<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>ovl_arr.vertices_begin();<sp/>vit<sp/>!=<sp/>ovl_arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>0x&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::hex<sp/>&lt;&lt;<sp/>std::setfill(</highlight><highlight class="charliteral">&apos;0&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::setw(6)<sp/>&lt;&lt;<sp/>vit-&gt;data()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssecarr_with_hist">
<title>Storing the Curve History</title>
<para>When you constructs an arrangement induced by a set <formula id="5">$\mathcal{C}$</formula> of arbitrary two-dimensional curves, you end up with a collection <formula id="15">$\mathcal{C}&apos;&apos;$</formula> of <formula id="7">$x$</formula>-monotone subcurves of <formula id="5">$\mathcal{C}$</formula> that are pairwise disjoint in their interior; see Section <ref refid="index_1aos_sec-intro" kindref="member">Introduction</ref>. These subcurves are associated with the arrangement edges (more precisely, with pairs of DCEL halfedges). The connection between the originating input curves and the arrangement edges is lost during the construction process. This loss might be acceptable for some applications. However, in many practical cases it is important to determine the input curves that give rise to the final subcurves.</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt;GeometryTraits,TopologyTraits&gt;</computeroutput> class-template extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits,TopologyTraots&gt;</computeroutput> class template by keeping an additional container of input curves representing <formula id="5">$\mathcal{C}$</formula>, and by maintaining a cross-mapping between these curves and the arrangement edges they induce. Similarly, the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;GeometryTraits,Dcel&gt;</computeroutput> class-template extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;GeometryTraits,Dcel&gt;</computeroutput> class template. The <computeroutput>GeometryTraits</computeroutput> template parameter, of either class templates, must be substituted by a model of the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept; see Section <ref refid="index_1aos_ssec-insert_gen" kindref="member">Inserting General Curves</ref>. It should define the <ref refid="classArrangementTraits__2_1a2cb306c890ab7d32f397b5d246e0271f" kindref="member"><computeroutput>Curve_2</computeroutput></ref> type and support its subdivision into <ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> objects, among the others. The <computeroutput>Dcel</computeroutput> parameter must be substituted by a model of the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept. You can use either the default DCEL class or an extended DCEL class (see Section <ref refid="index_1arr_ssecex_dcel" kindref="member">Extending the DCEL</ref>) based on your needs. An arrangement that support the cross-mapping mentioned above is referred to as an arrangement with history. In the following we use the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;&gt;</computeroutput> class template to demonstrate arrangements with history. However, the explanation applies also to <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt;&gt;</computeroutput>, as the type of the embedding surface is irrelevant to the discussion.</para>
<sect3 id="index_1arr_sssecarrwh_traverse">
<title>Traversing an Arrangement with History</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class template extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template. Thus, all the iterator and circulator types that are defined in the base class are also available in <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput>. (Refer to Section <ref refid="index_1arr_ssectraverse" kindref="member">Traversing the Arrangement</ref> for a comprehensive review of this functionality.)</para>
<para>As mentioned above, the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class template maintains a container of input curves, which can be accessed using curve handles. Let <computeroutput>arr</computeroutput> identify an object, the type of which is an instance of this template. The call <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1adabd51104d7d446771faeeae3c1cc006" kindref="member"><computeroutput>arr.number_of_curves()</computeroutput></ref> returns the number of input curves stored in the container, while <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1a846c40b96b3527112cb5a1c74a48f284" kindref="member"><computeroutput>arr.curves_begin()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1a30d59f0a6ecf423882e8b6a63ca063b0" kindref="member"><computeroutput>arr.curves_end()</computeroutput></ref> return <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1aaeb6d64d0b074e3bb4b531105709565b" kindref="member">Arrangement_with_history_2::Curve_iterator</ref></computeroutput> objects that define the range of curves that induce the arrangement. The value type of this iterator is <ref refid="classCGAL_1_1Arrangement__with__history__2_1aa303273192e33c6f0c1fb3e6ca33d3c9" kindref="member"><computeroutput>Curve_2</computeroutput></ref>. Moreover, the curve-iterator type is convertible to <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1a66661bfe6e4c7c0aae696dc4e9c8f20e" kindref="member">Arrangement_with_history_2::Curve_handle</ref></computeroutput>, which is used for accessing the stored curves. For convenience, the corresponding constant-iterator and constant-handle types are also defined.</para>
<para>As mentioned in the previous paragraph, a <computeroutput>Curve_handle</computeroutput> object <computeroutput>ch</computeroutput> serves as a pointer to a curve stored in an arrangement-with-history object <computeroutput>arr</computeroutput>. Using this handle, it is possible to obtain the number of arrangement edges this curve induces by calling <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1a736c888847f5cbe4223bff41b7cac58d" kindref="member"><computeroutput>arr.number_of_induced_edges(ch)</computeroutput></ref>. The functions <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1ad8430b861299627388f22056a956ae1d" kindref="member"><computeroutput>arr.induced_edges_begin(ch)</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1accf9d2f8f20219060db5950c5224467f" kindref="member"><computeroutput>arr.induced_edges_end(ch)</computeroutput></ref> return iterators of type <computeroutput>Arrangement_with_history_2::Induced_edges_iterator</computeroutput> that define the range of edges induced by <computeroutput>ch</computeroutput>. The value type of these iterators is <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaae449ff521205c5ba837143c431d3d3" kindref="member"><computeroutput>Halfedge_handle</computeroutput></ref>. It is thus possible to traverse all arrangement edges induced by an input curve.</para>
<para>The ability to perform the inverse mapping is also important. Given an arrangement edge, you may want to determine which input curve induces it. In case the edge represents an overlap of several curves, you should be able to trace all input curves that overlap in this edge. The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class template is extended by several member functions that enable such an inverse mapping. Given a handle to halfedge <computeroutput>e</computeroutput> in an arrangement with history object <computeroutput>arr</computeroutput>, the call <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1aefdc80dd47efc942dc1f445287627091" kindref="member"><computeroutput>arr.number_of_originating_curves(e)</computeroutput></ref> returns the number of curves that induce the edge (which should be 1 in non-degenerate cases, and 2 or more in case of overlaps), while <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1aec69b664d8dc3e7de12effed4fcda7bc" kindref="member"><computeroutput>arr.originating_curves_begin(e)</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2_1a82d5f9d897f72653681a0897b3e6dfb9" kindref="member"><computeroutput>arr.originating_curves_end(e)</computeroutput></ref> return <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2_1a81214726cd69ee6d0f50cd3b3c543342" kindref="member">Arrangement_with_history_2::Originating_curve_iterator</ref></computeroutput> objects that define the range of curves that induce <computeroutput>e</computeroutput>. The value type of these iterators is <ref refid="classCGAL_1_1Arrangement__with__history__2_1aa303273192e33c6f0c1fb3e6ca33d3c9" kindref="member"><computeroutput>Curve_2</computeroutput></ref>.</para>
<para>Overlaying two arrangement-with-history objects is possible only if their types are instances of the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class template, where the respective <computeroutput>Traits</computeroutput> parameters are substituted by two traits classes that are convertible to one another. In this case, the resulting arrangement stores a consolidated container of input curves, and automatically preserves the cross-mapping between the arrangement edges and the consolidated curve-set. You may also employ an overlay-traits class to maintain any type of auxiliary data stored with the DCEL cells; see Section <ref refid="index_1arr_ssecoverlay" kindref="member">Overlaying Arrangements</ref>.</para>
</sect3>
<sect3 id="index_1arr_sssecmodif_traverse">
<title>Modifying an Arrangement with History</title>
<para>The <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> class template extends the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> class template; thus, it inherits the fundamental modification operations, such as <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a9eccc63d91d51f0e1a100dc8d0927472" kindref="member"><computeroutput>assign()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a61a86c3bc36e5c7bdd872f676f23ffbd" kindref="member"><computeroutput>clear()</computeroutput></ref>, from it. The vertex-manipulation functions are also inherited and supported; see Sections <ref refid="index_1arr_sssecmf_iso_verts" kindref="member">Manipulating Isolated Vertices</ref> and <ref refid="index_1arr_sssecinsert_point" kindref="member">Inserting Points</ref> for details. However, there are some fundamental differences between the interfaces of the two class templates, which we highlight next.</para>
<para>The most significant difference between the arrangement-with-history class template and the basic arrangement class template is the way they handle their input curves. <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref></computeroutput> always stores the <ref refid="classCGAL_1_1Arrangement__with__history__2_1aa303273192e33c6f0c1fb3e6ca33d3c9" kindref="member"><computeroutput>Curve_2</computeroutput></ref> objects that induce it. Thus, it is impossible to insert <formula id="7">$x$</formula>-monotone curves into an arrangement with history. The free functions <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve()</ref></computeroutput> and the version of <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> that accept <formula id="7">$x$</formula>-monotone curves, as well as their aggregated versions), are therefore not available for arrangement-with-history instances. Only the free overloaded functions <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput> that accept general curves, namely, the incremental insertion function and the aggregate insertion function, are supported; see Section <ref refid="index_1aos_ssec-insert_gen" kindref="member">Inserting General Curves</ref> for a review of these functions. Notice however that while the incremental insertion function <computeroutput>insert(arr, c)</computeroutput> for an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> object <computeroutput>arr</computeroutput> does not have a return value, the corresponding arrangement-with-history function returns a <computeroutput>Curve_handle</computeroutput> object that points to the inserted curve.</para>
<para>As we are able to keep track of all edges induced by an input curve, we also provide a free function that removes a curve from an arrangement. By calling <computeroutput>remove_curve(arr,ch)</computeroutput>, where <computeroutput>ch</computeroutput> is a valid curve handle, the given curve is deleted from the curve container, and all edges induced solely by this curve (i.e., excluding overlapping edges) are removed from the arrangement. The function returns the number of edges that have been removed.</para>
<para>In some cases, users may need to operate directly on the arrangement edges. We first mention that the specialized insertion functions (see Section <ref refid="index_1arr_sssecmf_insert_cv" kindref="member">Inserting Pairwise Disjoint x-Monotone Curves</ref>) are not supported, as they accept <formula id="7">$x$</formula>-monotone curves. Insertion can only be performed via the free insertion-functions. The other edge-manipulation functions (see Section <ref refid="index_1arr_sssecmf_halfedges" kindref="member">Manipulating Halfedges</ref>) are, however, available, but have a different interface that does not use <formula id="7">$x$</formula>-monotone curves.</para>
<para><itemizedlist>
<listitem>
<para>Invoking <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a2247def3072f9c94c659c68c55388dee" kindref="member"><computeroutput>split_edge(e,p)</computeroutput></ref> splits the edge <computeroutput>e</computeroutput> at a given point <computeroutput>p</computeroutput> that lies in its interior.</para>
<para></para>
</listitem>
<listitem>
<para>Invoking <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a21ad366a7eca1b0b6494e86162b661b6" kindref="member"><computeroutput>merge_edge(e1,e2)</computeroutput></ref> merges the two given edges. There is a precondition that <computeroutput>e1</computeroutput> and <computeroutput>e2</computeroutput> shared a common end-vertex of degree 2 prior to the merge, and that the <formula id="7">$x$</formula>-monotone subcurves associated with these edges are mergeable.</para>
<para></para>
</listitem>
<listitem>
<para>It is possible to remove an edge by simply invoking <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a89618f53b378427e38b7d68fb9f86873" kindref="member"><computeroutput>remove_edge(e)</computeroutput></ref>.</para>
<para></para>
</listitem>
</itemizedlist>
</para>
<para>In all cases, the maintenance of cross-pointers for the appropriate input curves will be done automatically.</para>
<para>Note that it is possible to attach observers to an arrangement-with-history object in order to get detailed notifications of the changes the arrangements undergoes; see Section <ref refid="index_1arr_ssecnotif" kindref="member">The Notification Mechanism</ref> for the details).</para>
<para><anchor id="index_1fig__aos_fig-curve_history"/> <image type="html" name="curve_history.png"></image>
 <image type="latex" name="curve_history.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-curve_history" kindref="member">fig__aos_fig-curve_history</ref> An arrangement with history as constructed in <ref refid="Arrangement_on_surface_2_2curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/curve_history.cpp</ref>. Note that <formula id="52">$s_1$</formula> and <formula id="95">$s_3$</formula> overlap over two edges. The point-location query points <formula id="395">$q_1$</formula>, <formula id="396">$q_2$</formula>, and <formula id="397">$q_3$</formula> are drawn as lightly shaded dots. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In the following example we construct a simple arrangement of six line segments, as depicted in <ref refid="index_1fig__aos_fig-curve_history" kindref="member">fig__aos_fig-curve_history</ref>, while maintaining the curve history. Note that the input segments <formula id="52">$s_1$</formula> and <formula id="95">$s_3$</formula> overlap over two edges. The example demonstrates the usage of the special traversal functions. It also shows how to issue point-location queries on the resulting arrangement (the query points <formula id="395">$q_1$</formula>, <formula id="396">$q_2$</formula>, and <formula id="397">$q_3$</formula> are drawn as crosses), using the auxiliary function <computeroutput>locate_point()</computeroutput> defined in the header file <computeroutput>point_location_utils.h</computeroutput>; see also Section <ref refid="index_1arr_ssecpl" kindref="member">Point-Location Queries</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/curve_history.cpp</ref> <programlisting filename="Arrangement_on_surface_2/curve_history.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Constructing<sp/>an<sp/>arrangement<sp/>with<sp/>curve<sp/>history.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arr_with_hist<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Curve_handle<sp/>=<sp/>Arr_with_hist::Curve_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_location<sp/>=<sp/><ref refid="classCGAL_1_1Arr__trapezoid__ric__point__location" kindref="compound">CGAL::Arr_trapezoid_ric_point_location&lt;Arr_with_hist&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>3<sp/>curves<sp/>incrementally.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(0,<sp/>3),<sp/>Point(4,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(3,<sp/>2),<sp/>Point(3,<sp/>5)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(Point(2,<sp/>3),<sp/>Point(5,<sp/>3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>three<sp/>additional<sp/>segments<sp/>aggregately.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>segs[]<sp/>=<sp/>{Segment(Point(2,<sp/>6),<sp/>Point(7,<sp/>1)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(0,<sp/>0),<sp/>Point(2,<sp/>6)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Segment(Point(3,<sp/>4),<sp/>Point(6,<sp/>4))};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>segs,<sp/>segs<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(segs)/</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Segment));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>out<sp/>the<sp/>curves<sp/>and<sp/>the<sp/>number<sp/>of<sp/>edges<sp/>each<sp/>one<sp/>induces.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>contains<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>curves:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cit<sp/>=<sp/>arr.curves_begin();<sp/>cit<sp/>!=<sp/>arr.curves_end();<sp/>++cit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Curve<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*cit<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>induces<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_induced_edges(cit)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>arrangement<sp/>edges<sp/>along<sp/>with<sp/>the<sp/>list<sp/>of<sp/>curves<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>induce<sp/>each<sp/>edge.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>comprises<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eit-&gt;curve()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;].<sp/>Originating<sp/>curves:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ocit<sp/>=<sp/>arr.originating_curves_begin(eit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ocit<sp/>!=<sp/>arr.originating_curves_end(eit);<sp/>++ocit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*ocit<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::flush;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>some<sp/>point-location<sp/>queries.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location<sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(pl,<sp/>Point(4,<sp/>6));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(pl,<sp/>Point(6,<sp/>2));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>locate_point(pl,<sp/>Point(2,<sp/>4));<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>q3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-edge_manipulation_curve_hostory"/> <image type="html" name="edge_manipulation_curve_history.png"></image>
 <image type="latex" name="edge_manipulation_curve_history.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-edge_manipulation_curve_hostory" kindref="member">fig__aos_fig-edge_manipulation_curve_hostory</ref> An arrangement with history of nine circles as constructed in <ref refid="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</ref>. Note the vertical tangency points of <formula id="398">$c_0$</formula>, marked as dark dots, which subdivide this circle into an upper half and a lower half, each consists of 9 edges. The large circle <formula id="398">$c_0$</formula> is eventually removed from the arrangement, with all 18 edges it induces. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example demonstrates the usage of the free <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gaa323bd67be0dc7cc326eb4f26653e326" kindref="member">remove_curve()</ref></computeroutput> function. We construct an arrangement of nine circles, while keeping a handle to each inserted circle. We then remove the large circle <formula id="398">$c_0$</formula>, which induces <formula id="399">$18$</formula> edges, as depicted in <ref refid="index_1fig__aos_fig-edge_manipulation_curve_hostory" kindref="member">fig__aos_fig-edge_manipulation_curve_hostory</ref>. The example also shows how to use the <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a2247def3072f9c94c659c68c55388dee" kindref="member"><computeroutput>split_edge()</computeroutput></ref> and <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a21ad366a7eca1b0b6494e86162b661b6" kindref="member"><computeroutput>merge_edge()</computeroutput></ref> member functions when operating on an arrangement-with-history object.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</ref> <programlisting filename="Arrangement_on_surface_2/edge_manipulation_curve_history.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removing<sp/>curves<sp/>and<sp/>manipulating<sp/>edges<sp/>in<sp/>an<sp/>arrangement<sp/>with<sp/>history.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_walk_along_line_point_location.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_circular.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arr_with_hist<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Curve_handle<sp/>=<sp/>Arr_with_hist::Curve_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_location<sp/>=<sp/><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">CGAL::Arr_walk_along_line_point_location&lt;Arr_with_hist&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>containing<sp/>nine<sp/>circles:<sp/>C[0]<sp/>of<sp/>radius<sp/>2<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>C[1],<sp/>...,<sp/>C[8]<sp/>of<sp/>radius<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Number_type<sp/>_7_halves<sp/>=<sp/>Number_type(7)<sp/>/<sp/>Number_type(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve<sp/>C[9];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[0]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(_7_halves,<sp/>_7_halves),<sp/>4,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[1]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(_7_halves,<sp/>6),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[2]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(5,<sp/>6),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[3]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(6,<sp/>_7_halves),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[4]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(5,<sp/>2),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[5]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(_7_halves,<sp/>1),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[6]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(2,<sp/>2),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[7]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(1,<sp/>_7_halves),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>C[8]<sp/>=<sp/>Circle(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>(2,<sp/>5),<sp/>1,<sp/><ref refid="group__kernel__enums_1ga5aa0906f2432d414090dd8723c10f304" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::CLOCKWISE</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Curve_handle<sp/>handles[9];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>9;<sp/>++k)<sp/>handles[k]<sp/>=<sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>C[k]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>initial<sp/>arrangement<sp/>size:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>large<sp/>circle<sp/>C[0].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Removing<sp/>C[0]:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1gaa323bd67be0dc7cc326eb4f26653e326" kindref="member">remove_curve</ref>(arr,<sp/>handles[0])</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>edges<sp/>have<sp/>been<sp/>removed.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Locate<sp/>the<sp/>point<sp/>q,<sp/>which<sp/>should<sp/>be<sp/>on<sp/>an<sp/>edge<sp/>e.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location<sp/>pl(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>q{_7_halves,<sp/>7};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_location::result_type<sp/>obj<sp/>=<sp/>pl.locate(q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>e<sp/>=<sp/>std::get_if&lt;Arr_with_hist::Halfedge_const_handle&gt;(&amp;obj);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Split<sp/>the<sp/>edge<sp/>e<sp/>to<sp/>two<sp/>edges<sp/>e1<sp/>and<sp/>e2;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>e1<sp/>=<sp/>arr.split_edge(arr.non_const_handle(*e),<sp/>q);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>e2<sp/>=<sp/>e1-&gt;next();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>edge<sp/>split:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Merge<sp/>back<sp/>the<sp/>two<sp/>split<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arr.merge_edge(e1,<sp/>e2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;After<sp/>edge<sp/>merge:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-io">
<title>Input/Output Streams and Visualization</title>
<para>In some cases, one would like to save an arrangement object constructed by some application, so that later on it can be restored. In other cases one would like to create nice drawings that represent arrangements constructed by some application. These drawings can be hard printed or displayed on a computer screen.</para>
<sect2 id="index_1aos_ssec-io-stream">
<title>Input/Output Stream</title>
<para>Consider an arrangement that represents a very complicated geographical map, and assume that there are various applications that need to answer point-location queries on this map. Naturally, you can store the set of curves that induces the arrangement, but this implies that you would need to construct the arrangement from scratch each time you need to reuse it. A more efficient solution is to write the arrangement to a file in a format that other applications can read.</para>
<para>This package provides an <emphasis>inserter</emphasis> (the <computeroutput>&lt;&lt;</computeroutput> operator) and an <emphasis>extractor</emphasis> (the <computeroutput>&gt;&gt;</computeroutput> operator) for the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class that inserts an arrangement object into an output stream and extracts an arrangement object from an input stream, respectively. The arrangement is written using a simple predefined ASCII format that encodes the arrangement topology, as well as all geometric entities associated with vertices and edges.</para>
<para>The ability to use the input/output operators, requires that the <ref refid="classArrangementBasicTraits__2_1a8cfc873dc62ce86f9479c4689845d4b3" kindref="member"><computeroutput>Point_2</computeroutput></ref> type and the <ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> type defined by the traits class both support the <computeroutput>&lt;&lt;</computeroutput> and <computeroutput>&gt;&gt;</computeroutput> operators. The <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">Arr_conic_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_sssectr_conic" kindref="member">A Traits Class for Conic Arcs</ref>), the <computeroutput><ref refid="classCGAL_1_1Arr__rational__function__traits__2" kindref="compound">Arr_rational_function_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_sssectr_ratfunc" kindref="member">A Traits Class for Arcs of Rational Functions</ref>), and the <computeroutput><ref refid="classCGAL_1_1Arr__linear__traits__2" kindref="compound">Arr_linear_traits_2</ref></computeroutput> class (see Section <ref refid="index_1arr_ssectr_segs" kindref="member">Traits Classes for Line Segments and Linear Objects</ref>) currently do not provide these operators for the geometric types they define. Thus, only arrangements of line segments or of polylines can be written or read.</para>
<para>The following example constructs the arrangement depicted in <ref refid="index_1fig__aos_fig-special_edge_insertion" kindref="member">fig__aos_fig-special_edge_insertion</ref> and writes it to an output file. It also demonstrates how to re-read the arrangement from a file.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2io_8cpp-example" kindref="compound">Arrangement_on_surface_2/io.cpp</ref> <programlisting filename="Arrangement_on_surface_2/io.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>arrangement<sp/>I/O<sp/>operators.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_inexact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;point_location_utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>construct_segments_arr(arr1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out_file(</highlight><highlight class="stringliteral">&quot;arr_ex_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file<sp/>&lt;&lt;<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(</highlight><highlight class="stringliteral">&quot;arr_ex_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Reading\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssecarr_io_aux_data">
<title>Arrangements with Auxiliary Data</title>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly>  The inserter and extractor both ignore any auxiliary data stored with the arrangement features. Thus, they are ideal for arrangements instantiated using the default DCEL, which is the instance <computeroutput>Arr_default_dcel&lt;Traits&gt;</computeroutput>. However, as explained in Section <ref refid="index_1arr_ssecex_dcel" kindref="member">Extending the DCEL</ref>, one can easily extend the arrangement faces by using the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref></computeroutput> template, extend all DCEL records by using the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref></computeroutput> template, or use the <computeroutput><ref refid="classCGAL_1_1Arr__dcel" kindref="compound">Arr_dcel</ref></computeroutput> template. In such cases, it might be crucial that the auxiliary data fields are written to the file and read from there.</para>
<para>The arrangement package includes the free functions <computeroutput>write(arr, os, formatter)</computeroutput>, which writes the arrangement <computeroutput>arr</computeroutput> to an output stream <computeroutput>os</computeroutput>, and <computeroutput>read(arr, os, formatter)</computeroutput>, which reads the arrangement <computeroutput>arr</computeroutput> from an input stream <computeroutput>is</computeroutput>. Both operations are performed using a <computeroutput>formatter</computeroutput> object, which defines the I/O format. The package contains three formatter classes: <itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__text__formatter" kindref="compound">Arr_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> defines a simple textual I/O format for the arrangement topology and geometry, disregarding any auxiliary data that may be associated with the arrangement features. This is the default formatter used by the arrangement inserter and the arrangement extractor, as defined above. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__face__extended__text__formatter" kindref="compound">Arr_face_extended_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> operates on arrangements whose DCEL representation is based on the <computeroutput><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">Arr_face_extended_dcel</ref>&lt;Traits,FaceData&gt;</computeroutput> class (see Section <ref refid="index_1arr_sssecex_dcel_face" kindref="member">Extending the DCEL Faces</ref>). It supports reading and writing the auxiliary data objects stored with the arrangement faces provided that the <computeroutput>FaceData</computeroutput> class supports an inserter and an extractor. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel__text__formatter" kindref="compound">Arr_extended_dcel_text_formatter</ref>&lt;Arrangement&gt;</computeroutput> operates on arrangements whose DCEL representation is based on the <computeroutput><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">Arr_extended_dcel</ref>&lt;Traits,VertexData,HalfedgeData,FaceData&gt;</computeroutput> class (see Section <ref refid="index_1arr_sssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>). It supports reading and writing the auxiliary data objects stored with the arrangement vertices, edges and faces, provided that the <computeroutput>VertexData</computeroutput>, <computeroutput>HalfedgeData</computeroutput> and <computeroutput>FaceData</computeroutput> classed all have inserters and extractors. </para>
</listitem>
</itemizedlist>
</para>
<para>The following example constructs the same arrangement as the example <computeroutput>dcel_extension</computeroutput> does (see Section <ref refid="index_1arr_sssecex_dcel_all" kindref="member">Extending All DCEL Records</ref>), depicted in <ref refid="index_1fig__aos_fig-dcel_extension" kindref="member">fig__aos_fig-dcel_extension</ref>, and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2dcel_extension_io_8cpp-example" kindref="compound">Arrangement_on_surface_2/dcel_extension_io.cpp</ref> <programlisting filename="Arrangement_on_surface_2/dcel_extension_io.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>I/O<sp/>operators<sp/>for<sp/>arrangements<sp/>with<sp/>extended<sp/>DCEL<sp/>records.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_text_formatter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>Color<sp/>{BLUE,<sp/>RED,<sp/>WHITE};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::ostream&amp;<sp/><ref refid="group__IOstreamOperators_1gab63c7e66d05c61b2cafb1f85fd8bb3f7" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">operator&lt;&lt;</ref>(std::ostream&amp;<sp/>os,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Color&amp;<sp/>color)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(color)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>BLUE:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;BLUE&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>RED:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;RED&quot;</highlight><highlight class="normal">;<sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>WHITE:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;WHITE&quot;</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:<sp/>os<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR!&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>os;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::istream&amp;<sp/><ref refid="group__IOstreamOperators_1ga2e62094cfede6ee53227479cd7250883" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">operator&gt;&gt;</ref>(std::istream&amp;<sp/>is,<sp/>Color&amp;<sp/>color)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>str;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>is<sp/>&gt;&gt;<sp/>str;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;BLUE&quot;</highlight><highlight class="normal">)<sp/>color<sp/>=<sp/>BLUE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;RED&quot;</highlight><highlight class="normal">)<sp/>color<sp/>=<sp/>RED;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;WHITE&quot;</highlight><highlight class="normal">)<sp/>color<sp/>=<sp/>WHITE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>is;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ext_dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__extended__dcel" kindref="compound">CGAL::Arr_extended_dcel&lt;Traits, Color, bool, int&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ext_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Ext_dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Formatter<sp/>=<sp/><ref refid="classCGAL_1_1Arr__extended__dcel__text__formatter" kindref="compound">CGAL::Arr_extended_dcel_text_formatter&lt;Ext_arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>arrangement<sp/>containing<sp/>two<sp/>intersecting<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ext_arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s1(Point(4,<sp/>1),<sp/>Point(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s2(Point(1,<sp/>6),<sp/>Point(7,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s3(Point(4,<sp/>1),<sp/>Point(1,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s4(Point(1,<sp/>3),<sp/>Point(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s5(Point(1,<sp/>3),<sp/>Point(4,<sp/>8));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s6(Point(4,<sp/>8),<sp/>Point(7,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>s6);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>vertices<sp/>and<sp/>set<sp/>their<sp/>colors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>degree<sp/>=<sp/>vit-&gt;degree();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>==<sp/>0)<sp/>vit-&gt;set_data(BLUE);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Isolated<sp/>vertex</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(degree<sp/>&lt;=<sp/>2)<sp/>vit-&gt;set_data(RED);<sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>endpoint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>vit-&gt;set_data(WHITE);<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vertex<sp/>represents<sp/>an<sp/>intersection<sp/>point</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>edges<sp/>and<sp/>set<sp/>their<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>eit<sp/>=<sp/>arr.edges_begin();<sp/>eit<sp/>!=<sp/>arr.edges_end();<sp/>++eit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>the<sp/>halfedge<sp/>has<sp/>the<sp/>same<sp/>direction<sp/>as<sp/>its<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>segment.<sp/>Note<sp/>that<sp/>its<sp/>twin<sp/>always<sp/>has<sp/>an<sp/>opposite<sp/>direction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>flag<sp/>=<sp/>(eit-&gt;source()-&gt;point()<sp/>==<sp/>eit-&gt;curve().source());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;set_data(flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>eit-&gt;twin()-&gt;set_data(!<sp/>flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>all<sp/>arrangement<sp/>faces<sp/>and<sp/>print<sp/>their<sp/>outer<sp/>boundary<sp/>and<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>boundary_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boundary_size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<sp/>fit-&gt;is_unbounded())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>curr<sp/>=<sp/>fit-&gt;outer_ccb();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>++boundary_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++curr<sp/>!=<sp/>fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fit-&gt;set_data(boundary_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out_file(</highlight><highlight class="stringliteral">&quot;arr_ex_dcel_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Formatter<sp/>formatter;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Write_1ga2c5c5eaca6ac64bcc0c54b9c95d0a37f" kindref="member">CGAL::IO::write</ref>(arr,<sp/>out_file,<sp/>formatter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ext_arrangement<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(</highlight><highlight class="stringliteral">&quot;arr_ex_dcel_io.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Read_1ga66548d0cf66a26f18064927bc828b43a" kindref="member">CGAL::IO::read</ref>(arr2,<sp/>in_file,<sp/>formatter);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>arrangement<sp/>vertices:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr2.vertices_begin();<sp/>vit<sp/>!=<sp/>arr2.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;(&apos;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>-<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;data()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>You may develop your own formatter classes - models of the <computeroutput><ref refid="classArrangementInputFormatter" kindref="compound">ArrangementInputFormatter</ref></computeroutput> and <computeroutput><ref refid="classArrangementOutputFormatter" kindref="compound">ArrangementOutputFormatter</ref></computeroutput> concepts, as defined in the Reference Manual. Doing so, you can define other I/O formats, such as an XML-based format or a binary format. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect2>
<sect2 id="index_1arr_ssecarr_io_hist">
<title>Arrangements with Curve History</title>
<para>Section <ref refid="index_1arr_ssecarr_with_hist" kindref="member">Storing the Curve History</ref> introduces the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class, which saves the set of curves inducing an arrangement and maintains the relations between these curves and the edges they induce. Naturally, when reading or writing an arrangement-with-history instance we would like this information to be saved to the output stream or restored from the input stream alongside with the basic arrangement structure.</para>
<para>The arrangement package supplies an inserter and an extractor for the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> class. The arrangement is represented using a simple predefined ASCII format. An object of the <computeroutput><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt;Traits,Dcel&gt;</computeroutput> type can be saved and restored, as long as the <ref refid="classCGAL_1_1Arrangement__with__history__2_1aa303273192e33c6f0c1fb3e6ca33d3c9" kindref="member"><computeroutput>Curve_2</computeroutput></ref> type defined by the traits class<mdash/>as well as the <ref refid="classCGAL_1_1Arrangement__with__history__2_1ad7955c45cc6c5fc356b49bcad2c175f8" kindref="member"><computeroutput>Point_2</computeroutput></ref> type and the <ref refid="classCGAL_1_1Arrangement__with__history__2_1ad368cff686575c0a5104f580c1f66d6d" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> types<mdash/>support the <computeroutput>&lt;&lt;</computeroutput> and<computeroutput>&gt;&gt;</computeroutput> operators.</para>
<para>The following example constructs the same arrangement as example <computeroutput>curve_history</computeroutput> does, depicted in <ref refid="index_1fig__aos_fig-curve_history" kindref="member">fig__aos_fig-curve_history</ref>, and writes it to an output file. It also demonstrates how to re-read the arrangement-with-history from a file:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2io_curve_history_8cpp-example" kindref="compound">Arrangement_on_surface_2/io_curve_history.cpp</ref> <programlisting filename="Arrangement_on_surface_2/io_curve_history.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Using<sp/>the<sp/>arrangement-with-history<sp/>I/O<sp/>operators.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/basic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_with_history_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Arr_with_history_iostream.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Arr_with_hist<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">CGAL::Arrangement_with_history_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>six<sp/>additional<sp/>segments<sp/>aggregately:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>segs[6];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[0]<sp/>=<sp/>Segment(Point(2,<sp/>6),<sp/>Point(7,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[1]<sp/>=<sp/>Segment(Point(3,<sp/>2),<sp/>Point(3,<sp/>5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[2]<sp/>=<sp/>Segment(Point(2,<sp/>3),<sp/>Point(5,<sp/>3));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[3]<sp/>=<sp/>Segment(Point(2,<sp/>6),<sp/>Point(7,<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[4]<sp/>=<sp/>Segment(Point(0,<sp/>0),<sp/>Point(2,<sp/>6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>segs[5]<sp/>=<sp/>Segment(Point(3,<sp/>4),<sp/>Point(6,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr1,<sp/>segs,<sp/>segs<sp/>+<sp/>6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Writing<sp/>an<sp/>arrangement<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr1.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>segments:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>the<sp/>arrangement<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out_file(</highlight><highlight class="stringliteral">&quot;arr_ex_io_hist.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file<sp/>&lt;&lt;<sp/>arr1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out_file.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Read<sp/>the<sp/>arrangement<sp/>from<sp/>the<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arr_with_hist<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in_file(</highlight><highlight class="stringliteral">&quot;arr_ex_io_hist.dat&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file<sp/>&gt;&gt;<sp/>arr2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in_file.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Read<sp/>an<sp/>arrangement<sp/>of<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr2.number_of_curves()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>input<sp/>segments:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>print_arrangement_size(arr2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><htmlonly block="yes"> &lt;div class=&quot;CGALAdvanced&quot;&gt; &lt;div&gt;Advanced&lt;/div&gt; </htmlonly></para>
<para>The arrangement package also includes the free functions <computeroutput>write(arr,
os, formatter)</computeroutput> and <computeroutput>read(arr, os, formatter)</computeroutput> that operate on a given arrangement-with-history instance <computeroutput>arr</computeroutput>. Both functions are parameterized by a <computeroutput>formatter</computeroutput> object, which defines the I/O format. The package contains a template called, <computeroutput>Arr_with_hist_text_formatter&lt;ArranagmentFormatter&gt;</computeroutput>, which extends an arrangement formatter class (see Section <ref refid="index_1arr_ssecarr_io_aux_data" kindref="member">Arrangements with Auxiliary Data</ref>) and defines a simple textual input/output format. <htmlonly block="yes"> &lt;/div&gt; </htmlonly></para>
</sect2>
<sect2 id="index_1arr_ssecarr_io_vis">
<title>Drawing an Arrangement</title>
<para>An arrangement data structure can be visualized by calling the <ref refid="group__PkgArrangementOnSurface2Draw" kindref="compound">CGAL::draw&lt;arr&gt;() </ref> function as shown in the following example. This function opens a new window showing the given arrangement. A call to this function is blocking; that is, the program continues execution only after the user closes the window.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2draw_arr_8cpp-example" kindref="compound">Arrangement_on_surface_2/draw_arr.cpp</ref> <programlisting filename="Arrangement_on_surface_2/draw_arr.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_segment_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Traits<sp/>=<sp/><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point<sp/>=<sp/>Traits::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref><sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::tuple&lt;unsigned<sp/>char,<sp/>unsigned<sp/>char,<sp/>unsigned<sp/>char&gt;</highlight></codeline>
<codeline><highlight class="normal">hsv_to_rgb(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hue,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>sat,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>value)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>red,<sp/>green,<sp/>blue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>fc<sp/>=<sp/>value<sp/>*<sp/>sat;<sp/></highlight><highlight class="comment">//<sp/>Chroma</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>hue_prime<sp/>=<sp/>fmod(hue<sp/>/<sp/>60.0f,<sp/>6.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>fx<sp/>=<sp/>fc<sp/>*<sp/>(1.0f<sp/>-<sp/>fabs(fmod(hue_prime,<sp/>2.f)<sp/>-<sp/>1.f));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>fm<sp/>=<sp/>value<sp/>-<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(0<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(1<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(2<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(3<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(4<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>5)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(5<sp/>&lt;=<sp/>hue_prime<sp/>&amp;&amp;<sp/>hue_prime<sp/>&lt;<sp/>6)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>fc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>fx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>red<sp/>+=<sp/>fm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>green<sp/>+=<sp/>fm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>blue<sp/>+=<sp/>fm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>red<sp/>*=<sp/>255;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>green<sp/>*=<sp/>255;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>blue<sp/>*=<sp/>255;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>redc<sp/>=<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>char)red;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>greenc<sp/>=<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>char)green;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>bluec<sp/>=<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>char)blue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(redc,<sp/>greenc,<sp/>bluec);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Traits<sp/>traits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement_2<sp/>arr(&amp;traits);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ctr_xcv<sp/>=<sp/>traits.construct_x_monotone_curve_2_object();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(-2,-2),<sp/>Point(2,-2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(2,-2),<sp/>Point(2,2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(2,2),<sp/>Point(-2,2)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(-2,2),<sp/>Point(-2,-2)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(-1,-1),<sp/>Point(1,-1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(1,-1),<sp/>Point(1,1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(1,1),<sp/>Point(-1,1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(-1,1),<sp/>Point(-1,-1)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(-2,-2),<sp/>Point(-2,-4)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(2,-2),<sp/>Point(4,-2)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">CGAL::insert</ref>(arr,<sp/>ctr_xcv(Point(0,0),<sp/>Point(0,-3)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>arr.number_of_vertices()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_edges()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>arr.number_of_faces()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>id(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>CGAL::Graphics_scene_options&lt;Arrangement_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1a2b84fbf1c36a71637c4f09766cc89404" kindref="member">Arrangement_2::Vertex_const_handle</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1ae6a57d8ef97a928b56bb482085b62360" kindref="member">Arrangement_2::Halfedge_const_handle</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Arrangement__2_1aec6445d17ffe4ab1d5730d889bb576bc" kindref="member">Arrangement_2::Face_const_handle</ref>&gt;<sp/>gso;</highlight></codeline>
<codeline><highlight class="normal"><sp/>gso.colored_face=[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Arrangement_2&amp;,<sp/><ref refid="classCGAL_1_1Arrangement__2_1aec6445d17ffe4ab1d5730d889bb576bc" kindref="member">Arrangement_2::Face_const_handle</ref>)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>gso.face_color=[&amp;id](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Arrangement_2&amp;<sp/>arr,<sp/><ref refid="classCGAL_1_1Arrangement__2_1aec6445d17ffe4ab1d5730d889bb576bc" kindref="member">Arrangement_2::Face_const_handle</ref>)<sp/>-&gt;<sp/><ref refid="classCGAL_1_1IO_1_1Color" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::Color</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>h<sp/>=<sp/>360.0f<sp/>*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">++<sp/>/<sp/>arr.number_of_faces();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>s<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>v<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[r,<sp/>g,<sp/>b]<sp/>=<sp/>hsv_to_rgb(h,<sp/>s,<sp/>v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1IO_1_1Color" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::Color</ref>(r,g,b);</highlight></codeline>
<codeline><highlight class="normal"><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><ref refid="group__PkgDrawPolygonSet2_1gac5ad1c3be15e88df46b096885a023ff4" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Boolean_set_operations_2.tag">CGAL::draw</ref>(arr,<sp/>gso,<sp/></highlight><highlight class="stringliteral">&quot;hsv<sp/>colors&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>This function requires <computeroutput>CGAL_Qt6</computeroutput>, and is only available if the macro <computeroutput>CGAL_USE_BASIC_VIEWER</computeroutput> is defined. Linking with the cmake target <computeroutput>CGAL::CGAL_Basic_viewer</computeroutput> will link with <computeroutput>CGAL_Qt6</computeroutput> and add the definition <computeroutput>CGAL_USE_BASIC_VIEWER</computeroutput>.</para>
<para><anchor id="index_1fig__aos_fig-draw_arr"/> <image type="html" name="draw_arr.png"></image>
 <image type="latex" name="draw_arr.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-draw_arr" kindref="member">fig__aos_fig-draw_arr</ref> A snapshot of the window created by the program <ref refid="Arrangement_on_surface_2_2draw_arr_8cpp-example" kindref="compound">Arrangement_on_surface_2/draw_arr.cpp</ref>. The constructed arrangement consists of 14 vertices, 15 edges, and 3 faces. Notice that the colors are generated at random. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-bgl">
<title>Adapting to Boost Graphs</title>
<para>BoostSee also Boost&apos;s homepage at: <computeroutput>www.boost.org</computeroutput>. is a collection of portable C++ libraries that extend the C++ Standard Library. The Boost Graph Library (BGL), which one of the libraries in the collection, offers an extensive set of generic graph algorithms parameterized through templates. As our arrangements are embedded as planar graphs, it is only natural to extend the underlying data structure with the interface that the BGL expects, and gain the ability to perform the operations that the BGL supports, such as shortest-path computation. This section describes how to apply the graph algorithms implemented in the BGL to <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instances.</para>
<para>An instance of <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> is adapted to a Boost graph through the provision of a set of free functions that operate on the arrangement features and conform with the relevant BGL concepts. Besides the straightforward adaptation, which associates a vertex with each DCEL vertex and an edge with each DCEL halfedge, the package also offer a <emphasis>dual</emphasis> adaptor, which associates a graph vertex with each DCEL face, such that two vertices are connected, iff there is a DCEL halfedge that connects the two corresponding faces.</para>
<sect2 id="index_1arr_ssecbgl_primal">
<title>The Primal Arrangement Representation</title>
<para>Arrangement instances are adapted to Boost graphs by specializing the <ref refid="group__PkgBGLTraits_1BGLArgtGT" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag"><computeroutput>boost::graph_traits</computeroutput> </ref> template for <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</para>
<para>In this specialization the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member"><computeroutput>Vertex_handle</computeroutput></ref> is the graph-vertex type, while <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaae449ff521205c5ba837143c431d3d3" kindref="member"><computeroutput>Halfedge_handle</computeroutput></ref> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint <formula id="7">$x$</formula>-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our Boost.</para>
<para>Given an <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">VertexListGraph</ref></computeroutput> and <computeroutput><ref refid="classEdgeListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">EdgeListGraph</ref></computeroutput> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<computeroutput>Halfedge_around_vertex_circulator</computeroutput> - see Section <ref refid="index_1arr_sssectr_vertex" kindref="member">Traversal Methods for an Arrangement Vertex</ref>), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (this concept refines <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>, which requires only the traversal of outgoing edges).</para>
<para>It is important to notice that the vertex descriptors we use are <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Vertex_handle <computeroutput>Vertex_handle</computeroutput></ref> objects and <emphasis>not</emphasis> vertex indices. However, in order to gain more efficiency in most BGL algorithms, it is better to have them indexed <formula id="400">$0, 1,
\ldots, (n-1)$</formula>, where <formula id="86">$n$</formula> is the number of vertices. We therefore introduce the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <ref refid="index_1arr_ssecnotif" kindref="member">The Notification Mechanism</ref>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</para>
<para>In most algorithms provided by the BGL, the output is given by <emphasis>property maps</emphasis>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex <formula id="67">$s$</formula> to all other vertices we can obtain a map of distances and a map of predecessors - namely for each <formula id="30">$v$</formula> vertex we have its distance from <formula id="67">$s$</formula> and a descriptor of the vertex that precedes <formula id="30">$v$</formula> in a shortest path from <formula id="67">$s$</formula>.</para>
<para>If the vertex descriptors are simply indices, boost supplies tools to easily represent property maps using vectors. The <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref>&lt;Arrangement&gt;</computeroutput> class template enables the creation of such indices, and together with <computeroutput>boost::vector_property_map&lt;Type, IndexMap&gt;</computeroutput> it generates an efficient mapping from <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member"><computeroutput>Vertex_handle</computeroutput></ref> objects to properties of type <computeroutput>Type</computeroutput>. Note, however, that unlike the <computeroutput><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">Arr_vertex_index_map</ref></computeroutput> class template, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to BGL functions in case the arrangement is modified in between these calls.</para>
<para>The first example of this section demonstrates the application of Dijkstra&apos;s shortest path algorithm to compute the shortest-path length between a given vertex of an arrangement of linear curves and all other vertices. The length of a path is defined as the sum of squared Euclidean lengths of its segments. It uses an instance of the functor template <computeroutput>Edge_length&lt;Arrangement&gt;}</computeroutput> to compute the squared Euclidean length of the linear curve associated with a given halfedge of the arrangement. The functor implements a Boost property-map that attaches square lengths to edges; when the BGL algorithm queries the property map for a squared length of an edge the property map computes and returns it. The functor template is defined in the header file <computeroutput>Edge_length.h</computeroutput>.</para>
<para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement&gt;<sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Edge_length<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property-type<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::readable_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Number_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_handle<sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>value_type<sp/>operator()(</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Halfedge_handle<sp/>e)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>diff_x<sp/>=<sp/>e-&gt;target()-&gt;point().x()<sp/>-<sp/>e-&gt;source()-&gt;point().x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>diff_y<sp/>=<sp/>e-&gt;target()-&gt;point().y()<sp/>-<sp/>e-&gt;source()-&gt;point().y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>diff_x<sp/>*<sp/>diff_x<sp/>+<sp/>diff_y<sp/>*<sp/>diff_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/>value_type<sp/>get(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Edge_length&amp;<sp/>edge_length,<sp/>key_type<sp/>key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>edge_length(key);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-bgl_primal_adapter"/> <image type="html" name="bgl_primal_adapter.png"></image>
 <image type="latex" name="bgl_primal_adapter.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-bgl_primal_adapter" kindref="member">fig__aos_fig-bgl_primal_adapter</ref> An arrangement of seven line segments, as constructed by <ref refid="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_primal_adapter.cpp</ref> and <ref refid="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_dual_adapter.cpp</ref>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In the following example we construct an arrangement of seven line segments, as shown in <ref refid="index_1fig__aos_fig-bgl_primal_adapter" kindref="member">fig__aos_fig-bgl_primal_adapter</ref>. Then, it uses the BGL generic implementation of Dijkstra&apos;s shortest-paths algorithm to compute the sum of squared distances to all vertices from the lexicographically smallest vertex <formula id="401">$v_0$</formula> in the arrangement. Note the usage of the <computeroutput>Arr_vertex_property_map</computeroutput> class template in the call to <computeroutput>boost::dijkstra_shortest_paths()</computeroutput> and in the definition of the distance property-map. We instantiate a property map that attaches a number of type <computeroutput>Number_type</computeroutput> (which is a type of unlimited precision) to each vertex. The number represents the sum of squared distances of the vertex from <formula id="401">$v_0$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_primal_adapter.cpp</ref> <programlisting filename="Arrangement_on_surface_2/bgl_primal_adapter.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Adapting<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/dijkstra_shortest_paths.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/property_map/vector_property_map.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_Arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_vertex_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;Edge_length.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vertex_index_map<sp/>=<sp/><ref refid="classCGAL_1_1Arr__vertex__index__map" kindref="compound">CGAL::Arr_vertex_index_map&lt;Arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">My_edge_length<sp/>=<sp/>Edge_length&lt;Arrangement&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>keep<sp/>a<sp/>handle<sp/>for<sp/>the<sp/>vertex<sp/>v0<sp/>that<sp/>corresponds<sp/>to<sp/>the<sp/>point<sp/>(1,1).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>1),<sp/>p2(1,<sp/>4),<sp/>p3(2,<sp/>2),<sp/>p4(3,<sp/>7),<sp/>p5(4,<sp/>4),<sp/>p6(7,<sp/>1),<sp/>p7(9,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement<sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Segment<sp/>s(p1,<sp/>p6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement::Halfedge_handle<sp/>e<sp/>=<sp/><ref refid="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" kindref="member">insert_non_intersecting_curve</ref>(arr,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Arrangement::Vertex_handle<sp/>v0<sp/>=<sp/>e-&gt;source();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p1,<sp/>p4));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p2,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p3,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p3,<sp/>p5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p6,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p4,<sp/>p7));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_index_map<sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>property<sp/>map<sp/>based<sp/>on<sp/>std::vector<sp/>to<sp/>keep<sp/>the<sp/>result<sp/>distances.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::vector_property_map&lt;Number_type,<sp/>Vertex_index_map&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dist_map(</highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(arr.number_of_vertices()),<sp/>index_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>Dijkstra&apos;s<sp/>algorithm<sp/>from<sp/>the<sp/>vertex<sp/>v0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_edge_length<sp/>edge_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::dijkstra_shortest_paths(arr,<sp/>v0,<sp/>boost::vertex_index_map(index_map).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>weight_map(edge_length).distance_map(dist_map).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_zero(Number_type(0)).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance_inf(Number_type(1000)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>distance<sp/>of<sp/>each<sp/>vertex<sp/>from<sp/>v0.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>graph<sp/>distances<sp/>of<sp/>the<sp/>arrangement<sp/>vertices<sp/>from<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>v0-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>vit<sp/>=<sp/>arr.vertices_begin();<sp/>vit<sp/>!=<sp/>arr.vertices_end();<sp/>++vit)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vit-&gt;point()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)<sp/>at<sp/>distance<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double</ref>(dist_map[vit])<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1arr_ssecbgl_dual">
<title>The Dual Arrangement Representation</title>
<para>An arrangement instance can be represented as a graph other than the one described in the previous section. A dual-graph representation refers to the graph, where each arrangement face corresponds to a graph vertex, and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <computeroutput>boost::graph_traits</computeroutput> template for <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput> instances, where <computeroutput><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">Dual</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput> is a template specialization that gives a dual interpretation to an arrangement instance.</para>
<para>In a dual representation, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5c97d46fc76cf9ab96ceced3b795b3c9" kindref="member"><computeroutput>Face_handle</computeroutput></ref> is the graph-vertex type, while <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaae449ff521205c5ba837143c431d3d3" kindref="member"><computeroutput>Halfedge_handle</computeroutput></ref> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <computeroutput>e</computeroutput> is directed from <formula id="2">$f_1$</formula>, which is its incident face, to <formula id="3">$f_2$</formula>, which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges (loops) in our Boost graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <computeroutput><ref refid="classVertexListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">VertexListGraph</ref></computeroutput>, <computeroutput><ref refid="classEdgeListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">EdgeListGraph</ref></computeroutput> and <computeroutput><ref refid="classBidirectionalGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">BidirectionalGraph</ref></computeroutput> (thus also of <computeroutput><ref refid="classIncidenceGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">IncidenceGraph</ref></computeroutput>).</para>
<para>Since we use <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5c97d46fc76cf9ab96ceced3b795b3c9" kindref="member"><computeroutput>Face_handle</computeroutput></ref> objects as the vertex descriptors, we define the <computeroutput><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound">Arr_face_index_map</ref>&lt;Arrangement&gt;</computeroutput> class-template, which maintains an efficient mapping of face handles to indices.</para>
<para>The next example demonstrates how a property map can be used to update or receive information directly from a feature of the arrangement without the need to search for its index. The example also demonstrates the application of the breadth-first search} (BFS) algorithm on a dual arrangement. It uses the functor template <computeroutput>Extended_face_property_map&lt;Arrangement, Type&gt;</computeroutput> to directly access information stored inside the faces. The functor implements a property map that utilizes the <computeroutput>data()</computeroutput> and <computeroutput>set_data()</computeroutput> member functions of the extended face to update or obtain the property. When the property map is instantiated, the <computeroutput>Type</computeroutput> parameter must be substituted by the same type that is used to extend the arrangement face; see Section <ref refid="index_1arr_sssecex_dcel_face" kindref="member">Extending the DCEL Faces</ref>. The functor template is defined in the header file <computeroutput>Extended_face_property_map.h</computeroutput> listed below.</para>
<para><programlisting><codeline><highlight class="comment">//<sp/>A<sp/>property<sp/>map<sp/>that<sp/>reads/writes<sp/>the<sp/>information<sp/>to/from<sp/>the<sp/>extended<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Type&gt;<sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Extended_face_property_map<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Arrangement::Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>Face_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Boost<sp/>property<sp/>type<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>boost::read_write_property_map_tag<sp/><sp/><sp/><sp/><sp/><sp/>category;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>value_type&amp;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Face_handle<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>get<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/>reference<sp/>get(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Extended_face_property_map&amp;<sp/>map,<sp/>key_type<sp/>key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>key-&gt;data();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>put<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>property<sp/>map<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>put(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Extended_face_property_map&amp;<sp/>map,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type<sp/>key,<sp/>value_type<sp/>val)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>key-&gt;set_data(val);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para><anchor id="index_1fig__aos_fig-bgl_dual_adapter"/> <image type="html" name="bgl_dual_adapter.png"></image>
 <image type="latex" name="bgl_dual_adapter.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aos_fig-bgl_dual_adapter" kindref="member">fig__aos_fig-bgl_dual_adapter</ref> An arrangement of seven line segments, as constructed by <ref refid="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_dual_adapter.cpp</ref> and its dual face graph, where every arrangement face is a vertex of the graph. The index of a dual vertex is the discovery time of a breadth-first search applied to the face graph, starting from the unbounded face <formula id="98">$f_0$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The following example constructs the same arrangement constructed by the program coded in <ref refid="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_primal_adapter.cpp</ref>; see <ref refid="index_1fig__aos_fig-bgl_primal_adapter" kindref="member">fig__aos_fig-bgl_primal_adapter</ref>. Then, it performs a breadth-first search traversal on the face graph, starting from the unbounded face. The DCEL faces are extended with an unsigned integer indicating the discovered time of the face. The code uses a visitor that obtains the times and writes them into a property map that updates the faces accordingly. <ref refid="index_1fig__aos_fig-bgl_dual_adapter" kindref="member">fig__aos_fig-bgl_dual_adapter</ref> shows the graph dual to the arrangement. It is clear that the unbounded face <formula id="98">$f_0$</formula> is discovered at time <formula id="195">$0$</formula>, the neighboring faces <formula id="2">$f_1$</formula>, <formula id="402">$f_3$</formula>, and <formula id="403">$f_4$</formula> are discovered at times <formula id="269">$1$</formula>, <formula id="64">$2$</formula>, and <formula id="306">$3$</formula>, and finally <formula id="3">$f_2$</formula> is discovered at time <formula id="132">$4$</formula>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example" kindref="compound">Arrangement_on_surface_2/bgl_dual_adapter.cpp</ref> <programlisting filename="Arrangement_on_surface_2/bgl_dual_adapter.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Adapting<sp/>the<sp/>dual<sp/>of<sp/>an<sp/>arrangement<sp/>to<sp/>a<sp/>BGL<sp/>graph.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/config.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/boost/graph/breadth_first_search.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/graph/visitors.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_extended_dcel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Arr_face_index_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;Extended_face_property_map.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_exact_construction_segments.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;arr_print.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dcel<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__extended__dcel" kindref="compound">CGAL::Arr_face_extended_dcel&lt;Traits, unsigned int&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Ex_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dual_arrangement<sp/>=<sp/><ref refid="classCGAL_1_1Dual" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">CGAL::Dual&lt;Ex_arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Face_index_map<sp/>=<sp/><ref refid="classCGAL_1_1Arr__face__index__map" kindref="compound">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Face_property_map<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Extended_face_property_map&lt;Ex_arrangement,unsigned<sp/>int&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>an<sp/>arrangement<sp/>of<sp/>seven<sp/>intersecting<sp/>line<sp/>segments.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>p1(1,<sp/>1),<sp/>p2(1,<sp/>4),<sp/>p3(2,<sp/>2),<sp/>p4(3,<sp/>7),<sp/>p5(4,<sp/>4),<sp/>p6(7,<sp/>1),<sp/>p7(9,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Ex_arrangement<sp/><sp/>arr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p1,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p1,<sp/>p4));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p2,<sp/>p6));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p3,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p3,<sp/>p5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p6,<sp/>p7));<sp/><sp/><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert</ref>(arr,<sp/>Segment(p4,<sp/>p7));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>mapping<sp/>of<sp/>the<sp/>arrangement<sp/>faces<sp/>to<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Face_index_map<sp/>index_map(arr);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>breadth-first<sp/>search<sp/>from<sp/>the<sp/>unbounded<sp/>face,<sp/>using<sp/>the<sp/>event</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>visitor<sp/>to<sp/>associate<sp/>each<sp/>arrangement<sp/>face<sp/>with<sp/>its<sp/>discover<sp/>time.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>time<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boost::breadth_first_search(Dual_arrangement(arr),<sp/>arr.unbounded_face(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::vertex_index_map(index_map).visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(boost::make_bfs_visitor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(stamp_times(Face_property_map(),<sp/>time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::on_discover_vertex()))));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>discover<sp/>time<sp/>of<sp/>each<sp/>arrangement<sp/>face.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fit<sp/>=<sp/>arr.faces_begin();<sp/>fit<sp/>!=<sp/>arr.faces_end();<sp/>++fit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Discover<sp/>time<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>fit-&gt;data()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>for<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fit<sp/>!=<sp/>arr.unbounded_face())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;face<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;the<sp/>unbounded<sp/>face.\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1aos_sec-tips">
<title>How To Speed Up Your Computation</title>
<para>Before the specific tips, we remind you that compiling programs with debug flags disabled and with optimization flags enabled significantly reduces the running time.</para>
<para><orderedlist>
<listitem>
<para>When the curves to be inserted into an arrangement are <formula id="7">$x$</formula>-monotone and pairwise disjoint in their interior to start with, then it is more efficient (in running time) and less demanding (in traits-class functionality) to use the non-intersecting insertion-functions instead of the general ones; e.g., <computeroutput><ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member">insert()</ref></computeroutput>.</para>
<para></para>
</listitem>
<listitem>
<para>When the curves to be inserted into an arrangement are segments that are pairwise disjoint in their interior, it is more efficient to use the traits class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> rather than the default one (<computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput>).</para>
<para>If the segments may intersect each other, the default traits class <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> can be safely used with the somehow limited number type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;MP_float&gt;</computeroutput>.</para>
<para>On rare occasions the traits class <computeroutput><ref refid="classCGAL_1_1Arr__non__caching__segment__traits__2" kindref="compound">Arr_non_caching_segment_traits_2</ref></computeroutput> exhibits slightly better performance than the default one (<computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">Arr_segment_traits_2</ref></computeroutput> even when the segments intersect each other, due to the small overhead of the latter (optimized) traits class. (For example, when the so-called LEDA rational kernel is used.)</para>
<para></para>
</listitem>
<listitem>
<para>Prior knowledge of the combinatorial structure of the arrangement can be used to accelerate operations that insert <formula id="7">$x$</formula>-monotone curves, whose interior is disjoint from existing edges and vertices of the arrangement. The specialized insertion functions, i.e., <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a622e04b98c5d0ac773c0a1b6da94b242" kindref="member">Arrangement_on_surface_2::insert_in_face_interior()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member">Arrangement_on_surface_2::insert_from_left_vertex()</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1f3b1ceca5219900301e4eefd9f80bd0" kindref="member">Arrangement_on_surface_2::insert_from_right_vertex()</ref></computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a7f2201fbb9015ddbbd22b7704e958e24" kindref="member">Arrangement_on_surface_2::insert_at_vertices()</ref></computeroutput> can be used according to the available information. These functions hardly involve any geometric operations, if at all. They accept topologically related parameters, and use them to operate directly on the DCEL records, thus saving algebraic operations, which are especially expensive when high-degree curves are involved.</para>
<para>A polygon, represented by a list of segments along its boundary, can be inserted into an empty arrangement as follows. First, one segment is inserted using <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a622e04b98c5d0ac773c0a1b6da94b242" kindref="member">Arrangement_on_surface_2::insert_in_face_interior()</ref></computeroutput> into the unbounded face. Then, a segment with a common end point is inserted using either <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5afb084b94adba3fa294724bd07ccb36" kindref="member">Arrangement_on_surface_2::insert_from_left_vertex()</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a1f3b1ceca5219900301e4eefd9f80bd0" kindref="member">Arrangement_on_surface_2::insert_from_right_vertex()</ref></computeroutput>, and so on with the rest of the segments except for the last, which is inserted using <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a7f2201fbb9015ddbbd22b7704e958e24" kindref="member">Arrangement_on_surface_2::insert_at_vertices()</ref></computeroutput>, as both endpoints of which are the mapping of known vertices.</para>
<para></para>
</listitem>
<listitem>
<para>The main trade-off among point-location strategies is between time and storage. Using the naive or walk strategies, for example, takes more query time but does not require preprocessing or maintenance of auxiliary structures and saves storage space.</para>
<para></para>
</listitem>
<listitem>
<para>If point-location queries are not performed frequently, but other modifying functions, such as removing, splitting, or merging edges are, then using a point-location strategy that does not require the maintenance of auxiliary structures, such as the naive or walk strategies, is preferable.</para>
<para></para>
</listitem>
<listitem>
<para>There is a trade-off between two modes of the trapezoidal RIC strategy that enables the user to choose whether preprocessing should be performed or not. If preprocessing is not used, the creation of the structure is faster. However, for some input sequences the structure might be unbalanced and therefore queries and updates might take longer, especially, if many removal and split operations are performed.</para>
<para></para>
</listitem>
<listitem>
<para>When the curves to be inserted into an arrangement are available in advance (as opposed to supplied on-line), it is advised to use the more efficient aggregate (sweep-based) insertion over the incremental insertion; e.g., <ref refid="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" kindref="member"><computeroutput>insert(arr, first, last)</computeroutput></ref>.</para>
<para></para>
</listitem>
<listitem>
<para>The various traits classes should be instantiated with an exact number type to ensure robustness when the input of the operations to be carried out might be degenerate. Inexact number types can be used at the user&apos;s own risk.</para>
<para></para>
</listitem>
<listitem>
<para>Maintaining short bit-lengths of coordinate representations may drastically decrease the time consumption of arithmetic operations on the coordinates. This can be achieved by caching certain information or normalization (of rational numbers). However, both solutions should be used cautiously, as the former may lead to an undue space consumption, and indiscriminate normalization may considerably slow down the overall process.</para>
<para></para>
</listitem>
<listitem>
<para>Geometric functions (e.g., traits methods) dominate the time consumption of most operations. Thus, calls to such function should be avoided or at least their number should be decreased, perhaps at the expense of increased combinatorial-function calls or increased space consumption. For example, repetition of geometric-function calls could be avoided by storing the results obtained by the first call, and reusing them when needed. </para>
</listitem>
</orderedlist>
</para>
</sect1>
<sect1 id="index_1aos_sec-design">
<title>Design and Implementation History</title>
<para>The code of this package is the result of a long development process. Initially (and until version 3.1), the code was spread among several components, namely, <computeroutput>Topological_map</computeroutput>, <computeroutput>Planar_map_2</computeroutput>, <computeroutput>Planar_map_with_intersections_2</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput>, that were developed by Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Sigal Raab, Ron Wein, Baruch Zukerman, and Tali Zvi.</para>
<para>In version 3.2, as part of the ACS project, the packages have gone through a major re-design, resulting in an improved and unified <emphasis>2D Arrangements</emphasis> package. The code of the new package was restructured and developed by Efi Fogel, Idit Haran, Ron Wein, and Baruch Zukerman. This version included for the first time a new geometry-traits class that handles circular and linear curves, and is based on the circular kernel. The circular kernel was developed by Monique Teillaud, Sylvain Pion, and Julien Hazebrouck.</para>
<para>Version 3.3 features arrangements of unbounded curves for the first time. The design and development of this feature required yet another restructuring of the entire package. All this was done by Eric Berberich, Efi Fogel, Dan Halperin, Ophir Setter, and Ron Wein. Michael Hemmer helped tuning up parts of the geometry-traits concept related to unbounded curves.</para>
<para>Version 3.7 introduced a geometry-traits class that handles planar algebraic curves of arbitrary degree. It was developed by Eric Berberich and Michael Kerber.</para>
<para>Version 3.9 introduced a new geometry-traits class that handles rational arcs. It was developed by Oren Salzman and Michael Hemmer. It replaced an old traits, which handled the same family of curves, developed by Ron Wein.</para>
<para>Version 4.1 introduces a revised implementation of the point location class via a randomized incremental construction of the trapezoidal map. The old class was implemented by Oren Nechushtan, while the revamp was done by Michal Kleinbort and Michael Hemmer. The new class adds support for unbounded curves and can now guarantee logarithmic query time in all cases. </para>
</sect1>
    </detaileddescription>
    <location file="Arrangement_on_surface_2.txt"/>
  </compounddef>
</doxygen>
