<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="group__PkgArrangementOnSurface2Funcs" kind="group">
    <compoundname>PkgArrangementOnSurface2Funcs</compoundname>
    <title>Free Functions</title>
    <innergroup refid="group__PkgArrangementOnSurface2Insert">CGAL::insert()</innergroup>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GeomTraitsA</type>
          </param>
          <param>
            <type>class GeomTraitsB</type>
          </param>
          <param>
            <type>class GeomTraitsRes</type>
          </param>
          <param>
            <type>class TopTraitsA</type>
          </param>
          <param>
            <type>class TopTraitsB</type>
          </param>
          <param>
            <type>class TopTraitsRes</type>
          </param>
          <param>
            <type>class <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_2&lt; GeomTraitsA, TopTraitsA &gt; &amp;arr1, const Arrangement_2&lt; GeomTraitsB, TopTraitsB &gt; &amp;arr2, Arrangement_2&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;arr_res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const Arrangement_2&lt; GeomTraitsA, TopTraitsA &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const Arrangement_2&lt; GeomTraitsB, TopTraitsB &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type>Arrangement_2&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;</type>
          <declname>arr_res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</para>
<para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para>
</simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="32" column="6" declfile="CGAL/Arr_overlay_2.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaddb9e44b14b27e4cf0c7bb26b27d8518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel1</type>
          </param>
          <param>
            <type>typename Dcel2</type>
          </param>
          <param>
            <type>typename ResDcel</type>
          </param>
          <param>
            <type>typename <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;arr1, const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;arr2, Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type>Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements with history <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement with history <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The function also constructs a consolidated set of curves that induce <computeroutput>res</computeroutput>.</para>
<para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</para>
<para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para>
</simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="67" column="6" declfile="CGAL/Arr_overlay_2.h" declline="67" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename <ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::decompose</definition>
        <argsstring>(const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, OutputIterator oi)</argsstring>
        <name>decompose</name>
        <qualifiedname>CGAL::decompose</qualifiedname>
        <param>
          <type>const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>produces the symbolic vertical decomposition of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>More precisely, this function performs a batched vertical ray-shooting query from every arrangement vertex, and pairs each vertex with a pair of polymorphic objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it.</para>
<para>The finite arrangement vertices and the features they &quot;see&quot;, if exist, that are, the query results, are inserted in ascending <formula id="29">$xy$</formula>-lexicographic order (of the query vertex) into an output container given through an output iterator. If the vertex is the top end-vertex of a vertical edge, we say that there is no feature below it; similarly, if it is the bottom end-vertex of a vertical edge, we say that there is no feature above it. Each feature, if exists, is represented by a discriminated union container that holds an object of one of the following types:</para>
<para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member">Arrangement_on_surface_2::Halfedge_const_handle</ref></computeroutput>, if the vertex is located above (or below) an edge. The given halfedge is always directed from right to left. In case there is no concrete edge below (or above) the vertex, and the arrangement is unbounded, then the object returned is a <emphasis>fictitious</emphasis> halfedge. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member">Arrangement_on_surface_2::Face_const_handle</ref></computeroutput>, in case there is no edge below (or above) the vertex, and the arrangement is bounded. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref></computeroutput>, in case the vertex is located vertically above (or below) another arrangement vertex. </para>
</listitem>
</itemizedlist>
</para>
<para>The output of this function can be readily used for inserting vertical walls and physically decomposing the arrangement into pseudo-trapezoids.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>The arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oi</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator that points at the output container. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The past-the-end iterator of the output container.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><simplesect kind="pre"><para>Dereferencing <computeroutput>oi</computeroutput> must yield an object of type <computeroutput>std::pair&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref>, std::pair&lt;std::optional&lt;Type,std::optional&lt;Type&gt;&gt;&gt;</computeroutput>, where <computeroutput>Type</computeroutput> is <computeroutput>std::variant&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member">Arrangement_on_surface_2::Halfedge_const_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member">Arrangement_on_surface_2::Face_const_handle</ref>&gt;</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_vertical_decomposition_2.h" line="49" column="1" declfile="CGAL/Arr_vertical_decomposition_2.h" declline="49" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_non_intersecting_curve</name>
        <qualifiedname>CGAL::insert_non_intersecting_curve</qualifiedname>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given <formula id="211">$ x$</formula>-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges. </para>
        </briefdescription>
        <detaileddescription>
<para>Under this assumption, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges, and the function returns a handle for the one directed lexicographically in increasing order (from left to right).</para>
<para>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the &quot;walk
along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the restricted <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput> must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="257" column="1" declfile="CGAL/Arrangement_2.h" declline="257" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert_non_intersecting_curves</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert_non_intersecting_curves</name>
        <qualifiedname>CGAL::insert_non_intersecting_curves</qualifiedname>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts a set of <formula id="211">$ x$</formula>-monotone curves in a given range into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The insertion is performed in an aggregated manner, using the sweep-line algorithm. The input curves should be pairwise disjoint in their interior and pairwise interior-disjoint from all existing arrangement vertices and edges.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para><computeroutput>InputIterator::value_type</computeroutput> must be <computeroutput>Traits::X_monotone_curve_2</computeroutput> </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="278" column="6" declfile="CGAL/Arrangement_2.h" declline="278" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gabfaca749e7d8c9547c143032a0e9df08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle CGAL::insert_point</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_point</name>
        <qualifiedname>CGAL::insert_point</qualifiedname>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given point into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>. In either case, the function returns a handle for the vertex associated with the point.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, and support the splitting functionality. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="308" column="1" declfile="CGAL/Arrangement_2.h" declline="308" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gabcb9bc6c5859edf3fbc1390e60e32a17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>is_valid</name>
        <qualifiedname>CGAL::is_valid</qualifiedname>
        <param>
          <type>const Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Checks the validity of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Invokes the member function <computeroutput>arr.is_valid()</computeroutput> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all <formula id="211">$ x$</formula>-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para>The instantiated traits class must model the concept <computeroutput>ArranagmentXMonotoneTraits_2</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="331" column="6" declfile="CGAL/Arrangement_2.h" declline="331" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>Arrangement_2&lt; Traits, Dcel &gt;::Face_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Face_handle CGAL::remove_edge</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle e)</argsstring>
        <name>remove_edge</name>
        <qualifiedname>CGAL::remove_edge</qualifiedname>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <computeroutput>remove_edge(arr, e)</computeroutput> is equivalent to the call <computeroutput>arr.remove_edge (e, true, true)</computeroutput>. However, this free function requires that <computeroutput>Traits</computeroutput> be a model of the refined concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which requires merge operations on <formula id="211">$ x$</formula>-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated traits class must model the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="357" column="1" declfile="CGAL/Arrangement_2.h" declline="357" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::remove_vertex</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle v)</argsstring>
        <name>remove_vertex</name>
        <qualifiedname>CGAL::remove_vertex</qualifiedname>
        <param>
          <type>Arrangement_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Attempts to removed a given vertex from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <emphasis>redundant</emphasis> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single <formula id="453">$
x$</formula>-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and support the merging functionality. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="379" column="6" declfile="CGAL/Arrangement_2.h" declline="379" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga7598937d11570bdedd5f3b6491065940" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename Curve</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::do_intersect</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl)</argsstring>
        <name>do_intersect</name>
        <qualifiedname>CGAL::do_intersect</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const Curve &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>Checks if a given curve or <formula id="7">$x$</formula>-monotone curve intersects an existing arrangement&apos;s edges or vertices. </para>
        </briefdescription>
        <detaileddescription>
<para>If the give curve is not an <formula id="7">$x$</formula>-monotone curve then the function subdivides the given curve into <formula id="211">$ x$</formula>-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve&apos;s left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement&apos;s edge/vertex is found or when the right endpoint is reached.</para>
<para>A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>.</para>
<para>Checks if the given curve or <formula id="211">$ x$</formula>-monotone curve <computeroutput>c</computeroutput> intersects edges or vertices of the existing arrangement <computeroutput>arr</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>If <computeroutput>c</computeroutput> is <formula id="211">$ x$</formula>-monotone then the instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. If <computeroutput>c</computeroutput> is a curve then the instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept. That is, it should define the <computeroutput>Curve_2</computeroutput> type, and support its subdivision into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1126" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1126" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad2c812247ce5c1dd592c0e0be74a1fc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_non_intersecting_curve</name>
        <qualifiedname>CGAL::insert_non_intersecting_curve</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given <formula id="211">$ x$</formula>-monotone curve into a given arrangement, where the given curve and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interior of the input curve must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). </para>
        </briefdescription>
        <detaileddescription>
<para>Under this condition, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges. The function returns a handle to the one directed lexicographically in increasing order (from left to right).</para>
<para>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the &quot;walk
along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the restricted <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput> must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1163" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1163" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gab168a4f4aa766c5bd670d82f4793f16d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename <ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert_non_intersecting_curves</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert_non_intersecting_curves</name>
        <qualifiedname>CGAL::insert_non_intersecting_curves</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts a set of <formula id="211">$ x$</formula>-monotone curves in a given range into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The insertion is performed in an aggregated manner using the sweep-line algorithm. The input curves and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interiors of the input curves must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). The insertion operations creates exactly one new edge, that is, two twin halfedges, for every input curve.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para><computeroutput>InputIterator::value_type</computeroutput> must be <computeroutput>Traits::X_monotone_curve_2</computeroutput> </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1189" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1189" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga20598ef738aed142f32617212dc861d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle CGAL::insert_point</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_point</name>
        <qualifiedname>CGAL::insert_point</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given point into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>. In either case, the function returns a handle for the vertex associated with the point.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, and support the splitting functionality. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1223" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1223" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gafd685214e9dcdfe2186b4d9b7f76f37e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr)</argsstring>
        <name>is_valid</name>
        <qualifiedname>CGAL::is_valid</qualifiedname>
        <param>
          <type>const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Checks the validity of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Invokes the member function <computeroutput>arr.is_valid()</computeroutput> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all <formula id="211">$ x$</formula>-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para>The instantiated traits class must model the concept <computeroutput>ArranagmentXMonotoneTraits_2</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1246" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1246" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaaa3cb37bae2483e238ede133951e3088" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Face_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Face_handle CGAL::remove_edge</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle e)</argsstring>
        <name>remove_edge</name>
        <qualifiedname>CGAL::remove_edge</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <computeroutput>remove_edge(arr, e)</computeroutput> is equivalent to the call <computeroutput>arr.remove_edge (e, true, true)</computeroutput>. However, this free function requires that <computeroutput>Traits</computeroutput> be a model of the refined concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which requires merge operations on <formula id="211">$ x$</formula>-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated traits class must model the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1273" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1273" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga5eca39557780532185639e02ce4ecf83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::remove_vertex</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle v)</argsstring>
        <name>remove_vertex</name>
        <qualifiedname>CGAL::remove_vertex</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Attempts to removed a given vertex from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <emphasis>redundant</emphasis> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single <formula id="453">$
x$</formula>-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and support the merging functionality. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1297" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1297" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga52ccca744c113ea53ae30cdf6c70b295" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename <ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
        <definition>OutputIterator CGAL::zone</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename GeometryTraits::X_monotone_curve_2 &amp;c, OutputIterator oi, const PointLocation &amp;pl)</argsstring>
        <name>zone</name>
        <qualifiedname>CGAL::zone</qualifiedname>
        <param>
          <type>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename GeometryTraits::X_monotone_curve_2 &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref></type>
          <declname>oi</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>computes the zone of the given <formula id="7">$x$</formula>-monotone curve in a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>More precisely, this function finds the arrangement vertices, edges ,and faces that the given <formula id="7">$x$</formula>-monotone curve intersects, and inserts them in the order they are discovered when traversing the <formula id="7">$x$</formula>-monotone curve from left to right into an output contaiuner given through an output iterator. An object in the resulting zone is represented by a discriminated union container that holds a vertex handle, halfedge handle, or a face handle.</para>
<para>A given point-location object is used for answering point-location queries during the insertion process. By default, the function uses the &quot;walk along
line&quot; point-location strategy, namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt;&gt;</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>The given arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The <formula id="7">$x$</formula>-monotone curve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oi</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator that points at the output container. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pl</parametername>
</parameternamelist>
<parameterdescription>
<para>The point-location object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The past-the-end iterator of the output container.</para>
</simplesect>
<simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para>The instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. </para>
</simplesect>
<simplesect kind="pre"><para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</simplesect>
<simplesect kind="pre"><para>Dereferencing <computeroutput>oi</computeroutput> must yield a polymorphic object of type <computeroutput>std::variant&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member">Arrangement_on_surface_2::Vertex_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaae449ff521205c5ba837143c431d3d3" kindref="member">Arrangement_on_surface_2::Halfedge_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5c97d46fc76cf9ab96ceced3b795b3c9" kindref="member">Arrangement_on_surface_2::Face_handle</ref>&gt;</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1337" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1337" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaa323bd67be0dc7cc326eb4f26653e326" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>Size</type>
        <definition>Size CGAL::remove_curve</definition>
        <argsstring>(Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle ch)</argsstring>
        <name>remove_curve</name>
        <qualifiedname>CGAL::remove_curve</qualifiedname>
        <param>
          <type>Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
<para>Removes a given curve from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The curve is specified by its handle <computeroutput>ch</computeroutput>, from the arrangement <computeroutput>arr</computeroutput>, by deleting all the edges it induces. The function returns the number of deleted edges. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="260" column="6" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="260" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga9a27533ff4ade0c60978812e517b89d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>Size</type>
        <definition>Size CGAL::remove_curve</definition>
        <argsstring>(Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle ch)</argsstring>
        <name>remove_curve</name>
        <qualifiedname>CGAL::remove_curve</qualifiedname>
        <param>
          <type>Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
<para>Removes a given curvespecified by its handle <computeroutput>ch</computeroutput>, from a given arrangement <computeroutput>arr</computeroutput>, deleting all the edges it induces. </para>
        </briefdescription>
        <detaileddescription>
<para>The function returns the number of deleted edges. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="161" column="6" declfile="CGAL/Arrangement_with_history_2.h" declline="161" declcolumn="6"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
