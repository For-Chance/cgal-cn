<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="classCGAL_1_1Aos__observer" prot="public">CGAL::Aos_observer</innerclass>
    <innerclass refid="classCGAL_1_1Arr__accessor" prot="public">CGAL::Arr_accessor</innerclass>
    <innerclass refid="classCGAL_1_1Arr__algebraic__segment__traits__2" prot="public">CGAL::Arr_algebraic_segment_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__Bezier__curve__traits__2" prot="public">CGAL::Arr_Bezier_curve_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__bounded__planar__topology__traits__2" prot="public">CGAL::Arr_bounded_planar_topology_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__circle__segment__traits__2" prot="public">CGAL::Arr_circle_segment_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__circular__arc__traits__2" prot="public">CGAL::Arr_circular_arc_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__circular__line__arc__traits__2" prot="public">CGAL::Arr_circular_line_arc_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Arr__closed__side__tag" prot="public">CGAL::Arr_closed_side_tag</innerclass>
    <innerclass refid="classCGAL_1_1Arr__conic__traits__2" prot="public">CGAL::Arr_conic_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__consolidated__curve__data__traits__2" prot="public">CGAL::Arr_consolidated_curve_data_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Arr__contracted__side__tag" prot="public">CGAL::Arr_contracted_side_tag</innerclass>
    <innerclass refid="classCGAL_1_1Arr__curve__data__traits__2" prot="public">CGAL::Arr_curve_data_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__dcel" prot="public">CGAL::Arr_dcel</innerclass>
    <innerclass refid="classCGAL_1_1Arr__dcel__base" prot="public">CGAL::Arr_dcel_base</innerclass>
    <innerclass refid="classCGAL_1_1Arr__default__overlay__traits" prot="public">CGAL::Arr_default_overlay_traits</innerclass>
    <innerclass refid="classCGAL_1_1Arr__extended__dcel" prot="public">CGAL::Arr_extended_dcel</innerclass>
    <innerclass refid="classCGAL_1_1Arr__extended__dcel__text__formatter" prot="public">CGAL::Arr_extended_dcel_text_formatter</innerclass>
    <innerclass refid="classCGAL_1_1Arr__extended__face" prot="public">CGAL::Arr_extended_face</innerclass>
    <innerclass refid="classCGAL_1_1Arr__extended__halfedge" prot="public">CGAL::Arr_extended_halfedge</innerclass>
    <innerclass refid="classCGAL_1_1Arr__extended__vertex" prot="public">CGAL::Arr_extended_vertex</innerclass>
    <innerclass refid="classCGAL_1_1Arr__face__extended__dcel" prot="public">CGAL::Arr_face_extended_dcel</innerclass>
    <innerclass refid="classCGAL_1_1Arr__face__extended__text__formatter" prot="public">CGAL::Arr_face_extended_text_formatter</innerclass>
    <innerclass refid="classCGAL_1_1Arr__face__index__map" prot="public">CGAL::Arr_face_index_map</innerclass>
    <innerclass refid="classCGAL_1_1Arr__face__overlay__traits" prot="public">CGAL::Arr_face_overlay_traits</innerclass>
    <innerclass refid="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2" prot="public">CGAL::Arr_geodesic_arc_on_sphere_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Arr__identified__side__tag" prot="public">CGAL::Arr_identified_side_tag</innerclass>
    <innerclass refid="classCGAL_1_1Arr__landmarks__point__location" prot="public">CGAL::Arr_landmarks_point_location</innerclass>
    <innerclass refid="classCGAL_1_1Arr__line__arc__traits__2" prot="public">CGAL::Arr_line_arc_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__linear__traits__2" prot="public">CGAL::Arr_linear_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__naive__point__location" prot="public">CGAL::Arr_naive_point_location</innerclass>
    <innerclass refid="classCGAL_1_1Arr__non__caching__segment__basic__traits__2" prot="public">CGAL::Arr_non_caching_segment_basic_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__non__caching__segment__traits__2" prot="public">CGAL::Arr_non_caching_segment_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Arr__oblivious__side__tag" prot="public">CGAL::Arr_oblivious_side_tag</innerclass>
    <innerclass refid="structCGAL_1_1Arr__open__side__tag" prot="public">CGAL::Arr_open_side_tag</innerclass>
    <innerclass refid="structCGAL_1_1Arr__point__location__result" prot="public">CGAL::Arr_point_location_result</innerclass>
    <innerclass refid="classCGAL_1_1Arr__polycurve__traits__2" prot="public">CGAL::Arr_polycurve_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__polyline__traits__2" prot="public">CGAL::Arr_polyline_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__rational__function__traits__2" prot="public">CGAL::Arr_rational_function_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__segment__traits__2" prot="public">CGAL::Arr_segment_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__spherical__topology__traits__2" prot="public">CGAL::Arr_spherical_topology_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__text__formatter" prot="public">CGAL::Arr_text_formatter</innerclass>
    <innerclass refid="classCGAL_1_1Arr__trapezoid__ric__point__location" prot="public">CGAL::Arr_trapezoid_ric_point_location</innerclass>
    <innerclass refid="classCGAL_1_1Arr__triangulation__point__location" prot="public">CGAL::Arr_triangulation_point_location</innerclass>
    <innerclass refid="classCGAL_1_1Arr__unb__planar__topology__traits__2" prot="public">CGAL::Arr_unb_planar_topology_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Arr__vertex__index__map" prot="public">CGAL::Arr_vertex_index_map</innerclass>
    <innerclass refid="classCGAL_1_1Arr__walk__along__line__point__location" prot="public">CGAL::Arr_walk_along_line_point_location</innerclass>
    <innerclass refid="classCGAL_1_1Arr__with__history__text__formatter" prot="public">CGAL::Arr_with_history_text_formatter</innerclass>
    <innerclass refid="classCGAL_1_1Arrangement__2" prot="public">CGAL::Arrangement_2</innerclass>
    <innerclass refid="classCGAL_1_1Arrangement__on__surface__2" prot="public">CGAL::Arrangement_on_surface_2</innerclass>
    <innerclass refid="classCGAL_1_1Arrangement__on__surface__with__history__2" prot="public">CGAL::Arrangement_on_surface_with_history_2</innerclass>
    <innerclass refid="classCGAL_1_1Arrangement__with__history__2" prot="public">CGAL::Arrangement_with_history_2</innerclass>
    <innerclass refid="classCGAL_1_1CORE__algebraic__number__traits" prot="public">CGAL::CORE_algebraic_number_traits</innerclass>
    <innernamespace refid="namespaceCGAL_1_1IO">CGAL::IO</innernamespace>
      <sectiondef kind="user-defined">
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gaf7d5aac2640c2a706f8c5e6adc8a7e94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename Curve</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const Curve &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>The function <computeroutput>insert</computeroutput> inserts one or more curves or <formula id="211">$ x$</formula>-monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. </para>
        </briefdescription>
        <detaileddescription>
<para>If an inserted curve is not <formula id="211">$ x$</formula>-monotone curve, it is subdivided into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points), which are inserted into the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>If the curve is <formula id="211">$ x$</formula>-monotone curve then The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. In case that the curve is not <formula id="211">$ x$</formula>-monotone then the instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept. That is, it should define the <computeroutput>Curve_2</computeroutput> type, and support its subdivision into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
<para>Inserts the given curve <computeroutput>c</computeroutput> into the arrangement <computeroutput>arr</computeroutput>. <computeroutput>c</computeroutput> is subdivided into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). Each subcurve is in turn inserted into the arrangement by locating its left endpoint and computing its zone until reaching the right endpoint.</para>
<para>The given point-location object <computeroutput>pl</computeroutput> is used to locate the left endpoints of the <formula id="211">$ x$</formula>-monotone curves. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="200" column="6" declfile="CGAL/Arrangement_2.h" declline="200" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gaa4baa0868abeacbece3ff3a0a7d9d2ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, typename Arr_point_location_result&lt; Arrangement_2&lt; Traits, Dcel &gt; &gt;::type obj)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>typename <ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt; <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &gt;::type</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Inserts the<emphasis> <formula id="211">$ x$</formula>-monotone (only)</emphasis> curve <computeroutput>xc</computeroutput> into the arrangement <computeroutput>arr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The object <computeroutput>obj</computeroutput>, which wraps a <computeroutput>Vertex_const_handle</computeroutput>, a <computeroutput>Halfedge_const_handle</computeroutput>, or a <computeroutput>Face_const_handle</computeroutput>, represents the location of <computeroutput>xc</computeroutput>&apos;s left endpoint in the arrangement. The zone of <computeroutput>xc</computeroutput> is computed starting from the feature represented by <computeroutput>obj</computeroutput>. As in the case above, the zone computation terminates, when the right endpoint is reached. Thus, point-location is not required. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="212" column="6" declfile="CGAL/Arrangement_2.h" declline="212" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1ga25a2ae72727ec4c0680d20477bab7a1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Aggregately inserts the curves or <formula id="211">$ x$</formula>-monotone curves in the range <computeroutput>[first,last)</computeroutput> into the arrangement <computeroutput>arr</computeroutput> using the sweep-line framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the target arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator to the first element in the range of curves. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>the past-the-end iterator of the range of curves. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="223" column="6" declfile="CGAL/Arrangement_2.h" declline="223" declcolumn="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gae2a4543bc562996f3d38832a95d52c42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename Curve</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const Curve &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>The function <computeroutput>insert</computeroutput> inserts one or more curves or <formula id="211">$ x$</formula>-monotone curves into a given arrangement, where no restrictions are imposed on the inserted curves. </para>
        </briefdescription>
        <detaileddescription>
<para>If an inserted curve is not <formula id="211">$ x$</formula>-monotone curve, it is subdivided into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points), which are inserted into the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>If the curve is <formula id="211">$ x$</formula>-monotone curve then The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. In case that the curve is not <formula id="211">$ x$</formula>-monotone then the instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept. That is, it should define the <computeroutput>Curve_2</computeroutput> type, and support its subdivision into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
<para>Inserts the given curve <computeroutput>c</computeroutput> into the arrangement <computeroutput>arr</computeroutput>. <computeroutput>c</computeroutput> is subdivided into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). Each subcurve is in turn inserted into the arrangement by locating its left endpoint and computing its zone until reaching the right endpoint.</para>
<para>The given point-location object <computeroutput>pl</computeroutput> is used to locate the left endpoints of the <formula id="211">$ x$</formula>-monotone curves. By default, the function uses the &quot;walk along
line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1054" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1054" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gaedfedb7d7a927c18cdc3b68aa31ec8ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, typename Arr_point_location_result&lt; Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &gt;::type obj)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>typename <ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt; <ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &gt;::type</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Inserts the<emphasis> <formula id="211">$ x$</formula>-monotone (only)</emphasis> curve <computeroutput>xc</computeroutput> into the arrangement <computeroutput>arr</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The object <computeroutput>obj</computeroutput>, which wraps a <computeroutput>Vertex_const_handle</computeroutput>, a <computeroutput>Halfedge_const_handle</computeroutput>, or a <computeroutput>Face_const_handle</computeroutput>, represents the location of <computeroutput>xc</computeroutput>&apos;s left endpoint in the arrangement. The zone of <computeroutput>xc</computeroutput> is computed starting from the feature represented by <computeroutput>obj</computeroutput>. As in the case above, the zone computation terminates, when the right endpoint is reached. Thus, point-location is not required. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1067" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1067" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gac3bf533850fb20111cead96b11f162bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Aggregately inserts the curves or <formula id="211">$ x$</formula>-monotone curves in the range <computeroutput>[first,last)</computeroutput> into the arrangement <computeroutput>arr</computeroutput> using the sweep-line framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the target arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator to the first element in the range of curves. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>the past-the-end iterator of the range of curves. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1080" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1080" declcolumn="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__PkgArrangementOnSurface2Enums_1ga29246893be4be2ad9a8fbc249f49f0b5" prot="public" static="no" strong="no">
        <type></type>
        <name>Arr_curve_end</name>
        <qualifiedname>CGAL::Arr_curve_end</qualifiedname>
        <enumvalue id="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88" prot="public">
          <name>ARR_MIN_END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgArrangementOnSurface2Enums_1gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce" prot="public">
          <name>ARR_MAX_END</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>The enumeration <computeroutput>Arr_curve_end</computeroutput> is used to indicate one of the two ends of an <formula id="7">$x$</formula>-monotone curve. </para>
        </briefdescription>
        <detaileddescription>
<para>It is used by models geometry traits concept that handle boundary conditions.</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="classArrangementOpenBoundaryTraits__2" kindref="compound">ArrangementOpenBoundaryTraits_2</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="11" column="1" bodyfile="CGAL/Arr_enums.h" bodystart="11" bodyend="11"/>
      </memberdef>
      <memberdef kind="enum" id="group__PkgArrangementOnSurface2Enums_1ga92ec015604dd1aab753c009565fd28d0" prot="public" static="no" strong="no">
        <type></type>
        <name>Arr_halfedge_direction</name>
        <qualifiedname>CGAL::Arr_halfedge_direction</qualifiedname>
        <enumvalue id="group__PkgArrangementOnSurface2Enums_1gga92ec015604dd1aab753c009565fd28d0acd7482855e300ef8d05409913808b64d" prot="public">
          <name>ARR_LEFT_TO_RIGHT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__PkgArrangementOnSurface2Enums_1gga92ec015604dd1aab753c009565fd28d0a10f2cdb5a28163cc1e237914cc4bdcef" prot="public">
          <name>ARR_RIGHT_TO_LEFT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>The enumeration <computeroutput>Arr_halfedge_direction</computeroutput> is defined by <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a4f034d310002a73e70761392024d0d97" kindref="member">CGAL::Arrangement_2::Halfedge</ref></computeroutput> to specify the direction of the halfedge. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a4f034d310002a73e70761392024d0d97" kindref="member">CGAL::Arrangement_2::Halfedge</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="22" column="1" bodyfile="CGAL/Arr_enums.h" bodystart="22" bodyend="22"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__PkgArrangementOnSurface2DCEL_1gaf9635869a3794a46d7dcfce63d7de2a6" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arr__dcel" kindref="compound">Arr_dcel</ref>&lt; Traits &gt;</type>
        <definition>using CGAL::Arr_default_dcel = typedef Arr_dcel&lt;Traits&gt;</definition>
        <argsstring></argsstring>
        <name>Arr_default_dcel</name>
        <qualifiedname>CGAL::Arr_default_dcel</qualifiedname>
        <briefdescription>
<para>The default DCEL class used by the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__bounded__planar__topology__traits__2" kindref="compound">Arr_bounded_planar_topology_traits_2</ref></computeroutput>, <computeroutput><ref refid="classCGAL_1_1Arr__unb__planar__topology__traits__2" kindref="compound">Arr_unb_planar_topology_traits_2</ref></computeroutput> class templates and other templates. </para>
        </briefdescription>
        <detaileddescription>
<para>It is parameterized by a geometry traits type. It uses the <ref refid="classArrangementBasicTraits__2_1a8cfc873dc62ce86f9479c4689845d4b3" kindref="member"><computeroutput>Point_2</computeroutput></ref> and <ref refid="classArrangementBasicTraits__2_1a0fc1f7acfd69a5eae393294b6870a1d2" kindref="member"><computeroutput>X_monotone_curve_2</computeroutput></ref> types nested in the traits type to instantiate the vertex and base halfedge types, respectively. Thus, by default the DCEL only stores the topological incidence relations and the geometric data attached to vertices and edges.</para>
<para><variablelist>
<varlistentry><term>Is model of</term></varlistentry>
<listitem><para><computeroutput><ref refid="classArrangementDcelWithRebind" kindref="compound">ArrangementDcelWithRebind</ref></computeroutput> </para>
</listitem>
</variablelist>
</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>a geometry traits type, which is a model of the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Arr__dcel" kindref="compound">Arr_dcel</ref>&lt;Traits, V, H, F&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Arr__dcel__base" kindref="compound">Arr_dcel_base</ref>&lt;V, H, F&gt;</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_default_dcel.h" line="23" column="13" bodyfile="CGAL/Arr_default_dcel.h" bodystart="23" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" prot="public" static="no">
        <type>Box_parameter_space_2</type>
        <definition>typedef Box_parameter_space_2 CGAL::Arr_parameter_space</definition>
        <argsstring></argsstring>
        <name>Arr_parameter_space</name>
        <qualifiedname>CGAL::Arr_parameter_space</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="27" column="31" bodyfile="CGAL/Arr_enums.h" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__PkgArrangementOnSurface2Ref_1ga8019f986f5469920136c4b92290b7b1b" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename Arrangement_</type>
          </param>
        </templateparamlist>
        <type>typename Arrangement_::Observer</type>
        <definition>using CGAL::Arr_observer = typedef typename Arrangement_::Observer</definition>
        <argsstring></argsstring>
        <name>Arr_observer</name>
        <qualifiedname>CGAL::Arr_observer</qualifiedname>
        <briefdescription>
<para><computeroutput>Arr_observer&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;</computeroutput> is an alias for Aos_observer&lt;Arrangement_on_surface_2&gt;<computeroutput>, where</computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref><computeroutput>derives from</computeroutput>Arrangement_on_surface_2` and the latter is an instance of the template <computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">CGAL::Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt;</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_observer.h" line="13" column="1" bodyfile="CGAL/Arr_observer.h" bodystart="13" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__PkgArrangementOnSurface2Enums_1ga2bbdd8004c0a37409305b01cf7fc2563" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" kindref="member">Arr_parameter_space</ref></type>
        <definition>const Arr_parameter_space CGAL::ARR_LEFT_BOUNDARY</definition>
        <argsstring></argsstring>
        <name>ARR_LEFT_BOUNDARY</name>
        <qualifiedname>CGAL::ARR_LEFT_BOUNDARY</qualifiedname>
        <initializer>= LEFT_BOUNDARY</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="32" column="27" bodyfile="CGAL/Arr_enums.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgArrangementOnSurface2Enums_1ga341fb5c90e8037d651012f955e38fda1" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" kindref="member">Arr_parameter_space</ref></type>
        <definition>const Arr_parameter_space CGAL::ARR_RIGHT_BOUNDARY</definition>
        <argsstring></argsstring>
        <name>ARR_RIGHT_BOUNDARY</name>
        <qualifiedname>CGAL::ARR_RIGHT_BOUNDARY</qualifiedname>
        <initializer>= RIGHT_BOUNDARY</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="37" column="27" bodyfile="CGAL/Arr_enums.h" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgArrangementOnSurface2Enums_1gaf276ca43e83c8791923154aba4584651" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" kindref="member">Arr_parameter_space</ref></type>
        <definition>const Arr_parameter_space CGAL::ARR_BOTTOM_BOUNDARY</definition>
        <argsstring></argsstring>
        <name>ARR_BOTTOM_BOUNDARY</name>
        <qualifiedname>CGAL::ARR_BOTTOM_BOUNDARY</qualifiedname>
        <initializer>= BOTTOM_BOUNDARY</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="42" column="27" bodyfile="CGAL/Arr_enums.h" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgArrangementOnSurface2Enums_1gaf8d89294c23614f33351e94ff28e0d59" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" kindref="member">Arr_parameter_space</ref></type>
        <definition>const Arr_parameter_space CGAL::ARR_TOP_BOUNDARY</definition>
        <argsstring></argsstring>
        <name>ARR_TOP_BOUNDARY</name>
        <qualifiedname>CGAL::ARR_TOP_BOUNDARY</qualifiedname>
        <initializer>= TOP_BOUNDARY</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="47" column="27" bodyfile="CGAL/Arr_enums.h" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__PkgArrangementOnSurface2Enums_1gad93bd71ee623a2e4fded635967e9c8d2" prot="public" static="no" mutable="no">
        <type>const <ref refid="group__PkgArrangementOnSurface2Enums_1ga118afacd6b8f9fae5e992b5b2845dd9d" kindref="member">Arr_parameter_space</ref></type>
        <definition>const Arr_parameter_space CGAL::ARR_INTERIOR</definition>
        <argsstring></argsstring>
        <name>ARR_INTERIOR</name>
        <qualifiedname>CGAL::ARR_INTERIOR</qualifiedname>
        <initializer>= INTERIOR</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_enums.h" line="52" column="29" bodyfile="CGAL/Arr_enums.h" bodystart="52" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgArrangementOnSurface2PointLocation_1ga278df8e4d85dcb6bf3dfa35e251a706e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename InputIterator</type>
          </param>
          <param>
            <type>typename OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::locate</definition>
        <argsstring>(const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator begin, InputIterator end, OutputIterator oi)</argsstring>
        <name>locate</name>
        <qualifiedname>CGAL::locate</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>end</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>performs a batched point-location operation on a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>It accepts a collection of query points, locates each point in a given arrangement, and inserts the query results into an output container given through an output iterator. Each query result is given as a pair of the query point and an object representing the arrangement feature that contains it, namely a discriminated union container of the types <computeroutput>Face_const_handle</computeroutput>, <computeroutput>Halfedge_const_handle</computeroutput>, and <computeroutput>Vertex_const_hanlde</computeroutput>. The resulting pairs in the output container are sorted in increasing <formula id="29">$xy$</formula>-lexicographical order of the query points.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>The arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The begin iterator of the container of input points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The past-the-end iterator of the container of input points. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oi</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator that points at the output container. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The past-the-end iterator of the output container.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><simplesect kind="pre"><para>The value type of <computeroutput>InputIterator</computeroutput> must be convertible to <computeroutput><ref refid="classCGAL_1_1Arrangement__2_1a37ea0b27d161923f5d3a2289a3905d15" kindref="member">Arrangement_2::Point_2</ref></computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para>Dereferencing <computeroutput>oi</computeroutput> must yield an object convertible to <computeroutput>std::pair&lt;<ref refid="classCGAL_1_1Arrangement__2_1a37ea0b27d161923f5d3a2289a3905d15" kindref="member">Arrangement_2::Point_2</ref>, <ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">Arr_point_location_result</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&gt;::Type&gt;</computeroutput>.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Arr__point__location__result" kindref="compound">CGAL::Arr_point_location_result</ref>&lt;Arrangement&gt;</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_batched_point_location.h" line="33" column="16" declfile="CGAL/Arr_batched_point_location.h" declline="33" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga339cdba93f54001be303595689002396" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GeomTraitsA</type>
          </param>
          <param>
            <type>class GeomTraitsB</type>
          </param>
          <param>
            <type>class GeomTraitsRes</type>
          </param>
          <param>
            <type>class TopTraitsA</type>
          </param>
          <param>
            <type>class TopTraitsB</type>
          </param>
          <param>
            <type>class TopTraitsRes</type>
          </param>
          <param>
            <type>class <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_2&lt; GeomTraitsA, TopTraitsA &gt; &amp;arr1, const Arrangement_2&lt; GeomTraitsB, TopTraitsB &gt; &amp;arr2, Arrangement_2&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;arr_res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeomTraitsA, TopTraitsA &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeomTraitsB, TopTraitsB &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;</type>
          <declname>arr_res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</para>
<para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para>
</simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="32" column="6" declfile="CGAL/Arr_overlay_2.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaddb9e44b14b27e4cf0c7bb26b27d8518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel1</type>
          </param>
          <param>
            <type>typename Dcel2</type>
          </param>
          <param>
            <type>typename ResDcel</type>
          </param>
          <param>
            <type>typename <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;arr1, const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;arr2, Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel2 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, ResDcel &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
<para>Computes the overlay of two arrangements with history <computeroutput>arr1</computeroutput> and <computeroutput>arr2</computeroutput>, and sets the output arrangement with history <computeroutput>res</computeroutput> to represent the overlaid arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The function also constructs a consolidated set of curves that induce <computeroutput>res</computeroutput>.</para>
<para>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <computeroutput>Traits::Point_2</computeroutput>, <computeroutput>Traits::Curve_2</computeroutput>, and <computeroutput>Traits::Point_2</computeroutput>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</para>
<para><simplesect kind="pre"><para><computeroutput>res</computeroutput> does not refer to either <computeroutput>arr1</computeroutput> or <computeroutput>arr2</computeroutput> (that is, &quot;self overlay&quot; is not supported).</para>
</simplesect>
<simplesect kind="pre"><para>The overlay-traits object <computeroutput>ovl_tr</computeroutput> must model the <computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> concept, which is able to construct records of the <computeroutput>ResDcel</computeroutput> class on the basis of the <computeroutput>Dcel1</computeroutput> and <computeroutput>Dcel2</computeroutput> records that induce them.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_overlay_2.h" line="67" column="6" declfile="CGAL/Arr_overlay_2.h" declline="67" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga6250573eaa94af687154326513c2cd2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::decompose</definition>
        <argsstring>(const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, OutputIterator oi)</argsstring>
        <name>decompose</name>
        <qualifiedname>CGAL::decompose</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>produces the symbolic vertical decomposition of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>More precisely, this function performs a batched vertical ray-shooting query from every arrangement vertex, and pairs each vertex with a pair of polymorphic objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it.</para>
<para>The finite arrangement vertices and the features they &quot;see&quot;, if exist, that are, the query results, are inserted in ascending <formula id="29">$xy$</formula>-lexicographic order (of the query vertex) into an output container given through an output iterator. If the vertex is the top end-vertex of a vertical edge, we say that there is no feature below it; similarly, if it is the bottom end-vertex of a vertical edge, we say that there is no feature above it. Each feature, if exists, is represented by a discriminated union container that holds an object of one of the following types:</para>
<para><itemizedlist>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member">Arrangement_on_surface_2::Halfedge_const_handle</ref></computeroutput>, if the vertex is located above (or below) an edge. The given halfedge is always directed from right to left. In case there is no concrete edge below (or above) the vertex, and the arrangement is unbounded, then the object returned is a <emphasis>fictitious</emphasis> halfedge. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member">Arrangement_on_surface_2::Face_const_handle</ref></computeroutput>, in case there is no edge below (or above) the vertex, and the arrangement is bounded. </para>
</listitem>
<listitem>
<para><computeroutput><ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref></computeroutput>, in case the vertex is located vertically above (or below) another arrangement vertex. </para>
</listitem>
</itemizedlist>
</para>
<para>The output of this function can be readily used for inserting vertical walls and physically decomposing the arrangement into pseudo-trapezoids.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>The arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oi</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator that points at the output container. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The past-the-end iterator of the output container.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><simplesect kind="pre"><para>Dereferencing <computeroutput>oi</computeroutput> must yield an object of type <computeroutput>std::pair&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref>, std::pair&lt;std::optional&lt;Type,std::optional&lt;Type&gt;&gt;&gt;</computeroutput>, where <computeroutput>Type</computeroutput> is <computeroutput>std::variant&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a47fac787fb37cd812814fbb9b6ab9acc" kindref="member">Arrangement_on_surface_2::Vertex_const_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a22adafaff54a2c42e6c369f198870be5" kindref="member">Arrangement_on_surface_2::Halfedge_const_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a513a10758cc81189887d5f0a492f0245" kindref="member">Arrangement_on_surface_2::Face_const_handle</ref>&gt;</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arr_vertical_decomposition_2.h" line="49" column="1" declfile="CGAL/Arr_vertical_decomposition_2.h" declline="49" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga9dd10a3efed93328acef4e4bcb175df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt;::Halfedge_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_non_intersecting_curve</name>
        <qualifiedname>CGAL::insert_non_intersecting_curve</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given <formula id="211">$ x$</formula>-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges. </para>
        </briefdescription>
        <detaileddescription>
<para>Under this assumption, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges, and the function returns a handle for the one directed lexicographically in increasing order (from left to right).</para>
<para>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the &quot;walk
along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the restricted <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput> must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="257" column="1" declfile="CGAL/Arrangement_2.h" declline="257" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad4aa37a4e938747028690579fb703d67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert_non_intersecting_curves</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert_non_intersecting_curves</name>
        <qualifiedname>CGAL::insert_non_intersecting_curves</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts a set of <formula id="211">$ x$</formula>-monotone curves in a given range into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The insertion is performed in an aggregated manner, using the sweep-line algorithm. The input curves should be pairwise disjoint in their interior and pairwise interior-disjoint from all existing arrangement vertices and edges.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para><computeroutput>InputIterator::value_type</computeroutput> must be <computeroutput>Traits::X_monotone_curve_2</computeroutput> </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="278" column="6" declfile="CGAL/Arrangement_2.h" declline="278" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gabfaca749e7d8c9547c143032a0e9df08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt;::Vertex_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle CGAL::insert_point</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_point</name>
        <qualifiedname>CGAL::insert_point</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given point into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>. In either case, the function returns a handle for the vertex associated with the point.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, and support the splitting functionality. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="308" column="1" declfile="CGAL/Arrangement_2.h" declline="308" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gabcb9bc6c5859edf3fbc1390e60e32a17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>is_valid</name>
        <qualifiedname>CGAL::is_valid</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Checks the validity of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Invokes the member function <computeroutput>arr.is_valid()</computeroutput> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all <formula id="211">$ x$</formula>-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para>The instantiated traits class must model the concept <computeroutput>ArranagmentXMonotoneTraits_2</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="331" column="6" declfile="CGAL/Arrangement_2.h" declline="331" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad41fab113e4ec35768bbcdfc6f3c54c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt;::Face_handle</type>
        <definition>Arrangement_2&lt; Traits, Dcel &gt;::Face_handle CGAL::remove_edge</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Halfedge_handle e)</argsstring>
        <name>remove_edge</name>
        <qualifiedname>CGAL::remove_edge</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt;::Halfedge_handle</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <computeroutput>remove_edge(arr, e)</computeroutput> is equivalent to the call <computeroutput>arr.remove_edge (e, true, true)</computeroutput>. However, this free function requires that <computeroutput>Traits</computeroutput> be a model of the refined concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which requires merge operations on <formula id="211">$ x$</formula>-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated traits class must model the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="357" column="1" declfile="CGAL/Arrangement_2.h" declline="357" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::remove_vertex</definition>
        <argsstring>(Arrangement_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_2&lt; Traits, Dcel &gt;::Vertex_handle v)</argsstring>
        <name>remove_vertex</name>
        <qualifiedname>CGAL::remove_vertex</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt;::Vertex_handle</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Attempts to removed a given vertex from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <emphasis>redundant</emphasis> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single <formula id="453">$
x$</formula>-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and support the merging functionality. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_2.h" line="379" column="6" declfile="CGAL/Arrangement_2.h" declline="379" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga7598937d11570bdedd5f3b6491065940" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename Curve</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::do_intersect</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl)</argsstring>
        <name>do_intersect</name>
        <qualifiedname>CGAL::do_intersect</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const Curve &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>Checks if a given curve or <formula id="7">$x$</formula>-monotone curve intersects an existing arrangement&apos;s edges or vertices. </para>
        </briefdescription>
        <detaileddescription>
<para>If the give curve is not an <formula id="7">$x$</formula>-monotone curve then the function subdivides the given curve into <formula id="211">$ x$</formula>-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve&apos;s left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement&apos;s edge/vertex is found or when the right endpoint is reached.</para>
<para>A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>.</para>
<para>Checks if the given curve or <formula id="211">$ x$</formula>-monotone curve <computeroutput>c</computeroutput> intersects edges or vertices of the existing arrangement <computeroutput>arr</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>If <computeroutput>c</computeroutput> is <formula id="211">$ x$</formula>-monotone then the instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. If <computeroutput>c</computeroutput> is a curve then the instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> concept. That is, it should define the <computeroutput>Curve_2</computeroutput> type, and support its subdivision into <formula id="211">$ x$</formula>-monotone subcurves (and perhaps isolated points). </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1126" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1126" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gad2c812247ce5c1dd592c0e0be74a1fc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_non_intersecting_curve</name>
        <qualifiedname>CGAL::insert_non_intersecting_curve</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::X_monotone_curve_2 &amp;</type>
          <declname>xc</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given <formula id="211">$ x$</formula>-monotone curve into a given arrangement, where the given curve and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interior of the input curve must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). </para>
        </briefdescription>
        <detaileddescription>
<para>Under this condition, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges. The function returns a handle to the one directed lexicographically in increasing order (from left to right).</para>
<para>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the &quot;walk
along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the restricted <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput> must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1163" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1163" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gab168a4f4aa766c5bd670d82f4793f16d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert_non_intersecting_curves</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert_non_intersecting_curves</name>
        <qualifiedname>CGAL::insert_non_intersecting_curves</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Inserts a set of <formula id="211">$ x$</formula>-monotone curves in a given range into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The insertion is performed in an aggregated manner using the sweep-line algorithm. The input curves and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interiors of the input curves must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). The insertion operations creates exactly one new edge, that is, two twin halfedges, for every input curve.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, as no intersections are computed. </para>
</listitem>
<listitem>
<para><computeroutput>InputIterator::value_type</computeroutput> must be <computeroutput>Traits::X_monotone_curve_2</computeroutput> </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1189" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1189" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga20598ef738aed142f32617212dc861d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle CGAL::insert_point</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert_point</name>
        <qualifiedname>CGAL::insert_point</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts a given point into a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the &quot;walk along line&quot; point-location strategy - namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt; &gt;</computeroutput>. In either case, the function returns a handle for the vertex associated with the point.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept, and support the splitting functionality. </para>
</listitem>
<listitem>
<para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1223" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1223" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gafd685214e9dcdfe2186b4d9b7f76f37e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::is_valid</definition>
        <argsstring>(const Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr)</argsstring>
        <name>is_valid</name>
        <qualifiedname>CGAL::is_valid</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Checks the validity of a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Invokes the member function <computeroutput>arr.is_valid()</computeroutput> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all <formula id="211">$ x$</formula>-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para>The instantiated traits class must model the concept <computeroutput>ArranagmentXMonotoneTraits_2</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1246" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1246" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaaa3cb37bae2483e238ede133951e3088" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Face_handle</type>
        <definition>Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Face_handle CGAL::remove_edge</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle e)</argsstring>
        <name>remove_edge</name>
        <qualifiedname>CGAL::remove_edge</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <computeroutput>remove_edge(arr, e)</computeroutput> is equivalent to the call <computeroutput>arr.remove_edge (e, true, true)</computeroutput>. However, this free function requires that <computeroutput>Traits</computeroutput> be a model of the refined concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>, which requires merge operations on <formula id="211">$ x$</formula>-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <computeroutput><ref refid="group__PkgArrangementOnSurface2Funcs_1gacbb4f22a59c77fb06a9d544cbbb04778" kindref="member">remove_vertex()</ref></computeroutput> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated traits class must model the concept <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1273" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1273" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga5eca39557780532185639e02ce4ecf83" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::remove_vertex</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle v)</argsstring>
        <name>remove_vertex</name>
        <qualifiedname>CGAL::remove_vertex</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Attempts to removed a given vertex from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <emphasis>redundant</emphasis> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single <formula id="453">$
x$</formula>-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</para>
<para><bold>Requirements</bold><linebreak/>
</para>
<para><itemizedlist>
<listitem>
<para>The instantiated <computeroutput>Traits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <computeroutput><ref refid="classArrangementBasicTraits__2" kindref="compound">ArrangementBasicTraits_2</ref></computeroutput> concept and support the merging functionality. </para>
</listitem>
</itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1297" column="6" declfile="CGAL/Arrangement_on_surface_2.h" declline="1297" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga52ccca744c113ea53ae30cdf6c70b295" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename OutputIterator</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::zone</definition>
        <argsstring>(Arrangement_on_surface_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename GeometryTraits::X_monotone_curve_2 &amp;c, OutputIterator oi, const PointLocation &amp;pl)</argsstring>
        <name>zone</name>
        <qualifiedname>CGAL::zone</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename GeometryTraits::X_monotone_curve_2 &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>oi</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
        </param>
        <briefdescription>
<para>computes the zone of the given <formula id="7">$x$</formula>-monotone curve in a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>More precisely, this function finds the arrangement vertices, edges ,and faces that the given <formula id="7">$x$</formula>-monotone curve intersects, and inserts them in the order they are discovered when traversing the <formula id="7">$x$</formula>-monotone curve from left to right into an output contaiuner given through an output iterator. An object in the resulting zone is represented by a discriminated union container that holds a vertex handle, halfedge handle, or a face handle.</para>
<para>A given point-location object is used for answering point-location queries during the insertion process. By default, the function uses the &quot;walk along
line&quot; point-location strategy, namely, an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2" kindref="compound">Arrangement_on_surface_2</ref>&lt;GeometryTraits, TopologyTraits&gt;&gt;</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>The given arrangement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The <formula id="7">$x$</formula>-monotone curve. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oi</parametername>
</parameternamelist>
<parameterdescription>
<para>The output iterator that points at the output container. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pl</parametername>
</parameternamelist>
<parameterdescription>
<para>The point-location object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The past-the-end iterator of the output container.</para>
</simplesect>
<simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> must be attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para>The instantiated <computeroutput>GeometryTraits</computeroutput> class must model the <computeroutput><ref refid="classArrangementXMonotoneTraits__2" kindref="compound">ArrangementXMonotoneTraits_2</ref></computeroutput> concept. </para>
</simplesect>
<simplesect kind="pre"><para>The point-location object <computeroutput>pl</computeroutput>, must model the <computeroutput><ref refid="classArrangementPointLocation__2" kindref="compound">ArrangementPointLocation_2</ref></computeroutput> concept. </para>
</simplesect>
<simplesect kind="pre"><para>Dereferencing <computeroutput>oi</computeroutput> must yield a polymorphic object of type <computeroutput>std::variant&lt;<ref refid="classCGAL_1_1Arrangement__on__surface__2_1a43113edb82930474c25b57b9a8e2143f" kindref="member">Arrangement_on_surface_2::Vertex_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1aaae449ff521205c5ba837143c431d3d3" kindref="member">Arrangement_on_surface_2::Halfedge_handle</ref>, <ref refid="classCGAL_1_1Arrangement__on__surface__2_1a5c97d46fc76cf9ab96ceced3b795b3c9" kindref="member">Arrangement_on_surface_2::Face_handle</ref>&gt;</computeroutput>.</para>
</simplesect>
<bold>Requirements</bold><linebreak/>
 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_2.h" line="1337" column="1" declfile="CGAL/Arrangement_on_surface_2.h" declline="1337" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1gab94ab51b036c862501bc06a8fa48e3f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle</type>
        <definition>Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle CGAL::insert</definition>
        <argsstring>(Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::Curve_2 &amp;c, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Curve_2 &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts the given curve <computeroutput>c</computeroutput> into the arrangement with history <computeroutput>arr</computeroutput>, and returns a handle to the inserted curve. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>c</computeroutput> is subdivided into <formula id="453">$
x$</formula>-monotone subcurves (and perhaps isolated points). Each subcurve is in turn inserted into the arrangement by locating its left endpoint and computing its zone until reaching the right endpoint.</para>
<para>The given point-location object <computeroutput>pl</computeroutput> is used to locate the left endpoints of the <formula id="211">$ x$</formula>-monotone curves. By default, the function uses the &quot;walk along
line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> is attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="234" column="1" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="234" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1ga92e366673e866d93370d61a828f8e5e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
          <param>
            <type>typename InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Aggregately inserts the curves in the range <computeroutput>[first,last)</computeroutput> into the arrangement with history <computeroutput>arr</computeroutput> using the sweep-line framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the target arrangement with history. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator to the first element in the range of curves. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>the past-the-end iterator of the range of curves. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="248" column="6" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="248" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1gaa323bd67be0dc7cc326eb4f26653e326" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits</type>
          </param>
        </templateparamlist>
        <type>Size</type>
        <definition>Size CGAL::remove_curve</definition>
        <argsstring>(Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle ch)</argsstring>
        <name>remove_curve</name>
        <qualifiedname>CGAL::remove_curve</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
<para>Removes a given curve from a given arrangement. </para>
        </briefdescription>
        <detaileddescription>
<para>The curve is specified by its handle <computeroutput>ch</computeroutput>, from the arrangement <computeroutput>arr</computeroutput>, by deleting all the edges it induces. The function returns the number of deleted edges. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="260" column="6" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="260" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a0a415adfb14fd0faf921688779d2eb08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits1</type>
          </param>
          <param>
            <type>typename TopologyTraits12</type>
          </param>
          <param>
            <type>typename ResTopologyTraits</type>
          </param>
          <param>
            <type>typename <ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits1 &gt; &amp;arr1, const Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits12 &gt; &amp;arr2, Arrangement_on_surface_with_history_2&lt; GeometryTraits, ResTopologyTraits &gt; &amp;res, OverlayTraits &amp;ovl_tr)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits12 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, ResTopologyTraits &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <param>
          <type><ref refid="classOverlayTraits" kindref="compound">OverlayTraits</ref> &amp;</type>
          <declname>ovl_tr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="278" column="6" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="278" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a327e4c4a4e23a7ebc37c1f6ef31ad1c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits</type>
          </param>
          <param>
            <type>typename TopologyTraits1</type>
          </param>
          <param>
            <type>typename TopologyTraits2</type>
          </param>
          <param>
            <type>typename ResTopologyTraits</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits1 &gt; &amp;arr1, const Arrangement_on_surface_with_history_2&lt; GeometryTraits, TopologyTraits2 &gt; &amp;arr2, Arrangement_on_surface_with_history_2&lt; GeometryTraits, ResTopologyTraits &gt; &amp;res)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, TopologyTraits2 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__on__surface__with__history__2" kindref="compound">Arrangement_on_surface_with_history_2</ref>&lt; GeometryTraits, ResTopologyTraits &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_on_surface_with_history_2.h" line="298" column="6" declfile="CGAL/Arrangement_on_surface_with_history_2.h" declline="298" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1ga99926abedcbe0fad8a78df4e9393f6f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename PointLocation</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt;::Curve_handle</type>
        <definition>Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle CGAL::insert</definition>
        <argsstring>(Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Curve_2 &amp;c, const PointLocation &amp;pl=walk_pl)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const typename Traits::Curve_2 &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const PointLocation &amp;</type>
          <declname>pl</declname>
          <defval>walk_pl</defval>
        </param>
        <briefdescription>
<para>Inserts the given curve <computeroutput>c</computeroutput> into the arrangement with history <computeroutput>arr</computeroutput>, and returns a handle to the inserted curve. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>c</computeroutput> is subdivided into <formula id="453">$
x$</formula>-monotone subcurves (and perhaps isolated points). Each subcurve is in turn inserted into the arrangement by locating its left endpoint and computing its zone until reaching the right endpoint.</para>
<para>The given point-location object <computeroutput>pl</computeroutput> is used to locate the left endpoints of the <formula id="211">$ x$</formula>-monotone curves. By default, the function uses the &quot;walk along
line&quot; point-location strategy - namely an instance of the class <computeroutput><ref refid="classCGAL_1_1Arr__walk__along__line__point__location" kindref="compound">Arr_walk_along_line_point_location</ref>&lt;<ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt;Traits,Dcel&gt; &gt;</computeroutput>.</para>
<para><simplesect kind="pre"><para>If provided, <computeroutput>pl</computeroutput> is attached to the given arrangement <computeroutput>arr</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="140" column="1" declfile="CGAL/Arrangement_with_history_2.h" declline="140" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Insert_1ga744ea4ef5e40e521af139e106b6480f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename InputIterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::insert</definition>
        <argsstring>(Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr, InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Aggregately inserts the curves in the range <computeroutput>[first,last)</computeroutput> into the arrangement with history <computeroutput>arr</computeroutput> using the sweep-line framework. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the target arrangement with history. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator to the first element in the range of curves. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>the past-the-end iterator of the range of curves. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="152" column="6" declfile="CGAL/Arrangement_with_history_2.h" declline="152" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Funcs_1ga9a27533ff4ade0c60978812e517b89d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>Size</type>
        <definition>Size CGAL::remove_curve</definition>
        <argsstring>(Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr, typename Arrangement_with_history_2&lt; Traits, Dcel &gt;::Curve_handle ch)</argsstring>
        <name>remove_curve</name>
        <qualifiedname>CGAL::remove_curve</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>typename <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt;::Curve_handle</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
<para>Removes a given curvespecified by its handle <computeroutput>ch</computeroutput>, from a given arrangement <computeroutput>arr</computeroutput>, deleting all the edges it induces. </para>
        </briefdescription>
        <detaileddescription>
<para>The function returns the number of deleted edges. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="161" column="6" declfile="CGAL/Arrangement_with_history_2.h" declline="161" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceCGAL_1a64122d076561fdda2cb8851ec93c2b88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel1</type>
          </param>
          <param>
            <type>typename Dcel2</type>
          </param>
          <param>
            <type>typename ResDcel</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::overlay</definition>
        <argsstring>(const Arrangement_with_history_2&lt; Traits, Dcel1 &gt; &amp;arr1, const Arrangement_with_history_2&lt; Traits, Dcel2 &gt; &amp;arr2, Arrangement_with_history_2&lt; Traits, ResDcel &gt; &amp;res)</argsstring>
        <name>overlay</name>
        <qualifiedname>CGAL::overlay</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel1 &gt; &amp;</type>
          <declname>arr1</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel2 &gt; &amp;</type>
          <declname>arr2</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, ResDcel &gt; &amp;</type>
          <declname>res</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Arrangement_with_history_2.h" line="194" column="6" declfile="CGAL/Arrangement_with_history_2.h" declline="194" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Draw_1gaf71524fb5b1c9bc6751bed9b26516e61" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits_2</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename GSOptions</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::draw</definition>
        <argsstring>(const Arrangement_2&lt; GeometryTraits_2, Dcel &gt; &amp;arr, const GSOptions &amp;gso)</argsstring>
        <name>draw</name>
        <qualifiedname>CGAL::draw</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeometryTraits_2, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const GSOptions &amp;</type>
          <declname>gso</declname>
        </param>
        <briefdescription>
<para>opens a new window and draws <computeroutput>arr</computeroutput>, an instance of the <computeroutput><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">CGAL::Arrangement_2</ref></computeroutput> class template. </para>
        </briefdescription>
        <detaileddescription>
<para>Parameters of the drawing are taken from the optional graphics scene options parameter.</para>
<para>A call to this function blocks the execution of the program until the drawing window is closed. This function requires <computeroutput>CGAL_Qt6</computeroutput>, and is only available if the macro <computeroutput>CGAL_USE_BASIC_VIEWER</computeroutput> is defined. Linking with the cmake target <computeroutput>CGAL::CGAL_Basic_viewer</computeroutput> will link with <computeroutput>CGAL_Qt6</computeroutput> and add the definition <computeroutput>CGAL_USE_BASIC_VIEWER</computeroutput>.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GeometryTraits_2</parametername>
</parameternamelist>
<parameterdescription>
<para>a geometry traits type, a model of a 2D arrangement traits concept. At this point it must be an instance of either <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">CGAL::Arr_conic_traits_2</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Dcel</parametername>
</parameternamelist>
<parameterdescription>
<para>the DCEL type, a model of the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GSOptions</parametername>
</parameternamelist>
<parameterdescription>
<para>a model of <computeroutput>GraphicsSceneOptions</computeroutput> concept.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the 2D arrangement to draw. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gso</parametername>
</parameternamelist>
<parameterdescription>
<para>the graphics scene options parameter.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classArrangementTraits__2" kindref="compound">ArrangementTraits_2</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/draw_arrangement_2.h" line="45" column="6" declfile="CGAL/draw_arrangement_2.h" declline="45" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Draw_1ga901897b505970cac1e7a79e89c7a1d20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits_2</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::draw</definition>
        <argsstring>(const Arrangement_2&lt; GeometryTraits_2, Dcel &gt; &amp;arr)</argsstring>
        <name>draw</name>
        <qualifiedname>CGAL::draw</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeometryTraits_2, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>A shortcut to <computeroutput><ref refid="group__PkgArrangementOnSurface2Draw_1gaf71524fb5b1c9bc6751bed9b26516e61" kindref="member">CGAL::draw</ref>(arr, Graphics_scene_options{})</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/draw_arrangement_2.h" line="52" column="6" declfile="CGAL/draw_arrangement_2.h" declline="52" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Draw_1ga3eef5a7d0496ce7652139aeef47ce8bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits_2</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
          <param>
            <type>typename GSOptions</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::add_to_graphics_scene</definition>
        <argsstring>(const Arrangement_2&lt; GeometryTraits_2, Dcel &gt; &amp;arr, CGAL::Graphics_scene &amp;gs, const GSOptions &amp;gso)</argsstring>
        <name>add_to_graphics_scene</name>
        <qualifiedname>CGAL::add_to_graphics_scene</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeometryTraits_2, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>CGAL::Graphics_scene &amp;</type>
          <declname>gs</declname>
        </param>
        <param>
          <type>const GSOptions &amp;</type>
          <declname>gso</declname>
        </param>
        <briefdescription>
<para>adds the vertices, edges and faces of <computeroutput>arr</computeroutput> into the given graphic scene <computeroutput>gs</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Parameters of the cells are taken from the optional graphics scene options parameter <computeroutput>gso</computeroutput>. Note that <computeroutput>gs</computeroutput> is not cleared before being filled (to enable to draw several data structures in the same basic viewer).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>GeometryTraits_2</parametername>
</parameternamelist>
<parameterdescription>
<para>a geometry traits type, a model of a 2D arrangement traits concept. At this point it must be an instance of either <computeroutput><ref refid="classCGAL_1_1Arr__segment__traits__2" kindref="compound">CGAL::Arr_segment_traits_2</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Arr__conic__traits__2" kindref="compound">CGAL::Arr_conic_traits_2</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Dcel</parametername>
</parameternamelist>
<parameterdescription>
<para>the DCEL type, a model of the <computeroutput><ref refid="classArrangementDcel" kindref="compound">ArrangementDcel</ref></computeroutput> concept. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GSOptions</parametername>
</parameternamelist>
<parameterdescription>
<para>a model of <computeroutput>GraphicsSceneOptions</computeroutput> concept.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arr</parametername>
</parameternamelist>
<parameterdescription>
<para>the 2D arrangement to draw. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gs</parametername>
</parameternamelist>
<parameterdescription>
<para>the graphic scene to fill. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gso</parametername>
</parameternamelist>
<parameterdescription>
<para>the graphics scene options parameter. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/draw_arrangement_2.h" line="67" column="6" declfile="CGAL/draw_arrangement_2.h" declline="67" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2Draw_1ga9a5cd565bc752a7fec6d99e8cee1db28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename GeometryTraits_2</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::add_to_graphics_scene</definition>
        <argsstring>(const Arrangement_2&lt; GeometryTraits_2, Dcel &gt; &amp;arr, CGAL::Graphics_scene &amp;gs)</argsstring>
        <name>add_to_graphics_scene</name>
        <qualifiedname>CGAL::add_to_graphics_scene</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; GeometryTraits_2, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>CGAL::Graphics_scene &amp;</type>
          <declname>gs</declname>
        </param>
        <briefdescription>
<para>A shortcut to <computeroutput><ref refid="group__PkgArrangementOnSurface2Draw_1ga3eef5a7d0496ce7652139aeef47ce8bd" kindref="member">CGAL::add_to_graphics_scene</ref>(arr, gs, Graphics_scene_options{})</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/draw_arrangement_2.h" line="75" column="6" declfile="CGAL/draw_arrangement_2.h" declline="75" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2op__left__shift_1ga8b30fa13c4f865df66cf6a14718240e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; CGAL::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Arrangement_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>CGAL::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Inserts the arrangement object <computeroutput>arr</computeroutput> into the output stream <computeroutput>os</computeroutput> using the output format defined by the <computeroutput><ref refid="classCGAL_1_1Arr__text__formatter" kindref="compound">Arr_text_formatter</ref></computeroutput> class. </para>
        </briefdescription>
        <detaileddescription>
<para>Only the basic geometric and topological features of the arrangement are inserted. Auxiliary data that may be attached to the DCEL features is ignored. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/IO/Arr_iostream.h" line="86" column="1" declfile="CGAL/IO/Arr_iostream.h" declline="86" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2op__right__shift_1ga153c183e5eeb01e5fda67ae0e391aa23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Dcel</type>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; CGAL::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, Arrangement_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>CGAL::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__2" kindref="compound">Arrangement_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Extracts an arrangement from a given input stream using the input format defined by the <computeroutput><ref refid="classCGAL_1_1Arr__text__formatter" kindref="compound">Arr_text_formatter</ref></computeroutput> class - that is, only the basic geometric and topological features of the arrangement are read and no auxiliary data is attached to the Dcel features. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/IO/Arr_iostream.h" line="98" column="14" declfile="CGAL/IO/Arr_iostream.h" declline="98" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2op__left__shift_1ga8c49cd589cbb3b01c45a976fe2c98e0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Traits</type>
          </param>
          <param>
            <type>typename Dcel</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; CGAL::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>CGAL::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Inserts the arrangement-with-history object <computeroutput>arr</computeroutput> into the output stream <computeroutput>os</computeroutput> using the output format defined by the <computeroutput><ref refid="classCGAL_1_1Arr__with__history__text__formatter" kindref="compound">Arr_with_history_text_formatter</ref></computeroutput> class. </para>
        </briefdescription>
        <detaileddescription>
<para>Only the basic geometric and topological features of the arrangement are inserted. Auxiliary data that may be attached to the DCEL features is ignored. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/IO/Arr_with_history_iostream.h" line="42" column="1" declfile="CGAL/IO/Arr_with_history_iostream.h" declline="42" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgArrangementOnSurface2op__right__shift_1gaee7da9524b44916bd7b4dc75594b5c8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Dcel</type>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; CGAL::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, Arrangement_with_history_2&lt; Traits, Dcel &gt; &amp;arr)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>CGAL::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Arrangement__with__history__2" kindref="compound">Arrangement_with_history_2</ref>&lt; Traits, Dcel &gt; &amp;</type>
          <declname>arr</declname>
        </param>
        <briefdescription>
<para>Extracts an arrangement-with-history from a given input stream using the default input format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/IO/Arr_with_history_iostream.h" line="51" column="14" declfile="CGAL/IO/Arr_with_history_iostream.h" declline="51" declcolumn="14"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="Arrangement_on_surface_2.txt" line="1" column="1"/>
  </compounddef>
</doxygen>
