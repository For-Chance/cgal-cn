<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_Surface_Mesh_Topology"/><anchor id="index_1ChapterSurfaceMeshTopology"/> <htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="author"><para>Guillaume Damiand and Francis Lazarus</para>
</simplesect>
This package provides a toolbox for manipulating curves on a combinatorial surface from the topological point of view. Two main functionalities are proposed. One is the computation of shortest curves that cannot be continuously deformed to a point. This includes the computation of the so-called edge width and face width of the vertex-edge graph of a combinatorial surface. The other functionality is the homotopy test for deciding if two given curves on a combinatorial surface can be continuously deformed one into the other.</para>
<sect1 id="index_1SMTopology">
<title>Introduction</title>
<para>All the computations in this package, either for the shortest non-contractible curve or for the homotopy tests, are performed on a input surface represented as a model of <computeroutput><ref refid="classCombinatorialMap" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Combinatorial_map.tag">CombinatorialMap</ref></computeroutput> or any model of <computeroutput><ref refid="classFaceGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">FaceGraph</ref></computeroutput>. Note that combinatorial maps are based on darts and FaceGraphs are based on halfedges. To avoid repetitions we use the terms darts and halfedges interchangeably in the sequel. The input surface is supposed to be connected and orientable.</para>
<sect2 id="index_1SMTopology_shortest">
<title>Shortest Non-Contractible Curve</title>
<para>Given a combinatorial surface, one may consider <emphasis>combinatorial curves</emphasis>, which are described as sequences of edges, or <emphasis>topological curves</emphasis>, which are continuous curves on the topological surface underlying the combinatorial surface. The length of a combinatorial curve is the sum of the lengths of its edges. Here, we measure the length of a topological curve as the number of crossings of this curve with the vertex-edge graph of the combinatorial surface. A closed curve, either topological or combinatorial, that cannot be continuously deformed to a point on the topological surface is said <emphasis>non-contractible</emphasis>. This package offers the following functions:</para>
<para><itemizedlist>
<listitem><para>Given a surface mesh <formula id="0">$\cal{M}$</formula> and a dart descriptor <computeroutput>d</computeroutput>, compute a shortest non-contractible combinatorial curve passing through the source vertex of <computeroutput>d</computeroutput>,</para>
</listitem><listitem><para>Given a surface mesh <formula id="0">$\cal{M}$</formula>, compute a shortest non-contractible combinatorial curve without the previous vertex requirement. When all the edges have the same unit length, the length of a shortest non-contractible curve is known as the <emphasis>edge width</emphasis> of the surface,</para>
</listitem><listitem><para>Given a surface mesh <formula id="0">$\cal{M}$</formula>, compute a shortest non-contractible topological curve. It can be assumed that this curve does not cross the edges of <formula id="0">$\cal{M}$</formula> and only passes through the vertices. It follows that the curve can be described by a circular sequence of traversed faces alternating with the vertices it passes through. The length of this curve (i.e., the number of vertices it passes through) is known as the <emphasis>face width</emphasis> of the surface.</para>
</listitem></itemizedlist>
</para>
<para>It is important to clarify how we compare the lengths of two combinatorial curves in order to compute the shortest one. &quot;Shortest&quot; can be understood as &quot;having the least amount of edges&quot; or &quot;having the smallest total length of its edges&quot;. In the former case, we consider that the mesh is unweighted; in the latter case, we consider that the mesh is weighted, and one must specify how the weight, or length, of each edge is calculated (see concept <computeroutput><ref refid="classWeightFunctor" kindref="compound">WeightFunctor</ref></computeroutput>). When the vertices of the mesh have Euclidean coordinates, the Euclidean distance between two connected vertices defines a natural weight for the corresponding edge. A weight functor <ref refid="structCGAL_1_1Surface__mesh__topology_1_1Euclidean__length__weight__functor" kindref="compound"><computeroutput>Euclidean_length_weight_functor</computeroutput></ref> is provided for this purpose.</para>
<para>The algorithm to find a shortest non-contractible curve through a specified vertex is based on the paper by Cabello et al. <ref refid="citelist_1CITEREF_cvl-ew-12" kindref="member">[1]</ref>. The time complexity is linear, though in the weighted case it is raised by a logarithmic factor, assuming that the weight computation takes constant time per edge. Computing the edge width takes quadratic time by running the first function on each vertex, and its complexity is also raised by a logarithmic factor when considering a weighted map. Computing the face width consists of constructing the radial graph of the original mesh and computing the edge width of the radial graph. It thus takes quadratic time. Computing face width on weighted maps is currently not supported.</para>
</sect2>
<sect2 id="index_1SMTopology_homotopy">
<title>Homotopy Test</title>
<para>Given a curve drawn on a surface one can ask if the curve can be continuously deformed to a point (i.e. a zero length curve). In other words, does there exist a continuous sequence of curves on the surface that starts with the input curve and ends to a point? Curves that deform to a point are said <emphasis>contractible</emphasis>. Any curve on a sphere is contractible but this is not true for all curves on a torus or on a surface with more complicated topology. The algorithms in this section are purely topological and do not assume any geometry on the input surface. In particular, the surface is not necessarily embedded in a Euclidean space.</para>
<para>The algorithm implemented in this package builds a data structure to efficiently answer queries of the following forms:<itemizedlist>
<listitem><para>Given a combinatorial surface <formula id="0">$\cal{M}$</formula> and a closed combinatorial curve specified as a sequence of edges of <formula id="0">$\cal{M}$</formula>, decide if the curve is contractible on <formula id="0">$\cal{M}$</formula>,</para>
</listitem><listitem><para>Given a combinatorial surface <formula id="0">$\cal{M}$</formula> and two closed combinatorial curves on <formula id="0">$\cal{M}$</formula>, decide if the two curves are related by a continuous transformation,</para>
</listitem><listitem><para>Given a combinatorial surface <formula id="0">$\cal{M}$</formula> and two, non-necessarily closed, combinatorial curves on <formula id="0">$\cal{M}$</formula>, decide if the two curves are related by a continuous transformation that fixes the curve extremities. The curves should have common endpoints, otherwise the answer to the query is trivially negative.</para>
</listitem></itemizedlist>
</para>
<para>The second query asks if the curves are <emphasis>freely homotopic</emphasis> while the third one asks if the curves are <emphasis>homotopic with fixed endpoints</emphasis>. The three queries are globally referred to as <emphasis>homotopy tests</emphasis>. <ref refid="index_1fig__fig_sm_topology_homotopy" kindref="member">fig__fig_sm_topology_homotopy</ref> below illustrates the three types of queries.</para>
<para><anchor id="index_1fig__fig_sm_topology_homotopy"/> <image type="html" name="free-vs-fixed-endpoints.svg"></image>
 <image type="latex" name="free-vs-fixed-endpoints.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_sm_topology_homotopy" kindref="member">fig__fig_sm_topology_homotopy</ref> On the upper left surface the green curve is contractible. The red and blue curves share the same (green) endpoint. (Being closed, their two endpoints coincide.) Although these last two curves are not homotopic with fixed endpoints they are freely homotopic as shown by the suggested continuous transformation of the blue curve. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The algorithms used are based on a paper by Erickson and Whittlesey <ref refid="citelist_1CITEREF_ew-tcsr-13" kindref="member">[3]</ref>, providing a linear time algorithm for the above homotopy tests. This is a simplified version of the linear time algorithm by Lazarus and Rivaud <ref refid="citelist_1CITEREF_lr-hts-12" kindref="member">[4]</ref>.</para>
</sect2>
<sect2 id="index_1SMTopology_simplicity">
<title>Simplicity Test</title>
<para>Given a cycle drawn on a surface one can ask if the cycle can be continuously deformed to a cycle that does not intersect with itself. Any contractible cycle deforms to a simple cycle but this is not true for more complicated cycles. The algorithm in this section is purely topological and do not assume any geometry on the input surface.</para>
<para>The algorithm implemented in this package builds a data structure to efficiently answer queries of the following forms:<itemizedlist>
<listitem><para>Given a combinatorial surface <formula id="0">$\cal{M}$</formula> and a closed combinatorial curve specified as a sequence of edges of <formula id="0">$\cal{M}$</formula>, decide if the curve is homotopic to a simple one on <formula id="0">$\cal{M}$</formula>.</para>
</listitem></itemizedlist>
</para>
<para>The algorithm used is based on a paper by Despr√© and Lazarus <ref refid="citelist_1CITEREF_cgal:dl-cginc-19" kindref="member">[2]</ref>, providing a <formula id="1">$O(n + l\log{l})$</formula>-time algorithm where <formula id="2">$n$</formula> is the complexity of <formula id="0">$\cal{M}$</formula> and <formula id="3">$l$</formula> is the length of the path.</para>
</sect2>
</sect1>
<sect1 id="index_1SMTopology_HowToUse">
<title>API Description</title>
<sect2 id="index_1SMTopology_Input">
<title>Specifying the Input Surface and Curves</title>
<para>The main class for this package is <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>. Its constructor takes the input surface. An internal representation of the surface (described below) is computed the first time an homotopy test is called.</para>
<para>Each combinatorial curve on this surface is contained in an instance of the class <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Surface_mesh_topology::Path_on_surface</ref></computeroutput>. An object in this class behaves as a list. This list is initially empty and the halfedges corresponding to the sequence of consecutive oriented edges of an input curve should be pushed back in this list. The class provides four ways for extending a nonempty path.<itemizedlist>
<listitem><para>Simply push the next halfedge using the <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a7ab5d5739194b4c972aa74c49cb05543" kindref="member">push_back()</ref> member function. One can also specify if this halfedge should have its direction flipped so as to satisfy the condition of a <computeroutput>Path_on_surface</computeroutput> (see the description of <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3aae17ee1adefd962310e19994a8b620" kindref="member">can_be_pushed()</ref> below) This can be done even when the path is empty,</para>
</listitem><listitem><para>The user may push the index of the next halfedge instead of the halfedge itself with the member function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index()</ref>. This may however be at the cost of an overhead computation mapping the index to the actual dart,</para>
</listitem><listitem><para>The path may be extended with the member function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn()</ref> by specifying the next halfedge thanks to a number of positive turns with respect to the previous dart/halfedge in the path. Calling this previous halfedge <computeroutput>h</computeroutput>, extending by a positive one turn is thus equivalent to extend the path with <computeroutput>next(h)</computeroutput>. An analogous member function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3b1629a7e6e46e0477166a18ae1d1e96" kindref="member">extend_negative_turn()</ref> is provided for convenience,</para>
</listitem><listitem><para>Finally, when the input surface is a model of <computeroutput><ref refid="classPolygonalSchema" kindref="compound">PolygonalSchema</ref></computeroutput>, which is a model of <computeroutput><ref refid="classGenericMap" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Combinatorial_map.tag">GenericMap</ref></computeroutput> with labeled edges as explained in section <ref refid="index_1SMTopology_Schema" kindref="member">Polygonal Schema Helper</ref>, the user may push the label of the next halfedge instead of the halfedge itself with the member function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1afad1f86d456ab700558a703bb9dff496" kindref="member">push_back_by_label()</ref>.</para>
</listitem></itemizedlist>
</para>
<para>In the first two cases, let A be the source vertex of the added dart or the target vertex if the added dart is flipped, let B be the target vertex of the last dart in the path or the source vertex if the last dart is flipped: A and B should coincide. The user is responsible for ensuring this condition. The member functions <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3aae17ee1adefd962310e19994a8b620" kindref="member">can_be_pushed()</ref>, <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1acdd26daa275609bb5b34606dac122d7f" kindref="member">can_be_pushed_by_index()</ref> and <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a9dc8e934c952a9b3ac3578878d19093c" kindref="member">can_be_pushed_by_label()</ref> return <computeroutput>true</computeroutput> if and only if the condition is satisfied.</para>
</sect2>
<sect2 id="index_1SMTopology_Schema">
<title>Polygonal Schema Helper</title>
<sect3 id="index_1SMTopology_PL">
<title>Polygonal Schema</title>
<para>Specifying a path on a combinatorial surface might be a tedious task. Indeed, knowing in advance the pointer, index or turn of each consecutive halfedge in a path is not always easy. In order to facilitate this task, we provide an intuitive model of <computeroutput><ref refid="classCombinatorialMap" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Combinatorial_map.tag">CombinatorialMap</ref></computeroutput> called <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Polygonal__schema__with__combinatorial__map" kindref="compound">Surface_mesh_topology::Polygonal_schema_with_combinatorial_map</ref></computeroutput>, a model of the <computeroutput><ref refid="classPolygonalSchema" kindref="compound">PolygonalSchema</ref></computeroutput> concept. In this model, a surface is viewed as a collection of clockwise oriented polygonal facets with labeled boundary (oriented) edges. Boundary edges with the same label are glued together to form a surface. Each label should appear at most twice in the collection and a label that appears only once corresponds to a boundary edge. The label of the opposite of an oriented edge is preceded by a minus. For example, the opposite of &apos;a1&apos; is &apos;-a1&apos;. Since we are dealing with orientable surfaces only, each label that appears twice must appear once with a minus. The user can add facets to the surface one at a time. Each facet is specified by the sequence of its oriented edge labels given as a string where the labels are words (any sequence of characters, except space) separated by blank spaces. In the next figure we see three examples of combinatorial maps described by a collection of facets with labeled edges. <anchor id="index_1fig__fig_sm_incremental-builder"/> <image type="html" name="incremental-builder.svg"></image>
 <image type="latex" name="incremental-builder.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_sm_incremental-builder" kindref="member">fig__fig_sm_incremental-builder</ref> Left, a surface described by a single facet with eight edges pairwise identified. The resulting (topological) surface is shown in <ref refid="index_1fig__fig_cut-open" kindref="member">fig__fig_cut-open</ref>. Middle, a surface described by three labeled quadrilaterals. Right, a single labeled facet. The corresponding surface is topologically equivalent to the middle example. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
 The code for creating the above left and middle examples appear in the <ref refid="index_1SMTopology_Example_VI_VII" kindref="member">polygonal schema examples</ref> below. The class provides the following functionalities.<itemizedlist>
<listitem><para><ref refid="classPolygonalSchema_1a8d3f2abb3d118a3a25ae691178ea7312" kindref="member">add_facet(s)</ref> adds a polygon to the current collection of polygons. If the polygon has &quot;n&quot; sides, &quot;s&quot; is a sequence of &quot;n&quot; edge labels possibly preceded by a minus and separated by blanks.</para>
</listitem><listitem><para>alternatively, the user can add a facet by adding edge labels one at a time using the member functions <ref refid="classPolygonalSchema_1abb0c90f5140ce4a498eb21224695e6b0" kindref="member">init_facet()</ref>, <ref refid="classPolygonalSchema_1acaaf70f2078f0f62986c77ea66400648" kindref="member">add_edges_to_facet()</ref> and <ref refid="classPolygonalSchema_1a440a5d6c15f7f5f4d4b58450adf9846a" kindref="member">finish_facet()</ref></para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="index_1SMTopology_PL_with_Boundary">
<title>Polygonal Schema with Boundary</title>
<para>As noted in the previous section <ref refid="index_1SMTopology_PL" kindref="member">Polygonal Schema</ref>, every label that appears only once in a polygonal schema corresponds to a boundary edge. The Polygonal Schema helper offers another mechanism to create surfaces with boundary. Each facet already added to a polygonal schema may be perforated to create a hole in the surface. The edges of a perforated facet thus becomes boundary edges. The reverse operation consists in filling the supposedly perforated facet. The class provides the following interface.<itemizedlist>
<listitem><para><ref refid="classPolygonalSchema_1a2f5ea0f91ce40fa4362686343ec209a4" kindref="member">perforate_facet (h)</ref> perforates the facet identified by the halfedge <computeroutput>h</computeroutput>. If <computeroutput>s</computeroutput> is the label of the oriented edge corresponding to <computeroutput>h</computeroutput>, one may equivalently call perforate_facet (s).</para>
</listitem><listitem><para>Similarly, <ref refid="classPolygonalSchema_1ace5783954706f82a421ff6a2688fc577" kindref="member">fill_facet (h or s)</ref> turns a facet into a plain one.</para>
</listitem><listitem><para>The member functions <ref refid="classPolygonalSchema_1a7f62576d884d2e96c0ec4c4c71b76088" kindref="member">get_dart_labeled(s)</ref> and <ref refid="classPolygonalSchema_1a006ccdb967aa1eef3f8fbc4bc4de6f4c" kindref="member">get_label(h)</ref> allow to easily pass from a halfedge to its label and vice versa.</para>
</listitem></itemizedlist>
</para>
<para>As an example, one may perforate all the facets of a polygonal schema <formula id="0">$\cal{M}$</formula> to obtain a &quot;skeleton&quot; surface equivalent to a thickening of the graph composed of the edges of <formula id="0">$\cal{M}$</formula>.</para>
</sect3>
<sect3 id="index_1SMTopology_Curves_on_PS">
<title>Curves on Polygonal Schema</title>
<para>A <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput> can be constructed with a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Polygonal__schema__with__combinatorial__map" kindref="compound">Surface_mesh_topology::Polygonal_schema_with_combinatorial_map</ref></computeroutput> as input surface. In this case, every halfedge has a label (possibly preceded by a minus) and a path can be specified by the sequence of labels corresponding to its halfedge sequence. A repeated call to the function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1afad1f86d456ab700558a703bb9dff496" kindref="member">push_back_by_label()</ref> allows the user to specify the path in this way.</para>
</sect3>
</sect2>
<sect2 id="index_1SMTopology_Compute_SNC">
<title>Compute Shortest Non-contractible Cycle</title>
<para>Since the data structures to represent a surface are edge-centralized, in order to specify a vertex where the curve is computed, the user can use any dart belonging to this vertex. We use the term <emphasis>cycle</emphasis> as a synonymous of closed curve.</para>
<para>The class <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound"><computeroutput>Curves_on_surface_topology</computeroutput> </ref> provides the following three functions:</para>
<para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a415f2d76b13fdb39d4e3f10c611ad412" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle_with_base_point(d, weight_functor)</computeroutput> </ref>: Compute a shortest non-contractible cycle going through the source vertex of <computeroutput>d</computeroutput>,</para>
</listitem><listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a8292fce8d2ea8e2f9657196626e6af82" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle(weight_functor)</computeroutput> </ref>: Very similar to the previous function, except that one does not specify a vertex. It computes a shortest non-contractible cycle through every vertex and returns the shortest cycle among them,</para>
</listitem><listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a38561507c54e7a0c70b7d8cd00cd9713" kindref="member"><computeroutput>compute_edge_width()</computeroutput> </ref>: Compute the edge width of the mesh, equivalent to <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a8292fce8d2ea8e2f9657196626e6af82" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle(</computeroutput></ref> <ref refid="structCGAL_1_1Surface__mesh__topology_1_1Unit__weight__functor" kindref="compound"><computeroutput>Unit_weight_functor())</computeroutput></ref>.</para>
</listitem></itemizedlist>
</para>
<para>The above functions return an instance of <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound"><computeroutput>Path_on_surface</computeroutput> </ref>. The optional argument <computeroutput>weight_functor</computeroutput> is used to calculate the length of the edges. If not given, all the edge lengths are set to 1, i.e. the mesh is unweighted.</para>
</sect2>
<sect2 id="index_1SMTopology_Compute_facewidth">
<title>Compute Face Width</title>
<para>Face width returns a shortest non-contractible topological curve described as a circular sequence of traversed faces alternating with the vertices it passes through. Each face or vertex in this sequence is identified by one of its dart descriptors. In practice, we choose the same dart descriptor for a face as for the next vertex it passes through. This way, we only need to return one dart descriptor for a face and its following vertex in the sequence.</para>
<para>The function <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1ab1e89845805ea2bfbdbeb6344aed8643" kindref="member"><computeroutput>compute_face_width()</computeroutput> </ref> computes the sequence of dart descriptors as described above and returns an <computeroutput>std::vector</computeroutput> of dart descriptors, where each dart represents a traversed face followed by an incident vertex.</para>
</sect2>
<sect2 id="index_1SMTopology_Queries">
<title>Testing Homotopy</title>
<para>Given two <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Surface_mesh_topology::Path_on_surface</ref></computeroutput> <formula id="4">$p_1$</formula> and <formula id="5">$p_2$</formula>, the class <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput> provides the following three functions:</para>
<para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a816ad97901765d303ee5fa50fc8a0d0b" kindref="member">is_contractible</ref>( <formula id="4">$p_1$</formula>) returns <computeroutput>true</computeroutput> if the closed curve <formula id="4">$p_1$</formula> is contractible,</para>
</listitem><listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a85fc4a1f20c84073814251af6912539d" kindref="member">are_freely_homotopic</ref>( <formula id="4">$p_1$</formula>, <formula id="5">$p_2$</formula>) returns <computeroutput>true</computeroutput> if the closed curves <formula id="4">$p_1$</formula> and <formula id="5">$p_2$</formula> are freely homotopic,</para>
</listitem><listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a05dba41f3012ec7747aa215e2af2f152" kindref="member">are_homotopic_with_fixed_endpoints</ref>( <formula id="4">$p_1$</formula>, <formula id="5">$p_2$</formula>) returns <computeroutput>true</computeroutput> if the paths <formula id="4">$p_1$</formula> and <formula id="5">$p_2$</formula> are homotopic with fixed endpoints. This call is equivalent to <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a816ad97901765d303ee5fa50fc8a0d0b" kindref="member">is_contractible</ref>( <formula id="6">$p_1\cdot \overline{p_2}$</formula>), where <formula id="6">$p_1\cdot \overline{p_2}$</formula> is the concatenation of <formula id="4">$p_1$</formula> and the reverse of <formula id="5">$p_2$</formula>.</para>
</listitem></itemizedlist>
</para>
<para>A common first step in the homotopy test algorithms is to simplify the input combinatorial surface. This preprocessing step is done once and for all for a given mesh, the first time an homotopy test is called. The simplified surface is a quadrangulation, every face of which is a quadrilateral, stored in a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>. It has 2 vertices and <formula id="7">$2g$</formula> quadrilaterals where <formula id="8">$g$</formula> is the genus of the input surface. This is otherwise independent of the size of input surface, <simplesect kind="note"><para>The user must not modify the input surface as long as homotopy tests are performed with this <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>.</para>
</simplesect>
Each time a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Surface_mesh_topology::Path_on_surface</ref></computeroutput> is provided for a homotopy test, it is first transformed to an equivalent path in the quadrangulation stored by the <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>. This transformation is transparent to the user who has never access to the quadrangulation.</para>
</sect2>
<sect2 id="index_1SMTopology_Query_Simplicity">
<title>Testing Simplicity</title>
<para>Given a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Surface_mesh_topology::Path_on_surface</ref></computeroutput> <formula id="9">$p$</formula>, the class <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput> provides the following function:</para>
<para><itemizedlist>
<listitem><para><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a8d7c4cba2cf2cff542f5cd93117233db" kindref="member"><computeroutput>is_homotopic_to_simple_cycle(p)</computeroutput> </ref> returns <computeroutput>true</computeroutput> if the closed curve <formula id="9">$p$</formula> is homotopic to some simple cycle.</para>
</listitem></itemizedlist>
</para>
<para>Like homotopy tests, the first step is to simplify the input combinatorial surface. The algorithm will share the surface with homotopy tests and invoke the simplification if the preprocessing has not been done yet. <simplesect kind="note"><para>The user must not modify the input surface as long as simplicity tests are performed with this <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>.</para>
</simplesect>
Each time a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Surface_mesh_topology::Path_on_surface</ref></computeroutput> is provided for a simplicity test, it is first transformed to an equivalent path in the quadrangulation stored by the <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>. This transformation is transparent to the user who has never access to the quadrangulation.</para>
</sect2>
</sect1>
<sect1 id="index_1SMTopology_Examples">
<title>Examples</title>
<sect2 id="index_1SMTopology_Example_I_II_III">
<title>Compute Shortest Non-contractible Cycle</title>
<para>In the next two examples, we present various ways to compute shortest non-contractible cycles.</para>
<para>One can store the original mesh in a <computeroutput><ref refid="classCGAL_1_1Combinatorial__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Combinatorial_map.tag">Combinatorial_map</ref></computeroutput> instance and run the algorithm without regarding the geometric distances, i.e. the unweighted case (first call to <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a415f2d76b13fdb39d4e3f10c611ad412" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle_with_base_point</computeroutput></ref>). Alternatively, one can take the geometric distances into consideration by providing a weight functor to calculate the weight of the edge containing the given dart (second call to <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a415f2d76b13fdb39d4e3f10c611ad412" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle_with_base_point</computeroutput></ref>). Note that the time complexity is raised by a logarithmic factor.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2shortest_noncontractible_cycle_8cpp-example" kindref="compound">Surface_mesh_topology/shortest_noncontractible_cycle.cpp</ref> <programlisting filename="Surface_mesh_topology/shortest_noncontractible_cycle.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_constructors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_face_graph_with_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">LCC_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2, 3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Path_on_surface=<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">CGAL::Surface_mesh_topology::Path_on_surface&lt;LCC_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>cycle_length(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LCC_3&amp;<sp/>lcc,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Path_on_surface&amp;<sp/>cycle)</highlight></codeline>
<codeline><highlight class="normal">{<sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>length<sp/>of<sp/>the<sp/>given<sp/>cycle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>res=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i=0;<sp/>i&lt;cycle.length();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>res+=std::sqrt</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CGAL::squared_distance(lcc.point(cycle[i]),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lcc.point(lcc.other_extremity(cycle[i]))));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>display_cycle_info(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>LCC_3&amp;<sp/>lcc,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Path_on_surface&amp;<sp/>cycle)</highlight></codeline>
<codeline><highlight class="normal">{<sp/></highlight><highlight class="comment">//<sp/>Display<sp/>information<sp/>about<sp/>the<sp/>given<sp/>cycle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cycle.is_empty())<sp/>{<sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Empty.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Root:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;lcc.point(cycle[0])&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>edges:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;cycle.length()&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;Length:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;cycle_length(lcc,<sp/>cycle)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename(argc==1?<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/3torus.off&quot;</highlight><highlight class="normal">):argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>=(argc&lt;3?</highlight><highlight class="keyword">false</highlight><highlight class="normal">:std::string(argv[2])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!CGAL::load_off(lcc,<sp/>filename.c_str()))<sp/></highlight><highlight class="comment">//<sp/>Load<sp/>the<sp/>off<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cannot<sp/>read<sp/>file<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;.<sp/>Exiting<sp/>program&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;File<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;<sp/>loaded.<sp/>Finding<sp/>shortest<sp/>non<sp/>contractible<sp/>cycle...&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">CGAL::Surface_mesh_topology::Curves_on_surface_topology&lt;LCC_3&gt;</ref><sp/>cst(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3::Dart_const_descriptor<sp/>root=lcc.dart_descriptor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(CGAL::get_default_random().get_int(0,<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(lcc.number_of_darts())));<sp/></highlight><highlight class="comment">//<sp/>One<sp/>dart<sp/>of<sp/>the<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Path_on_surface<sp/>cycle1=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cst.compute_shortest_non_contractible_cycle_with_base_point(root);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Surface__mesh__topology_1_1Euclidean__length__weight__functor" kindref="compound">CGAL::Surface_mesh_topology::Euclidean_length_weight_functor&lt;LCC_3&gt;</ref><sp/>wf(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Path_on_surface<sp/>cycle2=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cst.compute_shortest_non_contractible_cycle_with_base_point(root,<sp/>wf);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cycle<sp/>1<sp/>(pink):<sp/>&quot;</highlight><highlight class="normal">;<sp/>display_cycle_info(lcc,<sp/>cycle1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cycle<sp/>2<sp/>(green):<sp/>&quot;</highlight><highlight class="normal">;<sp/>display_cycle_info(lcc,<sp/>cycle2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cycles={cycle1,<sp/>cycle2};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::draw</ref>(lcc,<sp/>cycles);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>In order to find the edge width of the surface, one can make use of the routine <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a38561507c54e7a0c70b7d8cd00cd9713" kindref="member"><computeroutput>compute_edge_width</computeroutput></ref> as in the following example. The weighted shortest non contractible cycle is also computed (calling <ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology_1a8292fce8d2ea8e2f9657196626e6af82" kindref="member"><computeroutput>compute_shortest_non_contractible_cycle</computeroutput></ref>). In this example, a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> is used to store the mesh.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2edgewidth_surface_mesh_8cpp-example" kindref="compound">Surface_mesh_topology/edgewidth_surface_mesh.cpp</ref> <programlisting filename="Surface_mesh_topology/edgewidth_surface_mesh.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/squared_distance_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_face_graph_with_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Mesh<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;CGAL::Simple_cartesian&lt;double&gt;::Point_3</ref>&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Path_on_surface<sp/>=<sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">CGAL::Surface_mesh_topology::Path_on_surface&lt;Mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>cycle_length(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Mesh&amp;<sp/>mesh,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Path_on_surface&amp;<sp/>cycle)</highlight></codeline>
<codeline><highlight class="normal">{<sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>length<sp/>of<sp/>the<sp/>given<sp/>cycle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>res=0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i=0;<sp/>i&lt;cycle.length();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>res+=std::sqrt</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(CGAL::squared_distance(mesh.point(mesh.vertex(mesh.edge(cycle[i]),<sp/>0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mesh.point(mesh.vertex(mesh.edge(cycle[i]),<sp/>1))));<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>display_cycle_info(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Mesh&amp;<sp/>mesh,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Path_on_surface&amp;<sp/>cycle)</highlight></codeline>
<codeline><highlight class="normal">{<sp/></highlight><highlight class="comment">//<sp/>Display<sp/>information<sp/>about<sp/>the<sp/>given<sp/>cycle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cycle.is_empty())<sp/>{<sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Empty.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Root:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;mesh.point(mesh.vertex(mesh.edge(cycle[0]),<sp/>0))&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>edges:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;cycle.length()&lt;&lt;</highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;Length:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;cycle_length(mesh,<sp/>cycle)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename(argc==1?<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/3torus.off&quot;</highlight><highlight class="normal">):argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>=(argc&lt;3?</highlight><highlight class="keyword">false</highlight><highlight class="normal">:(std::string(argv[2])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mesh<sp/>sm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!<ref refid="group__PkgBGLIOFct_1ga49f5b5e6fbfcbfaaac7604c88e10915c" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">CGAL::IO::read_polygon_mesh</ref>(filename,<sp/>sm))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cannot<sp/>read<sp/>file<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;.<sp/>Exiting<sp/>program&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;File<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;<sp/>loaded.<sp/>Finding<sp/>edge-width<sp/>of<sp/>the<sp/>mesh...&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">CGAL::Surface_mesh_topology::Curves_on_surface_topology&lt;Mesh&gt;</ref><sp/>cst(sm,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Path_on_surface<sp/>cycle1=cst.compute_edge_width(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Surface__mesh__topology_1_1Euclidean__length__weight__functor" kindref="compound">CGAL::Surface_mesh_topology::Euclidean_length_weight_functor&lt;Mesh&gt;</ref><sp/>wf(sm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Path_on_surface<sp/>cycle2=cst.compute_shortest_non_contractible_cycle(wf,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cycle<sp/>1<sp/>(pink):<sp/>&quot;</highlight><highlight class="normal">;<sp/>display_cycle_info(sm,<sp/>cycle1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cycle<sp/>2<sp/>(green):<sp/>&quot;</highlight><highlight class="normal">;<sp/>display_cycle_info(sm,<sp/>cycle2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cycles={cycle1,<sp/>cycle2};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::draw</ref>(sm,<sp/>cycles);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>In these two examples, the mesh and the cycles can be visualized if CGAL_Qt6 is enabled.</para>
</sect2>
<sect2 id="index_1SMTopology_Example_IV">
<title>Compute Face Width</title>
<para>The following example computes the face width, and visualizes it if CGAL_Qt6 is enabled.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2facewidth_8cpp-example" kindref="compound">Surface_mesh_topology/facewidth.cpp</ref> <programlisting filename="Surface_mesh_topology/facewidth.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_constructors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;draw_facewidth.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">LCC_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2, 3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">CST<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">CGAL::Surface_mesh_topology::Curves_on_surface_topology&lt;LCC_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dart_const_descriptor=LCC_3::Dart_const_descriptor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Program<sp/>facewidth_on_unweighted_map<sp/>started.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>filename(argc==1?<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/double-torus-example.off&quot;</highlight><highlight class="normal">):argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>inp(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(inp.fail())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Cannot<sp/>read<sp/>file<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;.<sp/>Exiting<sp/>program&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::load_off(lcc,<sp/>inp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;File<sp/>&apos;&quot;</highlight><highlight class="normal">&lt;&lt;filename&lt;&lt;</highlight><highlight class="stringliteral">&quot;&apos;<sp/>loaded.<sp/>Finding<sp/>the<sp/>facewidth...&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CST<sp/>cst(lcc,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Dart_const_descriptor&gt;<sp/>cycle=cst.compute_face_width(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cycle.size()==0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/><sp/>Cannot<sp/>find<sp/>such<sp/>cycle.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/><sp/>Number<sp/>of<sp/>faces:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;cycle.size()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_BASIC_VIEWER</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(argc&gt;=3<sp/>&amp;&amp;<sp/>std::string(argv[2])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>draw_facewidth(lcc,<sp/>cycle);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1SMTopology_Example_V">
<title>Basic Homotopy Test</title>
<para>The following example shows how to load an off file and how to create three closed paths on this surface. Contractibility and free homotopy tests are then performed. The example also shows how to use the CGAL viewer if CGAL_Qt6 is enabled. <linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2path_homotopy_double_torus_8cpp-example" kindref="compound">Surface_mesh_topology/path_homotopy_double_torus.cpp</ref> <programlisting filename="Surface_mesh_topology/path_homotopy_double_torus.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_constructors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_face_graph_with_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2,3&gt;</ref><sp/>LCC_3_cmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL_1_1Surface__mesh__topology" kindref="compound">CGAL::Surface_mesh_topology</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_1(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(14);<sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;7;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_2(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>({202,<sp/>206,<sp/>335,<sp/>317,<sp/>322,<sp/>69,<sp/>62,<sp/>414});<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_3(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(470);<sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;13;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>=(argc&gt;1?std::string(argv[1])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">:</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3_cmap<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!CGAL::load_off(lcc,<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/double-torus-example.off&quot;</highlight><highlight class="normal">).c_str()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;ERROR<sp/>reading<sp/>file<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/double-torus-example.off&quot;</highlight><highlight class="normal">)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Curves_on_surface_topology&lt;LCC_3_cmap&gt;</ref><sp/>cst(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref><sp/>p1(lcc),<sp/>p2(lcc),<sp/>p3(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_1(p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_2(p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_3(p3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res1=cst.is_contractible(p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p1<sp/>(pink)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res1?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>contractible.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res2=cst.are_freely_homotopic(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p1<sp/>(pink)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res2?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>homotopic<sp/>with<sp/>path<sp/>p2<sp/>(green).&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res3=cst.are_freely_homotopic(p1,<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p1<sp/>(pink)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res3?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>homotopic<sp/>with<sp/>path<sp/>p3<sp/>(orange).&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cycles={p1,<sp/>p2,<sp/>p3};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::draw</ref>(lcc,<sp/>cycles);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1SMTopology_Example_VI">
<title>Basic Simplicity Test</title>
<para>The following example shows how to test the simplicity of a closed path on a double torus. The original path is visualized if CGAL_Qt6 is enabled. <linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2path_simplicity_double_torus_2_8cpp-example" kindref="compound">Surface_mesh_topology/path_simplicity_double_torus_2.cpp</ref> <programlisting filename="Surface_mesh_topology/path_simplicity_double_torus_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_for_combinatorial_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Linear_cell_complex_constructors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_face_graph_with_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Linear__cell__complex__for__combinatorial__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::Linear_cell_complex_for_combinatorial_map&lt;2,3&gt;</ref><sp/>LCC_3_cmap;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL_1_1Surface__mesh__topology" kindref="compound">CGAL::Surface_mesh_topology</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(682);<sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;11;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;5;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;2;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;5;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;2;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;2;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;8;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;4;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;5;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;5;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;3;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;11;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>=(argc&gt;1?std::string(argv[1])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">:</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>LCC_3_cmap<sp/>lcc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!CGAL::load_off(lcc,<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/double-torus-example.off&quot;</highlight><highlight class="normal">).c_str()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;ERROR<sp/>reading<sp/>file<sp/>data/double-torus.off&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Curves_on_surface_topology&lt;LCC_3_cmap&gt;</ref><sp/>cst(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;LCC_3_cmap&gt;</ref><sp/>p(lcc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path(p);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res=cst.is_homotopic_to_simple_cycle(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p<sp/>(pink)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>simple.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cycles={p};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::draw</ref>(lcc,<sp/>cycles);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1SMTopology_Example_VI_VII">
<title>Polygonal Schema</title>
<para>Here, we show with two examples how to create a surface from a list of faces specified by edge label sequences. In this first example, we build a genus two torus surface from a single face, also called a polygonal schema. See left <ref refid="index_1fig__fig_sm_incremental-builder" kindref="member">fig__fig_sm_incremental-builder</ref> for an illustration. Two closed paths are then created. The paths are freely homotopic but not homotopic with fixed endpoint. <linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2path_homotopy_with_symbols_8cpp-example" kindref="compound">Surface_mesh_topology/path_homotopy_with_symbols.cpp</ref> <programlisting filename="Surface_mesh_topology/path_homotopy_with_symbols.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygonal_schema.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL_1_1Surface__mesh__topology" kindref="compound">CGAL::Surface_mesh_topology</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Polygonal__schema__with__combinatorial__map" kindref="compound">Polygonal_schema_with_combinatorial_map&lt;&gt;</ref><sp/>PS;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PS<sp/>ps;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_facet(</highlight><highlight class="stringliteral">&quot;a<sp/>b<sp/>-a<sp/>-b<sp/>c<sp/>d<sp/>-c<sp/>-d&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;PS&gt;</ref><sp/>p1(ps);<sp/>p1.push_back_by_label(</highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;PS&gt;</ref><sp/>p2(ps);<sp/>p2.push_back_by_label(</highlight><highlight class="stringliteral">&quot;b<sp/>c<sp/>a<sp/>-c<sp/>-b&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Curves_on_surface_topology&lt;PS&gt;</ref><sp/>cst(ps);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res1=cst.are_freely_homotopic(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Paths<sp/>p1<sp/>and<sp/>p2<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res1?</highlight><highlight class="stringliteral">&quot;ARE&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;ARE<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>freely<sp/>homotopic.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res2=cst.are_base_point_homotopic(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Paths<sp/>p1<sp/>and<sp/>p2<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res2?</highlight><highlight class="stringliteral">&quot;ARE&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;ARE<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>base<sp/>point<sp/>homotopic.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
<para>In this second example, we build a genus two torus surface from a set of three squares. See middle <ref refid="index_1fig__fig_sm_incremental-builder" kindref="member">fig__fig_sm_incremental-builder</ref> for an illustration. The first two faces are added each with a single call to the member function <computeroutput>add_facet()</computeroutput>. The third face is build incrementally by adding its edge labels one at a time. We then create a contractible closed path. <linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2path_homotopy_with_symbols_2_8cpp-example" kindref="compound">Surface_mesh_topology/path_homotopy_with_symbols_2.cpp</ref> <programlisting filename="Surface_mesh_topology/path_homotopy_with_symbols_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygonal_schema.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Polygonal__schema__with__combinatorial__map" kindref="compound">CGAL::Surface_mesh_topology::Polygonal_schema_with_combinatorial_map&lt;&gt;</ref><sp/>PS;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PS<sp/>ps;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_facet(</highlight><highlight class="stringliteral">&quot;a<sp/>b<sp/>-a<sp/>c&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>First<sp/>facet,<sp/>giving<sp/>directly<sp/>its<sp/>sequence<sp/>of<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_facet(</highlight><highlight class="stringliteral">&quot;d<sp/>-c<sp/>e<sp/>-b&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>Second<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.init_facet();<sp/></highlight><highlight class="comment">//<sp/>Third<sp/>facet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_edges_to_facet(</highlight><highlight class="stringliteral">&quot;f&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>Here,<sp/>each<sp/>edge<sp/>is<sp/>added<sp/>one<sp/>at<sp/>a<sp/>time</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_edges_to_facet(</highlight><highlight class="stringliteral">&quot;-d&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_edges_to_facet(</highlight><highlight class="stringliteral">&quot;-f&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.add_edges_to_facet(</highlight><highlight class="stringliteral">&quot;-e&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.finish_facet();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.perforate_facet(</highlight><highlight class="stringliteral">&quot;f&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>cells<sp/>of<sp/>the<sp/>combinatorial<sp/>maps:<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ps.display_characteristics(std::cout)&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">CGAL::Surface_mesh_topology::Path_on_surface&lt;PS&gt;</ref><sp/>p(ps);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1afad1f86d456ab700558a703bb9dff496" kindref="member">push_back_by_label</ref>(</highlight><highlight class="stringliteral">&quot;a<sp/>b<sp/>-a<sp/>e<sp/>-b<sp/>d&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">CGAL::Surface_mesh_topology::Curves_on_surface_topology&lt;PS&gt;</ref><sp/>cst(ps);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res=cst.is_contractible(p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>contractible.&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1SMTopology_Example_VIII">
<title>Open Path</title>
<para>In this third example, we create non closed paths on the same mesh as in the first example and perform homotopy tests with fixed endpoints. Here, a <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref></computeroutput> is used as an alternative to a <computeroutput><ref refid="classCombinatorialMap" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Combinatorial_map.tag">CombinatorialMap</ref></computeroutput>. <linebreak/>
<bold>File</bold> <ref refid="Surface_mesh_topology_2open_path_homotopy_8cpp-example" kindref="compound">Surface_mesh_topology/open_path_homotopy.cpp</ref> <programlisting filename="Surface_mesh_topology/open_path_homotopy.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Curves_on_surface_topology.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Path_on_surface.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/draw_face_graph_with_paths.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_predicates_inexact_constructions_kernel<sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SM;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceCGAL_1_1Surface__mesh__topology" kindref="compound">CGAL::Surface_mesh_topology</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_1(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;SM&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(88);<sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;3;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_2(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;SM&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(300);<sp/><sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;3;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3b1629a7e6e46e0477166a18ae1d1e96" kindref="member">extend_negative_turn</ref>(2);<sp/>}<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_path_3(<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;SM&gt;</ref>&amp;<sp/>p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a3bf430e3e6fc0fd2d173b98cffcdb89d" kindref="member">push_back_by_index</ref>(87);<sp/></highlight><highlight class="comment">//<sp/>Its<sp/>starting<sp/>dart</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);<sp/></highlight><highlight class="comment">//<sp/>Extend<sp/>the<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;3;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(2);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>p.<ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface_1a1d84ab79576f8f41f5124c2b5fe7c55f" kindref="member">extend_positive_turn</ref>(1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>=(argc&gt;1?std::string(argv[1])==</highlight><highlight class="stringliteral">&quot;-draw&quot;</highlight><highlight class="normal">:</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/double-torus-example.off&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in.is_open())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;ERROR<sp/>reading<sp/>file<sp/>data/double-torus.off&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>SM<sp/>sm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in&gt;&gt;sm;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Curves_on_surface_topology&lt;SM&gt;</ref><sp/>cst(sm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Path__on__surface" kindref="compound">Path_on_surface&lt;SM&gt;</ref><sp/>p1(sm),<sp/>p2(sm),<sp/>p3(sm);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_1(p1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_2(p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_path_3(p3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res1=cst.are_base_point_homotopic(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p1<sp/>(pink)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res1?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>base<sp/>point<sp/>homotopic<sp/>with<sp/>path<sp/>p2<sp/>(green).&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>res2=cst.are_base_point_homotopic(p2,<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;Path<sp/>p2<sp/>(green)<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;(res2?</highlight><highlight class="stringliteral">&quot;IS&quot;</highlight><highlight class="normal">:</highlight><highlight class="stringliteral">&quot;IS<sp/>NOT&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;</highlight><highlight class="stringliteral">&quot;<sp/>base<sp/>point<sp/>homotopic<sp/>with<sp/>path<sp/>p3<sp/>(orange).&quot;</highlight><highlight class="normal">&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">draw</ref>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cycles={p1,<sp/>p2,<sp/>p3};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgDrawLinearCellComplex_1gaf1430ae5975d4186d8a9a873959826fc" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Linear_cell_complex.tag">CGAL::draw</ref>(sm,<sp/>cycles);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1SMTopology_Benchmarks">
<title>Benchmarks</title>
<para>The machine used is a PC running Ubuntu 18.04 with an Intel CPU Core i7-4790 CPU clocked at 3.60GHz with 32GB of RAM.</para>
<sect2 id="index_1SMTopology_bench1">
<title>Combinatorial Surface Topology Computation Time</title>
<para>The first time an homotopy test is called, we build a special quadrangulation of the surface as internal representation (as explained in Section <ref refid="index_1SMTopology_Theory" kindref="member">Implementation Details</ref>). The complexity of this operation is linear in the number of darts of the input surface, as we can see in <ref refid="index_1fig__fig_sm_topology_bench1" kindref="member">fig__fig_sm_topology_bench1</ref>.</para>
<para>For this benchmark, we computed 38 <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput> objects for different input surfaces with different number of darts (between 8,000 and 30,000,000). We show in the figure the computation time of the quadrangulation according to the number of darts of the input surface. We remind that this computation needs be done only once if you want to perform several path homotopy tests on the same surface.</para>
<para><anchor id="index_1fig__fig_sm_topology_bench1"/> <image type="html" name="computation-time-reduce-surface.svg"></image>
 <image type="latex" name="computation-time-reduce-surface.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_sm_topology_bench1" kindref="member">fig__fig_sm_topology_bench1</ref> Computation time of <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput> constructions, according to the number of darts or the input surface. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1SMTopology_bench2">
<title>Path Homotopy Tests</title>
<para>In this second benchmark, we use two surfaces as input (with respectively 543,652 vertices, 1,631,574 edges and 1,087,716 faces, and 55,498 vertices, 167,106 edges and 111,404 faces). We generate 100 random pairs of closed paths on each surface. The first path is generated randomly, with a lower bound for its length given by a random number between 100 and 10,000: passed the lower bound, the path is randomly extended until it returns to its origin vertex. The second path is generated from a sequence of elementary deformations of the first path, so that the two paths are homotopic. The number of elementary deformations is a random number between 100 and 10,000.</para>
<para>The computation time of the 200 <computeroutput>are_freely_homotopic()</computeroutput> tests are given in <ref refid="index_1fig__fig_sm_topology_bench2" kindref="member">fig__fig_sm_topology_bench2</ref>, according to the number of darts of the two input paths.</para>
<para><anchor id="index_1fig__fig_sm_topology_bench2"/> <image type="html" name="computation-time-path-homotopy.svg"></image>
 <image type="latex" name="computation-time-path-homotopy.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_sm_topology_bench2" kindref="member">fig__fig_sm_topology_bench2</ref> Computation time of <computeroutput>are_freely_homotopic()</computeroutput> tests, according to the number of darts or the input paths. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The third benchmark is similar to the previous one, except that we use a genus 5 surface with one vertex, 10 edges and 1 face. The length of the paths to be tested is varied between 10 and 30,000,000. The computation time of the <computeroutput>are_freely_homotopic()</computeroutput> tests are given in <ref refid="index_1fig__fig_sm_topology_bench3" kindref="member">fig__fig_sm_topology_bench3</ref>. The free homotopy test takes 17 seconds for paths of length 10,000,000. <anchor id="index_1fig__fig_sm_topology_bench3"/> <image type="html" name="computation-time-polygonal-schema.svg"></image>
 <image type="latex" name="computation-time-polygonal-schema.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_sm_topology_bench3" kindref="member">fig__fig_sm_topology_bench3</ref> Computation time of <computeroutput>are_freely_homotopic()</computeroutput> tests, according to the number of darts or the input paths for random paths on the canonical reduced surface of genus five. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Note that the linear time implementation of the algorithms is remarkably observed in each benchmark.</para>
</sect2>
</sect1>
<sect1 id="index_1SMTopology_Theory">
<title>Implementation Details</title>
<sect2 id="index_1SMTopology_SNC">
<title>Compute Shortest Non-Contractible Cycle</title>
<para>The algorithm to find shortest non-contractible cycle through a vertex in <ref refid="citelist_1CITEREF_cvl-ew-12" kindref="member">[1]</ref> can be summarized as follows.</para>
<para>A mesh <formula id="0">$\cal{M}$</formula> consists of components such as vertices, edges, and faces, thus it can be seen as a graph <formula id="10">$G$</formula> embedded in the surface <formula id="11">$\Sigma$</formula>.</para>
<para>Let <formula id="12">$T$</formula> be a spanning tree of <formula id="10">$G$</formula>. Let <formula id="13">$C^*$</formula> be the subgraph of the dual graph <formula id="14">$G^*$</formula> of <formula id="10">$G$</formula> with the same vertex set as <formula id="14">$G^*$</formula> and the edge set be <formula id="15">$E(G^*)\backslash E(T)^*$</formula>. Repeatedly remove from <formula id="13">$C^*$</formula> the edges with an incident vertex of degree one, the remaining set of edges is denoted as <formula id="16">$E_{nc}(T)^*$</formula>. It has been proven that for any edge <formula id="17">$ab\in E_{nc}(T)$</formula>, the concatenation of the path from a vertex <formula id="18">$v$</formula> following <formula id="12">$T$</formula> to <formula id="19">$a$</formula>, the edge <formula id="20">$ab$</formula>, and the path from <formula id="21">$b$</formula> following <formula id="12">$T$</formula> back to <formula id="18">$v$</formula> is a closed path (denoted as <formula id="22">$\tau(T, v, ab)$</formula>) and is non-contractible. Furthermore, if <formula id="12">$T$</formula> is a BFS tree (or Dijkstra tree in the weighted case) rooted at <formula id="18">$v$</formula>, the shortest cycle found among <formula id="23">$\tau(T, v, e)$</formula> for any <formula id="24">$e\in E_{nc}(T)$</formula> is the shortest non-contractible cycle through <formula id="18">$v$</formula>.</para>
<para>Although it is said in <ref refid="index_1SMTopology_Input" kindref="member">Specifying the Input Surface and Curves</ref> that the given mesh should be closed (no dart is 2-free), the algorithm to find shortest non-contractible cycles also works if the surface contains boundaries.</para>
</sect2>
<sect2 id="index_1SMTopology_Facewidth">
<title>Compute Face Width</title>
<para>The reader is recommended to read the section <ref refid="index_1SMTopology_SNC" kindref="member">Compute Shortest Non-Contractible Cycle</ref> before reading this section.</para>
<para>The face width is the minimum number of intersection points between <formula id="10">$G$</formula> and any non-contractible cycle of <formula id="11">$\Sigma$</formula> (these cycles do not necessarily follow the edges of <formula id="10">$G$</formula>). As a result, the face width of <formula id="10">$G$</formula> is half the edge width of <formula id="25">$R(G)$</formula>, where <formula id="25">$R(G)$</formula> denotes the radial graph of <formula id="10">$G$</formula>. The radial graph of <formula id="10">$G$</formula> is a bipartite graph, constructed as follows. Start with the original graph. For every face of the original graph, add a vertex in the interior of the face and connect this vertex to all the vertices of the face. After doing this for all faces, remove all edges from the original graph.</para>
</sect2>
<sect2 id="index_1SMTopology_Quad_System">
<title>Reducing to a Quadrangulation</title>
<para>A <emphasis>quadrangulation</emphasis> is a combinatorial map whose faces are quadrilaterals, i.e. have four sides. For efficiency of the homotopy test, the input combinatorial surface <formula id="0">$\cal{M}$</formula> is first turned into a quadrangulation with only two vertices. The transformation is performed as follows.<orderedlist>
<listitem><para>A spanning tree of the graph composed of the vertices and edges of <formula id="0">$\cal{M}$</formula> is computed. See <ref refid="index_1fig__fig_spanning_tree" kindref="member">fig__fig_spanning_tree</ref>. <anchor id="index_1fig__fig_spanning_tree"/> <image type="html" name="spanning_tree.svg"></image>
 <image type="latex" name="spanning_tree.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_spanning_tree" kindref="member">fig__fig_spanning_tree</ref> Left, a combinatorial map with three faces (red, yellow, green). Right, a spanning tree of its graph. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>The edges of the spanning are contracted. The resulting surface has the same topology as <formula id="0">$\cal{M}$</formula> and has a single vertex. <anchor id="index_1fig__fig_contract_tree"/> <image type="html" name="contract_tree.svg"></image>
 <image type="latex" name="contract_tree.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_contract_tree" kindref="member">fig__fig_contract_tree</ref> The contraction of a spanning tree merges all the vertices into a single vertex. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>The faces are merged into a single face by iteratively erasing edges incident to distinct faces. Those edges corresponds to a spanning tree of the dual combinatorial map. <anchor id="index_1fig__fig_merge_faces"/> <image type="html" name="merge_faces.svg"></image>
 <image type="latex" name="merge_faces.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_merge_faces" kindref="member">fig__fig_merge_faces</ref> The green, red and yellow faces are merged by removing edges. The resulting <emphasis>reduced surface</emphasis> has a single vertex and a single face. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
 Cutting through the graph of the reduced surface, we obtain a face that can be flattened into the plane. <anchor id="index_1fig__fig_cut-open"/> <image type="html" name="cut-open.svg"></image>
 <image type="latex" name="cut-open.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_cut-open" kindref="member">fig__fig_cut-open</ref> If <formula id="0">$\cal{M}$</formula> is obtained by gluing <formula id="8">$g$</formula> tori, i.e. <formula id="0">$\cal{M}$</formula> has genus <formula id="8">$g$</formula>, the cut-open reduced surface has <formula id="26">$4g$</formula> sides. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>A vertex is introduced in the middle of this unique face and joined by new edges to the corners of this face to form a triangulation with <formula id="26">$4g$</formula> triangles. Gluing back along the (old) edges of the reduced surface and deleting them amounts to merge the triangles by pairs. We thus obtain a quadrangulated surface <formula id="27">$\cal{Q}$</formula> with <formula id="7">$2g$</formula> quadrilaterals, <formula id="26">$4g$</formula> edges and 2 vertices. <anchor id="index_1fig__fig_quad_mesh"/> <image type="html" name="quad_mesh.svg"></image>
 <image type="latex" name="quad_mesh.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_quad_mesh" kindref="member">fig__fig_quad_mesh</ref> Triangles of the same color are merged into quadrilaterals. All the light blue vertices correspond to a same vertex on the glued surface. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem></orderedlist>
</para>
<para>This quadrangulation <formula id="27">$\cal{Q}$</formula> is stored in a <computeroutput><ref refid="classCGAL_1_1Surface__mesh__topology_1_1Curves__on__surface__topology" kindref="compound">Surface_mesh_topology::Curves_on_surface_topology</ref></computeroutput>. In order to perform a homotopy test, each input curve <formula id="28">$C$</formula> is transformed into a (closed) path in <formula id="27">$\cal{Q}$</formula> as follows. If an edge of <formula id="28">$C$</formula> is part of the contracted spanning tree, we simply ignore that edge. Otherwise the edge can be replaced by two consecutive edges of <formula id="27">$\cal{Q}$</formula> to obtain a new path <formula id="29">$C&apos;$</formula> in the vertex-edge graph of <formula id="27">$\cal{Q}$</formula> so that <formula id="29">$C&apos;$</formula> is a continuous deformation of <formula id="28">$C$</formula>. Hence, deciding if <formula id="28">$C$</formula> is contractible in <formula id="0">$\cal{M}$</formula> is equivalent to test if <formula id="29">$C&apos;$</formula> is contractible in <formula id="27">$\cal{Q}$</formula>.</para>
</sect2>
<sect2 id="index_1SMTopology_Canonical">
<title>Canonical Form</title>
<para>In order to test if two input curves <formula id="28">$C$</formula> and <formula id="30">$D$</formula> in <formula id="0">$\cal{M}$</formula> are homotopic they are first replaced by curves <formula id="29">$C&apos;$</formula> and <formula id="31">$D&apos;$</formula> in <formula id="27">$\cal{Q}$</formula> as above. Those curves are further transformed into <emphasis>canonical forms</emphasis> that only depend on their homotopy classes. The transformation to canonical form relies on three basic operations that we now describe.<orderedlist>
<listitem><para>A <emphasis>bracket</emphasis> in a curve is a subsequence of edges along a row of quadrilaterals, surrounded by two edges along the end sides of the row. A bracket can be flattened by replacing the corresponding subpath with a shorter subpath going along the other long side of the row. See <ref refid="index_1fig__fig_bracket" kindref="member">fig__fig_bracket</ref>. <anchor id="index_1fig__fig_bracket"/> <image type="html" name="bracket.svg"></image>
 <image type="latex" name="bracket.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_bracket" kindref="member">fig__fig_bracket</ref> Left, a blue curve in a quadrangulation (for clarity the quadrangulation has more than two vertices). Middle, a bracket of the blue curve. Right, the bracket has been flattened. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>A <emphasis>spur</emphasis> in a curve is a subsequence of two opposite edges. A spur can be deleted to shorten the curve. See <ref refid="index_1fig__fig_spur" kindref="member">fig__fig_spur</ref>. <anchor id="index_1fig__fig_spur"/> <image type="html" name="spur.svg"></image>
 <image type="latex" name="spur.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_spur" kindref="member">fig__fig_spur</ref> Removing a spur. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>A <emphasis>right L-shape</emphasis> in a curve is a subsequence of edges going along the exterior side of a sequence of quadrilaterals forming an L, with the interior of the L to its right. This notion takes into account the traversal direction of the curve. A right L-shape subpath can be pushed to the right by replacing it with the other side of the L-shaped sequence of quadrilaterals. See <ref refid="index_1fig__fig_push_right" kindref="member">fig__fig_push_right</ref> <anchor id="index_1fig__fig_push_right"/> <image type="html" name="push_right.svg"></image>
 <image type="latex" name="push_right.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_push_right" kindref="member">fig__fig_push_right</ref> Pushing an L-shaped subpath to its right. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem></orderedlist>
</para>
<para>The canonical form of a curve is obtained by flattening its brackets, removing its spurs and pushing its right L-shapes to the right until the curve has no more brackets, spurs or L-shapes. This can be done in time proportional to the number of edges of the curve. Note that the above three operations preserve the homotopy class of the curve.</para>
</sect2>
<sect2 id="index_1SMTopology_Homotopy_Test">
<title>Homotopy Test</title>
<para>It can be proven that the canonical form is uniquely defined and only depends on the homotopy class of the curve. Hence, the curves <formula id="29">$C&apos;$</formula> and <formula id="31">$D&apos;$</formula> in <formula id="27">$\cal{Q}$</formula> are homotopic if and only if their canonical forms are equal. Since each curve is defined as a sequence of (oriented) edges up to a cyclic permutation, we resort to the Knuth-Morris-Pratt algorithm to decide in linear time if the canonical forms are the same up to a cyclic permutation.</para>
</sect2>
<sect2 id="index_1SMTopology_Simplicity_Test">
<title>Simplicity Test</title>
<para>The simplicity test relies on the fact that a closed curve is homotopic to a simple one if and only if its canonical form can be made intersection free via infinitesimal perturbations together with some homotopy preserving operations. One can imagine each edge in the quadrangulation has a width and each vertex in the quadrangulation has an area so that paths visiting the same vertex/edge multiple times can avoid intersection after perturbation within a vertex or an edge. See <ref refid="index_1fig__fig_perturbation_sample" kindref="member">fig__fig_perturbation_sample</ref> for an example. <anchor id="index_1fig__fig_perturbation_sample"/> <image type="html" name="perturbation_sample.svg"></image>
 <image type="latex" name="perturbation_sample.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_perturbation_sample" kindref="member">fig__fig_perturbation_sample</ref> Applying a perturbation to remove 2 intersections between the red and the blue subpaths. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Such a perturbation can be encoded as a transverse ordering of the edges from the canonical form which traverse the same edge in the quadrangulation. The idea of the algorithm is to traverse the canonical form, one edge at a time, to inductively build such orderings and try to avoid intersection as best as we can.</para>
<sect3 id="index_1SMTopology_Simplicity_Test_Primitive">
<title>Detect Repetition</title>
<para>There is an easy case where we know for sure that a closed curve cannot be deformed to simple one: If the canonical form can be expressed as concatenation of two or more copies of the same path. So the first step of the algorithm is to detect repetition.</para>
<para>Let <formula id="32">$P$</formula> be a path and let <formula id="33">$+$</formula> be the operator of concatenation. It can be shown that <formula id="32">$P$</formula> contains no repetition if and only if there are only 2 matchings of <formula id="32">$P$</formula> in <formula id="34">$P+P$</formula> (matching the first and the second copy). The algorithm resorts to the Knuth-Morris-Pratt algorithm to decide in linear time if the canonical form contains repetitions.</para>
</sect3>
<sect3 id="index_1SMTopology_Simplicity_Test_Switch">
<title>Avoid Crossing by Switching</title>
<para>Apart from applying perturbation, the algorithm also tries to avoid crossings using a homotopy-preserving operation called as a <emphasis>switch</emphasis>. A switch is triggered whenever an intersection could be avoided by turning a left L-shaped subpath into a right L-shaped subpath. See <ref refid="index_1fig__fig_switch_sample" kindref="member">fig__fig_switch_sample</ref> for an example. <anchor id="index_1fig__fig_switch_sample"/> <image type="html" name="switch_sample.svg"></image>
 <image type="latex" name="switch_sample.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_switch_sample" kindref="member">fig__fig_switch_sample</ref> Top-left, an intersection between the red subpath and the green subpath at the start of the left L-shaped red subpath. Top-right, switch the left L-shape to right L-shape to avoid the intersection. Bottom-left or right, no switch is performed because no intersection can be avoided. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect3>
<sect3 id="index_1SMTopology_Simplicity_Test_Relative_Order">
<title>Decide Relative Order</title>
<para>As the algorithm inductively builds orderings, it has to determine a relative order between the edge being processed and the edges that have been ordered. There are three cases to consider.</para>
<para><orderedlist>
<listitem><para>The current edge and its predecessor, say <formula id="35">$e$</formula>, form a subpath of length two so that a parallel copy of this subpath has already been processed, and <formula id="35">$e$</formula> is adjacent to its parallel copy in the previously constructed ordering. In this case, the current edge must be adjacent to its copy in the transverse ordering. See <ref refid="index_1fig__fig_relative_order_corner" kindref="member">fig__fig_relative_order_corner</ref>. <anchor id="index_1fig__fig_relative_order_corner"/> <image type="html" name="relative_order_corner.svg"></image>
 <image type="latex" name="relative_order_corner.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_relative_order_corner" kindref="member">fig__fig_relative_order_corner</ref> The red edge is being processed. The blue edge is adjacent to the green edge (the predecessor <formula id="35">$e$</formula> of the red edge) in the previously constructed ordering and forms the same turn (blue-pink turn) as the green-red turn. The red edge should be right next to the pink edge in the ordering so as to avoid crossings. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>When the previous situation does not occur, the current edge has to be compared against every parallel copy already processed. In this case, the predecessors of the copy and of the current edge form a Y shape with the current edge. The circular order of the edges in this Y can be used to determine the relative order between the current edge and its copy. See <ref refid="index_1fig__fig_relative_order_normal" kindref="member">fig__fig_relative_order_normal</ref>. <anchor id="index_1fig__fig_relative_order_normal"/> <image type="html" name="relative_order_normal.svg"></image>
 <image type="latex" name="relative_order_normal.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_relative_order_normal" kindref="member">fig__fig_relative_order_normal</ref> The red edge is being processed and is compared against the pink edge. Since the green edge (the predecessor of the red edge) is to the right of the blue edge around the vertex, the red edge must be to the right of the pink edge in the transverse ordering. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem><listitem><para>There is one special case where the comparison of the current edge with a parallel copy cannot be deduced form previous computations: When this copy happens to be the very first edge processed in the traversal. Indeed, the predecessor of the first edge (aka the last edge of the path) has not been processed yet. If the last edge runs parallel to the predecessor of the current edge, we cannot determine their relative order. So the idea is to keep following the predecessors of the current edge and of the first edge until they diverge, at which point the relative order around the vertex can be used to determine the relative order. See <ref refid="index_1fig__fig_relative_order_first" kindref="member">fig__fig_relative_order_first</ref>. This can be precomputed by finding all the longest common suffixes of the path against its circular shifts. A modified Knuth-Morris-Pratt algorithm is applied to preprocess the path in linear time. <anchor id="index_1fig__fig_relative_order_first"/> <image type="html" name="relative_order_first.svg"></image>
 <image type="latex" name="relative_order_first.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__fig_relative_order_first" kindref="member">fig__fig_relative_order_first</ref> The red edge is being processed and is compared against the pink edge which is the first edge of the path. The blue and green edges are the first diverging pair when tracing backward. The dashed line means that edges have not been processed yet. Since the green edge lies to the right of the blue edge around the vertex, the red edge must be to the right of the pink edge in the ordering. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</listitem></orderedlist>
</para>
<para>The transverse orderings are stored in red-black trees, one for each edge of the quadrangulation. So each insertion or search takes <formula id="36">$O(\log{l})$</formula> time, where <formula id="3">$l$</formula> is the length of the closed curve.</para>
</sect3>
<sect3 id="index_1SMTopology_Simplicity_Test_Verification">
<title>Verify Ordering</title>
<para>After computing a tentative ordering within the edges of the path, we have to verify that such an ordering could result in an intersection free arrangement. Since there is no intersection within an edge, we only need to verify this for each vertex in the quadrangulation. Each vertex is naturally associated with a circular ordering of the incident path edges by concatenating clockwise the orderings computed for every incident edge in the quadrangulation. We consider the two consecutive edges composing a turn (one going in the vertex, one going out of the vertex) at the vertex being verified as a <emphasis>pair</emphasis>. The ordering at the vertex is intersection free if and only if there is no two pairs crossing each other according to the clockwise ordering around the vertex. In other words, for any two pairs <formula id="37">$(a, a&apos;)$</formula> and <formula id="38">$(b, b&apos;)$</formula>, none of the subsequences <formula id="39">$a, b, a&apos;, b&apos;$</formula> or <formula id="40">$a, b&apos;, a&apos;, b$</formula> should appear in the clockwise ordering. This is very similar to verifying balanced parentheses in a string. We traverse clockwise at each vertex and use a stack-based algorithm to verify in linear time that the ordering produces a cycle without self-intersection.</para>
</sect3>
</sect2>
</sect1>
<sect1 id="index_1Implementation">
<title>History</title>
<para>The code was developed in 2018 by Guillaume Damiand and Francis Lazarus. Felix Castillon contributed to the extension of the homotopy test to the case of surfaces with boundaries. Thien Hoang added methods to compute shortest non-contractible cycles, edge width and face width as part of the program Google Summer of Code 2019. Shuhao Tan added methods to test simplicity of a closed curve as part of the program Google Summer of Code 2020. </para>
</sect1>
    </detaileddescription>
    <location file="Surface_mesh_topology.txt"/>
  </compounddef>
</doxygen>
