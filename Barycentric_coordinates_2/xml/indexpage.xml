<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Generalized_Barycentric_Coordinates"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly></para>
<para><simplesect kind="authors"><para>Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez</para>
</simplesect>
</para>
<sect1 id="index_1gbc_introduction">
<title>Introduction</title>
<para>Barycentric coordinates are widely used in computer graphics and computational mechanics to determine a position of a point in the plane with respect to a triangle. These coordinates have been later generalized to support simple polygons in 2D and polyhedra in 3D.</para>
<para>This package offers an efficient and robust implementation of 2D generalized barycentric coordinates defined for simple polygons in the plane. If coordinates with respect to multivariate scattered points instead of a polygon are required, please refer to natural neighbor coordinates from the package <ref refid="index_1chapinterpolation" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Interpolation.tag">2D and Surface Function Interpolation</ref>.</para>
<para>In particular, this package includes an implementation of <ref refid="index_1wp_example" kindref="member">Wachspress</ref>, <ref refid="index_1dh_example" kindref="member">discrete harmonic</ref>, <ref refid="index_1mv_example" kindref="member">mean value</ref>, and <ref refid="index_1hm_example" kindref="member">harmonic</ref> coordinates, and provides some extra functions to compute barycentric coordinates with respect to <ref refid="index_1seg_example" kindref="member">segments</ref> and <ref refid="index_1tri_example" kindref="member">triangles</ref>.</para>
<para><anchor id="index_1fig__overview"/> <image type="html" name="overview.svg"></image>
 <image type="latex" name="overview.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__overview" kindref="member">fig__overview</ref> Wachspress (WP), discrete harmonic (DH), mean value (MV), and harmonic (HM) coordinate functions for a convex polygon plotted with respect to the marked vertex. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1gbc_interface">
<title>Software Design</title>
<para>Mean value and harmonic coordinates are the most generic coordinates in this package, because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates are, by definition, limited to strictly convex polygons. Segment coordinates take as input any non-degenerate segment, and triangle coordinates allow an arbitrary non-degenerate triangle.</para>
<para>Wachspress, discrete harmonic, mean value, and harmonic coordinates are all generalized barycentric coordinates. However, while Wachspress, discrete harmonic, and mean value coordinates can be computed analytically, harmonic coordinates cannot. They first need to be approximated over a triangulation of the interior part of the polygon. Once approximated, they can be evaluated analytically at any point inside the polygon.</para>
<para>For all analytic coordinates, we provide two algorithms. One has a linear time complexity, but may suffer imprecisions near the polygon boundary, while the second one is precise but has a quadratic time complexity. The user can choose the preferred algorithm by specifying a computation policy <computeroutput><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a478bbcec416216b2274ee4b4e97b0e6c" kindref="member">Barycentric_coordinates::Computation_policy_2</ref></computeroutput>.</para>
<para>All analytic barycentric coordinates for polygons can be computed either by instantiating a class or through one of the free functions. Harmonic coordinates can be computed only by instantiating a class that must be parameterized by a model of the concept <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1DiscretizedDomain__2" kindref="compound">DiscretizedDomain_2</ref></computeroutput>. Segment and triangle coordinates can be computed only through the free functions. For more information see the <ref refid="group__PkgBarycentricCoordinates2Ref" kindref="compound">Reference Manual</ref>.</para>
<para>Any point in the plane may be taken as a query point. However, we do not recommend using Wachspress and discrete harmonic coordinates with query points outside the closure of a polygon, because they are not well-defined for some of these points. The same holds for harmonic coordinates, which are not defined everywhere outside the polygon. For more information see Section <ref refid="index_1gbc_degeneracies" kindref="member">Edge Cases</ref>.</para>
<para>The output of the computation is a set of coordinate values at the given query point with respect to the polygon vertices. That means that the number of returned coordinates per query point equates the number of polygon vertices. The ordering of the coordinates is the same as the ordering of polygon vertices.</para>
<para>All class and function templates are parameterized by a traits class, which is a model of the concept <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1BarycentricTraits__2" kindref="compound">BarycentricTraits_2</ref></computeroutput>. It provides all necessary geometric primitives, predicates, and constructions, which are required for the computation. All models of <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> can be used. A polygon is provided as a range of vertices with a <ref refid="group__PkgPropertyMapRef" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">property map</ref> that maps a vertex from the polygon to <computeroutput><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Point_2</ref></computeroutput>.</para>
<para>If you do not know which coordinate function best fits your application, you can address the table below for some advise.</para>
<para><table rows="7" cols="6"><row>
<entry thead="yes" align='center'><para>Coordinates </para>
</entry><entry thead="yes" align='center'><para>Properties </para>
</entry><entry thead="yes" align='center'><para>Valid domain </para>
</entry><entry thead="yes" align='center'><para>Closed form </para>
</entry><entry thead="yes" align='center'><para>Queries </para>
</entry><entry thead="yes" align='center'><para>Speed  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Segment </para>
</entry><entry thead="no" align='center'><para>All </para>
</entry><entry thead="no" align='center'><para>2D non-degenerate segments </para>
</entry><entry thead="no" align='center'><para>Yes </para>
</entry><entry thead="no" align='center'><para>Everywhere on the supporting line </para>
</entry><entry thead="no" align='center'><para>+++  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Triangle </para>
</entry><entry thead="no" align='center'><para>All </para>
</entry><entry thead="no" align='center'><para>2D non-degenerate triangles </para>
</entry><entry thead="no" align='center'><para>Yes </para>
</entry><entry thead="no" align='center'><para>Everywhere in 2D </para>
</entry><entry thead="no" align='center'><para>+++  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Discrete harmonic </para>
</entry><entry thead="no" align='center'><para>May be negative </para>
</entry><entry thead="no" align='center'><para>Strongly convex polygons </para>
</entry><entry thead="no" align='center'><para>Yes </para>
</entry><entry thead="no" align='center'><para>Everywhere inside the polygon </para>
</entry><entry thead="no" align='center'><para>++  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Wachspress </para>
</entry><entry thead="no" align='center'><para>All </para>
</entry><entry thead="no" align='center'><para>Strongly convex polygons </para>
</entry><entry thead="no" align='center'><para>Yes </para>
</entry><entry thead="no" align='center'><para>Everywhere inside the polygon </para>
</entry><entry thead="no" align='center'><para>++  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Mean value </para>
</entry><entry thead="no" align='center'><para>May be negative </para>
</entry><entry thead="no" align='center'><para>Simple polygons </para>
</entry><entry thead="no" align='center'><para>Yes </para>
</entry><entry thead="no" align='center'><para>Everywhere in 2D </para>
</entry><entry thead="no" align='center'><para>++  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>Harmonic </para>
</entry><entry thead="no" align='center'><para>All </para>
</entry><entry thead="no" align='center'><para>Simple polygons </para>
</entry><entry thead="no" align='center'><para>No </para>
</entry><entry thead="no" align='center'><para>Everywhere inside the polygon </para>
</entry><entry thead="no" align='center'><para>+  </para>
</entry></row>
</table>
</para>
<para><simplesect kind="note"><para>This is the second version of the package with the modified and improved API. The package still supports the old API. See more details <ref refid="index_1depr_example" kindref="member">here</ref>.</para>
</simplesect>
</para>
</sect1>
<sect1 id="index_1gbc_examples">
<title>Examples</title>
<para>In order to facilitate the process of learning this package, we provide various examples with a basic usage of different barycentric components.</para>
<sect2 id="index_1seg_example">
<title>Segment Coordinates</title>
<para>This example illustrates the use of the global function <computeroutput><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gab856ca68d37f58e6cdf74c8aac6f4245" kindref="member">segment_coordinates_2()</ref></computeroutput>. We compute coordinates at three green points along the segment <formula id="0">$[v_0, v_1]$</formula> and at two blue points outside this segment but along its supporting line. The symmetry of the query points helps recognizing errors that may have occurred during construction of the example. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is exact.</para>
<para><anchor id="index_1seg_coord_example"/><anchor id="index_1fig__seg_example"/> <image type="html" name="seg_coord_example.svg"></image>
 <image type="latex" name="seg_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__seg_example" kindref="member">fig__seg_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2segment_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/segment_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/segment_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/segment_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>y<sp/>=<sp/>FT(2)<sp/>/<sp/>FT(5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>segment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>source(FT(0),<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>target(FT(2),<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>three<sp/>interior<sp/>and<sp/>two<sp/>exterior<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>queries<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(2)<sp/>/<sp/>FT(5),<sp/>y),<sp/></highlight><highlight class="comment">//<sp/>interior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(5)<sp/>/<sp/>FT(5),<sp/>y),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(8)<sp/>/<sp/>FT(5),<sp/>y),</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(-FT(1)<sp/>/<sp/>FT(5),<sp/>y),<sp/></highlight><highlight class="comment">//<sp/>exterior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(11)<sp/>/<sp/>FT(5),<sp/>y)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>segment<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(queries.size()<sp/>*<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>queries)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gab856ca68d37f58e6cdf74c8aac6f4245" kindref="member">CGAL::Barycentric_coordinates::segment_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>source,<sp/>target,<sp/>query,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>all<sp/>segment<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;segment<sp/>coordinates<sp/>(all<sp/>queries):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size();<sp/>i<sp/>+=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates[i<sp/>+<sp/>0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates[i<sp/>+<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1tri_example">
<title>Triangle Coordinates</title>
<para>In this example, we show how to use the global function <computeroutput><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gaa378786f8996dbcefe7923ebb711e4dd" kindref="member">triangle_coordinates_2()</ref></computeroutput>. We compute coordinates for three sets of points: interior (green), boundary (red), and exterior (blue). Note that some of the coordinate values for the exterior points are negative. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact.</para>
<para><anchor id="index_1tri_coord_example"/><anchor id="index_1fig__tri_example"/> <image type="html" name="tri_coord_example.svg"></image>
 <image type="latex" name="tri_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__tri_example" kindref="member">fig__tri_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2triangle_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/triangle_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/triangle_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/triangle_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>triangle.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>p0(0.0,<sp/>0.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>p1(2.0,<sp/>0.5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>p2(1.0,<sp/>2.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>several<sp/>interior,<sp/>boundary,<sp/>and<sp/>exterior<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>queries<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.50,<sp/>0.50),<sp/></highlight><highlight class="comment">//<sp/>interior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.00,<sp/>0.50),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.0,<sp/>0.75),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.00,<sp/>1.0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.00,<sp/>1.25),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.0,<sp/>1.50),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.75,<sp/>1.0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.25,<sp/>1.00),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.5,<sp/>0.75),</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2.0,<sp/>0.50),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.0,<sp/>2.00),<sp/></highlight><highlight class="comment">//<sp/>boundary<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.0,<sp/>0.25),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.5,<sp/>1.25),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.5,<sp/>1.0),</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.25,<sp/>1.00),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.50,<sp/>1.75),<sp/></highlight><highlight class="comment">//<sp/>exterior<sp/>query<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.50,<sp/>1.75),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1.75,<sp/>1.50)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>triangle<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(queries.size()<sp/>*<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>queries)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gaa378786f8996dbcefe7923ebb711e4dd" kindref="member">CGAL::Barycentric_coordinates::triangle_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p0,<sp/>p1,<sp/>p2,<sp/>query,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>all<sp/>triangle<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;triangle<sp/>coordinates<sp/>(all<sp/>queries):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size();<sp/>i<sp/>+=<sp/>3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates[i<sp/>+<sp/>0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates[i<sp/>+<sp/>1]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates[i<sp/>+<sp/>2]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1wp_example">
<title>Wachspress Coordinates</title>
<para>In the following example, we generate 100 random points (green/red/black), then we take the convex hull (red/black) of this set of points as our polygon (black), and compute Wachspress coordinates at all the generated points. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact.</para>
<para><anchor id="index_1wp_coord_example"/><anchor id="index_1fig__wp_example"/> <image type="html" name="wp_coord_example.svg"></image>
 <image type="latex" name="wp_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__wp_example" kindref="member">fig__wp_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2wachspress_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/wachspress_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/wachspress_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/convex_hull_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Wachspress_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Creator<sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;FT, Point_2&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Generator<sp/>=<sp/><ref refid="classCGAL_1_1Random__points__in__square__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Generator.tag">CGAL::Random_points_in_square_2&lt;Point_2, Creator&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Choose<sp/>how<sp/>many<sp/>query<sp/>points<sp/>we<sp/>want<sp/>to<sp/>generate.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>num_queries<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>vectors<sp/>to<sp/>store<sp/>query<sp/>points<sp/>and<sp/>polygon<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>queries,<sp/>convex;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>a<sp/>set<sp/>of<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.reserve(num_queries);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Generator<sp/>generator(1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy_n(generator,<sp/>num_queries,<sp/>std::back_inserter(queries));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>the<sp/>convex<sp/>hull<sp/>of<sp/>the<sp/>generated<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>convex<sp/>hull<sp/>gives<sp/>the<sp/>vertices<sp/>of<sp/>a<sp/>convex<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>contains<sp/>all<sp/>the<sp/>generated<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgConvexHull2Functions_1ga8241d43969ff61cb9be46811c2e9e176" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Convex_hull_2.tag">CGAL::convex_hull_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>queries.begin(),<sp/>queries.end(),<sp/>std::back_inserter(convex));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>Wachspress<sp/>coordinates<sp/>for<sp/>all<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Wachspress<sp/>coordinates<sp/>(interior<sp/>+<sp/>boundary):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(convex.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>queries)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1ga2b78df5ac4952fef00a0f132c2ab946f" kindref="member">CGAL::Barycentric_coordinates::wachspress_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>convex,<sp/>query,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1dh_example">
<title>Discrete Harmonic Coordinates</title>
<para>In this example, we compute discrete harmonic coordinates for a set of green (interior), red (boundary), and blue (exterior) points with respect to a unit square. We also demonstrate the use of various containers, both random access and serial access, different property maps, and the ability to choose a computation policy. For points on the polygon boundary, we use the free function <computeroutput><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1ga4724a05781aa56db0faff8cd3013c924" kindref="member">boundary_coordinates_2()</ref></computeroutput>. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is exact.</para>
<para><anchor id="index_1dh_coord_example"/><anchor id="index_1fig__dh_example"/> <image type="html" name="dh_coord_example.svg"></image>
 <image type="latex" name="dh_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__dh_example" kindref="member">fig__dh_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2discrete_harmonic_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/discrete_harmonic_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/discrete_harmonic_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/boundary_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Discrete_harmonic_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Info<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Info(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>_name)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>name(_name)<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>name;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vertex<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::pair&lt;Point_2,<sp/>Info&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Vertex&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vertex_range<sp/>=<sp/>std::vector&lt;Vertex&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Discrete_harmonic_coordinates_2<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Discrete_harmonic_coordinates_2&lt;Vertex_range, Kernel, Point_map&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Policy<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a478bbcec416216b2274ee4b4e97b0e6c" kindref="member">CGAL::Barycentric_coordinates::Computation_policy_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>kernel;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_map<sp/>point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Vertex&gt;<sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">square</ref><sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::make_pair(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0,<sp/>0),<sp/>Info(</highlight><highlight class="stringliteral">&quot;1&quot;</highlight><highlight class="normal">)),<sp/>std::make_pair(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>0),<sp/>Info(</highlight><highlight class="stringliteral">&quot;2&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::make_pair(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>1),<sp/>Info(</highlight><highlight class="stringliteral">&quot;3&quot;</highlight><highlight class="normal">)),<sp/>std::make_pair(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0,<sp/>1),<sp/>Info(</highlight><highlight class="stringliteral">&quot;4&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>class<sp/>with<sp/>discrete<sp/>harmonic<sp/>weights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>do<sp/>not<sp/>check<sp/>for<sp/>edge<sp/>cases<sp/>since<sp/>we<sp/>know<sp/>the<sp/>exact<sp/>positions</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>of<sp/>all<sp/>our<sp/>points.<sp/>We<sp/>speed<sp/>up<sp/>the<sp/>computation<sp/>by<sp/>using<sp/>the<sp/>O(n)<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Policy<sp/>policy<sp/>=<sp/>Policy::FAST;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Discrete_harmonic_coordinates_2<sp/>discrete_harmonic_2(<ref refid="group__PkgAlgebraicFoundationsRef_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">square</ref>,<sp/>policy,<sp/>kernel,<sp/>point_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>center<sp/>point<sp/>of<sp/>the<sp/>unit<sp/>square.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>center(FT(1)<sp/>/<sp/>FT(2),<sp/>FT(1)<sp/>/<sp/>FT(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>weights<sp/>for<sp/>the<sp/>center<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;FT&gt;<sp/>weights;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>discrete_harmonic_2.weights(center,<sp/>std::back_inserter(weights));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;discrete<sp/>harmonic<sp/>weights<sp/>(center):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT&amp;<sp/>weight<sp/>:<sp/>weights)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>weight<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>the<sp/>center<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>discrete_harmonic_2(center,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;discrete<sp/>harmonic<sp/>coordinates<sp/>(center):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT&amp;<sp/>coordinate<sp/>:<sp/>coordinates)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinate<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>several<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>interior_points<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(1)<sp/>/<sp/>FT(5),<sp/>FT(1)<sp/>/<sp/>FT(5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(4)<sp/>/<sp/>FT(5),<sp/>FT(1)<sp/>/<sp/>FT(5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(4)<sp/>/<sp/>FT(5),<sp/>FT(4)<sp/>/<sp/>FT(5)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(1)<sp/>/<sp/>FT(5),<sp/>FT(4)<sp/>/<sp/>FT(5))<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>weights<sp/>for<sp/>all<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;discrete<sp/>harmonic<sp/>weights<sp/>(interior):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>ws;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>interior_points)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ws.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>discrete_harmonic_2.weights(query,<sp/>std::back_inserter(ws));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ws.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>ws[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>ws[ws.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>all<sp/>interior<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;discrete<sp/>harmonic<sp/>coordinates<sp/>(interior):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>bs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>interior_points)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bs.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>discrete_harmonic_2(query,<sp/>std::back_inserter(bs));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>bs.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>bs[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>bs[bs.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>2<sp/>boundary<sp/>points<sp/>on<sp/>the<sp/>second<sp/>and<sp/>fourth<sp/>edges.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>e2(1,<sp/>FT(4)<sp/>/<sp/>FT(5));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>e4(0,<sp/>FT(4)<sp/>/<sp/>FT(5));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>=<sp/>boundary<sp/>coordinates</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>these<sp/>2<sp/>points<sp/>one<sp/>by<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1ga4724a05781aa56db0faff8cd3013c924" kindref="member">CGAL::Barycentric_coordinates::boundary_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">square</ref>,<sp/>e2,<sp/>std::back_inserter(coordinates),<sp/>kernel,<sp/>point_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1ga4724a05781aa56db0faff8cd3013c924" kindref="member">CGAL::Barycentric_coordinates::boundary_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">square</ref>,<sp/>e4,<sp/>std::back_inserter(coordinates),<sp/>kernel,<sp/>point_map);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;boundary<sp/>coordinates<sp/>(edge<sp/>2<sp/>and<sp/>edge<sp/>4):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT&amp;<sp/>coordinate<sp/>:<sp/>coordinates)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinate<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>6<sp/>other<sp/>boundary<sp/>points:<sp/>2<sp/>on<sp/>the<sp/>first<sp/>and<sp/>third<sp/>edges<sp/>respectively</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>4<sp/>at<sp/>the<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>es13<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(1)<sp/>/<sp/>FT(2),<sp/>0),<sp/></highlight><highlight class="comment">//<sp/>edges</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(FT(1)<sp/>/<sp/>FT(2),<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>vertices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0,<sp/>0),<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>1),<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0,<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>=<sp/>boundary<sp/>coordinates<sp/>for<sp/>all<sp/>6<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;boundary<sp/>coordinates<sp/>(edge<sp/>1,<sp/>edge<sp/>3,<sp/>and<sp/>vertices):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>es13)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bs.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1ga4724a05781aa56db0faff8cd3013c924" kindref="member">CGAL::Barycentric_coordinates::boundary_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga07001b5ddc5c43096c811c91a306be9a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">square</ref>,<sp/>query,<sp/>std::back_inserter(bs),<sp/>point_map);<sp/></highlight><highlight class="comment">//<sp/>we<sp/>can<sp/>skip<sp/>kernel<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>bs.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>bs[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>bs[bs.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>2<sp/>points<sp/>outside<sp/>the<sp/>unit<sp/>square<sp/>-<sp/>one<sp/>from<sp/>the<sp/>left<sp/>and<sp/>one<sp/>from<sp/>the<sp/>right.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Even<sp/>if<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>may<sp/>not<sp/>be<sp/>valid<sp/>for<sp/>some<sp/>exterior<sp/>points,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>can<sp/>still<sp/>do<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>l(FT(-1)<sp/>/<sp/>FT(2),<sp/>FT(1)<sp/>/<sp/>FT(2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>r(FT(3)<sp/><sp/>/<sp/>FT(2),<sp/>FT(1)<sp/>/<sp/>FT(2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>discrete<sp/>harmonic<sp/>coordinates<sp/>for<sp/>all<sp/>exterior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>discrete_harmonic_2(l,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>discrete_harmonic_2(r,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;discrete<sp/>harmonic<sp/>coordinates<sp/>(exterior):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT&amp;<sp/>coordinate<sp/>:<sp/>coordinates)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinate<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1mv_example">
<title>Mean Value Coordinates</title>
<para>This is an example that illustrates how to compute mean value coordinates for a set of green points in a star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon while Wachspress and discrete harmonic coordinates are not. However, it may yield negative coordinate values for points outside <ulink url="https://en.wikipedia.org/wiki/Star-shaped_polygon">the polygon&apos;s kernel</ulink> (shown in red). We speed up the computation using the linear time complexity algorithm by specifying a computation policy <computeroutput><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a478bbcec416216b2274ee4b4e97b0e6c" kindref="member">Barycentric_coordinates::Computation_policy_2</ref></computeroutput>. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact.</para>
<para><anchor id="index_1mv_coord_example"/><anchor id="index_1fig__mv_example"/> <image type="html" name="mv_coord_example.svg"></image>
 <image type="latex" name="mv_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__mv_example" kindref="member">fig__mv_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2mean_value_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/mean_value_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/mean_value_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Mean_value_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Policy<sp/><sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a478bbcec416216b2274ee4b4e97b0e6c" kindref="member">CGAL::Barycentric_coordinates::Computation_policy_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>star-shaped<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>star_shaped<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.0,<sp/>0.0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(<sp/>0.1,<sp/>-0.8),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.3,<sp/>0.0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.6,<sp/>-0.5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.6,<sp/>0.1),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(<sp/>1.1,<sp/><sp/>0.6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.3,<sp/>0.2),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.1,<sp/><sp/>0.8),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.1,<sp/>0.2),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(-0.7,<sp/><sp/>0.0)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>some<sp/>interior<sp/>points<sp/>in<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>interior_points<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.12,<sp/>-0.45),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.55,<sp/>-0.3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.9<sp/>,<sp/>0.45),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.15,<sp/><sp/>0.35),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(-0.4,<sp/>0.04),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.11,<sp/>0.11),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.28,<sp/><sp/>0.12),<sp/></highlight><highlight class="comment">//<sp/>the<sp/>only<sp/>point<sp/>in<sp/>the<sp/>kernel<sp/>of<sp/>the<sp/>star<sp/>shaped<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.55,<sp/><sp/>0.11)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Choose<sp/>a<sp/>computation<sp/>policy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>do<sp/>not<sp/>check<sp/>for<sp/>edge<sp/>cases<sp/>since<sp/>we<sp/>know</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>all<sp/>our<sp/>points<sp/>are<sp/>strictly<sp/>interior.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Policy<sp/>policy<sp/>=<sp/>Policy::PRECISE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>vector<sp/>`std::vector`<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(star_shaped.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>coordinates<sp/>for<sp/>all<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;mean<sp/>value<sp/>coordinates<sp/>(interior):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>interior_points)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gad9337f53ea56d65708bb42e4ee3415aa" kindref="member">CGAL::Barycentric_coordinates::mean_value_coordinates_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>star_shaped,<sp/>query,<sp/>std::back_inserter(coordinates),<sp/>policy);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>mean<sp/>value<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1hm_example">
<title>Harmonic Coordinates</title>
<para>This example illustrates how to <ref refid="index_1terrain_triangulation_fig" kindref="member">discretize</ref> the interior part of the <ref refid="index_1terrain_example_fig" kindref="member">polygon</ref> and compute harmonic coordinates at the vertices of the discretized domain, which is represented by a 2D Delaunay triangulation. Once computed, harmonic coordinate functions can be evaluated at any point in the closure of the polygon. To illustrate such an evaluation, we compute the barycenter of each triangle and evaluate harmonic coordinates at this barycenter. Since harmonic coordinates can only be approximated, the used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact.</para>
<para><anchor id="index_1hm_coord_example"/><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2harmonic_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/harmonic_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/harmonic_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Harmonic_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_range<sp/>=<sp/>std::vector&lt;Point_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Domain<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2" kindref="compound">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2" kindref="compound">Harmonic_coordinates_2</ref><sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Harmonic_coordinates_2&lt;Point_range, Domain, Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>simple<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>polygon<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.03,<sp/>0.05),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.07,<sp/>0.04),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.10,<sp/>0.04),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.14,<sp/>0.04),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.17,<sp/>0.07),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.20,<sp/>0.09),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.22,<sp/>0.11),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.25,<sp/>0.11),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.27,<sp/>0.10),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.30,<sp/>0.07),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.31,<sp/>0.04),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.34,<sp/>0.03),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.37,<sp/>0.02),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.40,<sp/>0.03),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.42,<sp/>0.04),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.44,<sp/>0.07),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.45,<sp/>0.10),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.46,<sp/>0.13),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.46,<sp/>0.19),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.47,<sp/>0.26),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.47,<sp/>0.31),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.47,<sp/>0.35),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.45,<sp/>0.37),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.41,<sp/>0.38),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.38,<sp/>0.37),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.35,<sp/>0.36),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.32,<sp/>0.35),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.30,<sp/>0.37),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.28,<sp/>0.39),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.25,<sp/>0.40),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.23,<sp/>0.39),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.21,<sp/>0.37),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.21,<sp/>0.34),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.23,<sp/>0.32),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.24,<sp/>0.29),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.27,<sp/>0.24),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.29,<sp/>0.21),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.29,<sp/>0.18),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.26,<sp/>0.16),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.24,<sp/>0.17),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.23,<sp/>0.19),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.24,<sp/>0.22),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.24,<sp/>0.25),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.21,<sp/>0.26),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.17,<sp/>0.26),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.12,<sp/>0.24),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.07,<sp/>0.20),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.03,<sp/>0.15),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.01,<sp/>0.10),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.02,<sp/>0.07)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>seeds<sp/>to<sp/>mark<sp/>the<sp/>interior<sp/>part<sp/>of<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::list&lt;Point_2&gt;<sp/>seeds;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>seeds.push_back(<ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.1,<sp/>0.1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>Delaunay<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_edge_length<sp/>=<sp/>0.01;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Domain<sp/>domain(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>domain.create(max_edge_length,<sp/>seeds);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>harmonic<sp/>coordinates<sp/>at<sp/>the<sp/>vertices<sp/>of<sp/>the<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Harmonic_coordinates_2<sp/>harmonic_coordinates_2(polygon,<sp/>domain);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>harmonic_coordinates_2.compute();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>it<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;double&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(polygon.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>harmonic<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>output<sp/>only<sp/>the<sp/>first<sp/>20<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout.precision(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;harmonic<sp/>coordinates<sp/>(computed):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>20;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>harmonic_coordinates_2(k,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Evaluate<sp/>harmonic<sp/>coordinates<sp/>at<sp/>the<sp/>barycenters<sp/>of<sp/>the<sp/>domain<sp/>triangles.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>output<sp/>only<sp/>the<sp/>first<sp/>20<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;harmonic<sp/>coordinates<sp/>(evaluated):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_2&gt;<sp/>barycenters;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>domain.barycenters(std::back_inserter(barycenters));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>20;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>harmonic_coordinates_2(barycenters[k],<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1height_inter_example">
<title>Terrain Modeling</title>
<para>This is an advanced example that illustrates how to use generalized barycentric coordinates for height interpolation with applications to terrain modeling. It also shows how to use a non-default traits class with our package instead of a <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> traits class. Suppose we know the boundary of three-dimensional piece of terrain that can be represented as a polygon with several three-dimensional vertices, where the third dimension indicates the corresponding height. The task is to propagate the height from the known sample points on the boundary to the polygon&apos;s interior. This gives an approximate estimation of the terrain&apos;s surface in this region.</para>
<para><anchor id="index_1terrain_example_fig"/><anchor id="index_1fig__terrain_example"/> <image type="html" name="terrain.svg"></image>
 <image type="latex" name="terrain.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__terrain_example" kindref="member">fig__terrain_example</ref> A 2D polygon with 50 vertices representing a piece of terrain with convex and concave parts. The height is not shown. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In this example, we project a 3D polygon orthogonally onto the 2D plane using the class <computeroutput><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3</ref></computeroutput>, triangulate its interior using the class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2" kindref="compound">Delaunay_domain_2</ref></computeroutput>, and compute mean value coordinates at the vertices of this triangulation with respect to the polygon vertices. Finally, we interpolate the height data from the polygon boundary to its interior using the computed coordinates and the global interpolation function from the package <ref refid="index_1chapinterpolation" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Interpolation.tag">2D and Surface Function Interpolation</ref>.</para>
<para><anchor id="index_1terrain_example"/><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2terrain_height_modeling_8cpp-example" kindref="compound">Barycentric_coordinates_2/terrain_height_modeling.cpp</ref> <programlisting filename="Barycentric_coordinates_2/terrain_height_modeling.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Projection_traits_xy_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/interpolation_functions.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Mean_value_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Projection<sp/>=<sp/><ref refid="classCGAL_1_1Projection__traits__xy__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Projection::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Projection::Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_range<sp/>=<sp/>std::vector&lt;Point&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Domain<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2" kindref="compound">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Projection&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__2" kindref="compound">Mean_value_coordinates_2</ref><sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Mean_value_coordinates_2&lt;Point_range, Projection&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Vertex_function_value<sp/>=<sp/>std::map&lt;Point,<sp/>FT,<sp/>typename<sp/>Projection::Less_xy_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Function_value_access<sp/>=<sp/><ref refid="structCGAL_1_1Data__access" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Interpolation.tag">CGAL::Data_access&lt;Vertex_function_value&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_with_coordinate<sp/>=<sp/>std::pair&lt;Point,<sp/>FT&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>polygon<sp/>that<sp/>bounds<sp/>a<sp/>three-dimensional<sp/>terrain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>z-coordinate<sp/>of<sp/>each<sp/>vertex<sp/>represents<sp/>the<sp/>height<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Projection<sp/>in<sp/>2D<sp/>is<sp/>performed<sp/>automatically<sp/>by<sp/>the<sp/>Projection<sp/>traits<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/>polygon<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.03,<sp/>0.05,<sp/>0.00),<sp/>Point(0.07,<sp/>0.04,<sp/>0.02),<sp/>Point(0.10,<sp/>0.04,<sp/>0.04),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.14,<sp/>0.04,<sp/>0.06),<sp/>Point(0.17,<sp/>0.07,<sp/>0.08),<sp/>Point(0.20,<sp/>0.09,<sp/>0.10),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.22,<sp/>0.11,<sp/>0.12),<sp/>Point(0.25,<sp/>0.11,<sp/>0.14),<sp/>Point(0.27,<sp/>0.10,<sp/>0.16),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.30,<sp/>0.07,<sp/>0.18),<sp/>Point(0.31,<sp/>0.04,<sp/>0.20),<sp/>Point(0.34,<sp/>0.03,<sp/>0.22),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.37,<sp/>0.02,<sp/>0.24),<sp/>Point(0.40,<sp/>0.03,<sp/>0.26),<sp/>Point(0.42,<sp/>0.04,<sp/>0.28),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.44,<sp/>0.07,<sp/>0.30),<sp/>Point(0.45,<sp/>0.10,<sp/>0.32),<sp/>Point(0.46,<sp/>0.13,<sp/>0.34),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.46,<sp/>0.19,<sp/>0.36),<sp/>Point(0.47,<sp/>0.26,<sp/>0.38),<sp/>Point(0.47,<sp/>0.31,<sp/>0.40),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.47,<sp/>0.35,<sp/>0.42),<sp/>Point(0.45,<sp/>0.37,<sp/>0.44),<sp/>Point(0.41,<sp/>0.38,<sp/>0.46),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.38,<sp/>0.37,<sp/>0.48),<sp/>Point(0.35,<sp/>0.36,<sp/>0.50),<sp/>Point(0.32,<sp/>0.35,<sp/>0.52),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.30,<sp/>0.37,<sp/>0.54),<sp/>Point(0.28,<sp/>0.39,<sp/>0.56),<sp/>Point(0.25,<sp/>0.40,<sp/>0.58),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.23,<sp/>0.39,<sp/>0.60),<sp/>Point(0.21,<sp/>0.37,<sp/>0.62),<sp/>Point(0.21,<sp/>0.34,<sp/>0.64),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.23,<sp/>0.32,<sp/>0.66),<sp/>Point(0.24,<sp/>0.29,<sp/>0.68),<sp/>Point(0.27,<sp/>0.24,<sp/>0.70),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.29,<sp/>0.21,<sp/>0.72),<sp/>Point(0.29,<sp/>0.18,<sp/>0.74),<sp/>Point(0.26,<sp/>0.16,<sp/>0.76),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.24,<sp/>0.17,<sp/>0.78),<sp/>Point(0.23,<sp/>0.19,<sp/>0.80),<sp/>Point(0.24,<sp/>0.22,<sp/>0.82),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.24,<sp/>0.25,<sp/>0.84),<sp/>Point(0.21,<sp/>0.26,<sp/>0.86),<sp/>Point(0.17,<sp/>0.26,<sp/>0.88),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.12,<sp/>0.24,<sp/>0.90),<sp/>Point(0.07,<sp/>0.20,<sp/>0.92),<sp/>Point(0.03,<sp/>0.15,<sp/>0.94),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point(0.01,<sp/>0.10,<sp/>0.97),<sp/>Point(0.02,<sp/>0.07,<sp/>1.00)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>Delaunay<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>seeds;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>seeds.push_back(Point(0.1,<sp/>0.1,<sp/>0.0));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Domain<sp/>domain(polygon);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>domain.create(0.05,<sp/>seeds);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Associate<sp/>each<sp/>polygon<sp/>vertex<sp/>with<sp/>the<sp/>corresponding<sp/>function<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vertex_function_value<sp/>vertex_function_value;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>vertex<sp/>:<sp/>polygon)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vertex_function_value.insert(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::make_pair(vertex,<sp/>vertex.z()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>class<sp/>with<sp/>the<sp/>mean<sp/>value<sp/>weights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mean_value_coordinates_2<sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gad9337f53ea56d65708bb42e4ee3415aa" kindref="member">mean_value_coordinates_2</ref>(polygon);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>coordinates<sp/>and<sp/>use<sp/>them<sp/>to<sp/>interpolate<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>from<sp/>the<sp/>polygon<sp/>boundary<sp/>to<sp/>its<sp/>interior.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(polygon.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_with_coordinate&gt;<sp/>boundary;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>boundary.resize(polygon.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>queries;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>queries.reserve(domain.number_of_vertices());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>domain.number_of_vertices();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>=<sp/>domain.vertex(i);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__PkgBarycentricCoordinates2RefFunctions_1gad9337f53ea56d65708bb42e4ee3415aa" kindref="member">mean_value_coordinates_2</ref>(query,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>polygon.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boundary[i]<sp/>=<sp/>std::make_pair(polygon[i],<sp/>coordinates[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>f<sp/>=<sp/><ref refid="group__PkgInterpolation2Interpolation_1ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Interpolation.tag">CGAL::linear_interpolation</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boundary.begin(),<sp/>boundary.end(),<sp/>FT(1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Function_value_access(vertex_function_value));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>queries.push_back(Point(query.x(),<sp/>query.y(),<sp/>f));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>interpolated<sp/>heights.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;interpolated<sp/>heights<sp/>(all<sp/>queries):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>queries)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>query.z()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>As a result, we get a smooth function inside the polygon that approximates the underlying terrain surface.</para>
<para><anchor id="index_1fig__terrain_interpolation_example"/> <image type="html" name="terrain_interpolation.png"></image>
 <image type="latex" name="terrain_interpolation.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__terrain_interpolation_example" kindref="member">fig__terrain_interpolation_example</ref> The interpolated data. The color bar represents the corresponding height. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1shape_deform_example">
<title>Shape Deformation</title>
<para>This is another advanced example that shows how to use generalized barycentric coordinates in order to deform a given 2D shape into another shape as shown in the figure below. Harmonic coordinates satisfy all the properties of barycentric coordinates for complicated concave polygons and hence this is our choice to perform a shape deformation. Note that even though harmonic coordinates are guaranteed to be positive inside a polygon, they do not guarantee a bijective mapping between the source and target shapes that is the target mesh can fold-over the target polygon after the mapping (see the little fold-over in the left shoulder of the target shape).</para>
<para><anchor id="index_1fig__shape_deformation_example"/> <image type="html" name="shape_deformation.svg"></image>
 <image type="latex" name="shape_deformation.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__shape_deformation_example" kindref="member">fig__shape_deformation_example</ref> The shape on the left is deformed into the shape on the right. The zoom shows a fold-over in the left shoulder of the target shape where the red triangle goes over the polygon boundary. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><anchor id="index_1deformation_example"/><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2shape_deformation_8cpp-example" kindref="compound">Barycentric_coordinates_2/shape_deformation.cpp</ref> <programlisting filename="Barycentric_coordinates_2/shape_deformation.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Harmonic_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_range<sp/>=<sp/>std::vector&lt;Point_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Domain<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2" kindref="compound">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2" kindref="compound">Harmonic_coordinates_2</ref><sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Harmonic_coordinates_2&lt;Point_range, Domain, Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>source<sp/>and<sp/>target<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>number<sp/>of<sp/>vertices<sp/>in<sp/>both<sp/>shapes<sp/>must<sp/>be<sp/>equal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>source_shape<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(3,<sp/>3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(5,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(5,<sp/>4),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(5,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>6),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>4),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>target_shape<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(3,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(3,<sp/>3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(3,<sp/>0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(5,<sp/>6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(5,<sp/>7),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(4,<sp/>6),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>7),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(1,<sp/>6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(2,<sp/>3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(target_shape.size()<sp/>==<sp/>source_shape.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>seeds<sp/>to<sp/>mark<sp/>the<sp/>interior<sp/>part<sp/>of<sp/>the<sp/>source<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>seeds<sp/>=<sp/>{<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(3,<sp/>5)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>Delaunay<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>max_edge_length<sp/>=<sp/>FT(1)<sp/>/<sp/>FT(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Domain<sp/>domain(source_shape);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>domain.create(max_edge_length,<sp/>seeds);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>it<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;<sp/>std::vector&lt;FT&gt;<sp/>&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(domain.number_of_vertices());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>harmonic<sp/>coordinates<sp/>at<sp/>the<sp/>vertices<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>discretized<sp/>interior<sp/>domain<sp/>of<sp/>the<sp/>source<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Harmonic_coordinates_2<sp/>harmonic_coordinates_2(source_shape,<sp/>domain);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>harmonic_coordinates_2.compute();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>harmonic_coordinates_2(std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Deform<sp/>the<sp/>source<sp/>domain<sp/>into<sp/>the<sp/>target<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>output<sp/>only<sp/>the<sp/>first<sp/>20<sp/>results.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;shape<sp/>deformation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>20;<sp/>++k)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>x<sp/>=<sp/>FT(0),<sp/>y<sp/>=<sp/>FT(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates[k].size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>x<sp/>+=<sp/>coordinates[k][i]<sp/>*<sp/>target_shape[i].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>y<sp/>+=<sp/>coordinates[k][i]<sp/>*<sp/>target_shape[i].y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;deformed<sp/>domain<sp/>vertex:<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>x<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>y<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>But despite the possible fold-overs, a similar technique can be used for image warping in 2D and character articulation in 3D. For example in 2D, we first enclose an image, which we want to deform, into a simple polygon so-called <emphasis>cage</emphasis>, we then bound each image pixel to this cage using barycentric coordinates, and finally deform this cage into a new one, which also deforms the underlying image, as shown in the figure below for harmonic coordinates.</para>
<para><anchor id="index_1fig__image_warping_example"/> <image type="html" name="image_warping.png"></image>
 <image type="latex" name="image_warping.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__image_warping_example" kindref="member">fig__image_warping_example</ref> An image on the left is deformed into a new image on the right using a 2D concave polygon (grey) and harmonic coordinates computed at each image pixel with respect to the vertices of this polygon. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1aff_example">
<title>Affine Coordinates</title>
<para>This is an example, where we show how a <ulink url="https://en.cppreference.com/w/cpp/language/lambda">lambda expression</ulink> can be used to define a model of generalized barycentric coordinates. To make this example useful, we implement affine generalized coordinates for a set of scattered points. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact.</para>
<para><anchor id="index_1aff_coord_example_fig"/><anchor id="index_1fig__aff_example"/> <image type="html" name="aff_coord_example.svg"></image>
 <image type="latex" name="aff_coord_example.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__aff_example" kindref="member">fig__aff_example</ref> Example&apos;s point pattern. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><anchor id="index_1aff_coord_example"/><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2affine_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/affine_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/affine_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;Eigen/Core&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;Eigen/Dense&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/barycenter.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/transform_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">VectorXd<sp/>=<sp/>Eigen::VectorXd;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">MatrixXd<sp/>=<sp/>Eigen::MatrixXd;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Output_iterator<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::back_insert_iterator&lt;<sp/>std::vector&lt;double&gt;<sp/>&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>set<sp/>of<sp/>vertices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>vertices<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.0,<sp/>0.0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.75,<sp/>0.25),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.5,<sp/>0.5),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.4,<sp/>-0.2)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>set<sp/>of<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>queries<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.2,<sp/>0.2),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.3,<sp/>0.3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.4,<sp/>0.4)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>lambda<sp/>function<sp/>with<sp/>affine<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>implementation<sp/>is<sp/>based<sp/>on<sp/>the<sp/>following<sp/>paper:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>S.<sp/>Waldron.<sp/>Affine<sp/>generalized<sp/>barycentric<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Jaen<sp/>Journal<sp/>on<sp/>Approximation,<sp/>3(2):209-226,<sp/>2011.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>a<sp/>model<sp/>of<sp/>the<sp/>`AnalyticWeights_2`<sp/>concept.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>affine<sp/>=<sp/>[&amp;](</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>&amp;<sp/>query,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Output_iterator<sp/>coordinates)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>n<sp/>=<sp/>vertices.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>lambda<sp/>=<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>&amp;<sp/>p){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_pair(p,<sp/>1.0);<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>b<sp/>=<sp/><ref refid="group__barycenter__grp_1ga93e459977649c2430139b5778101529b" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::barycenter</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_transform_iterator(vertices.begin(),<sp/>lambda),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_transform_iterator(vertices.end()<sp/><sp/>,<sp/>lambda),<sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixXd<sp/>V(2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>V(0,<sp/>i)<sp/>=<sp/>vertices[i].x()<sp/>-<sp/>b.x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>V(1,<sp/>i)<sp/>=<sp/>vertices[i].y()<sp/>-<sp/>b.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A<sp/><sp/><sp/>=<sp/>V.adjoint();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mat<sp/>=<sp/>V<sp/>*<sp/>A;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>inv<sp/>=<sp/>mat.inverse();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>diff;<sp/>VectorXd<sp/>vec(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>query.x()<sp/>-<sp/>b.x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>y<sp/>=<sp/>query.y()<sp/>-<sp/>b.y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>diff<sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vec(0)<sp/>=<sp/>V(0,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vec(1)<sp/>=<sp/>V(1,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>inv<sp/>*<sp/>vec;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*(coordinates++)<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff.x()<sp/>*<sp/>res(0)<sp/>+<sp/>diff.y()<sp/>*<sp/>res(1)<sp/>+<sp/>1.0<sp/>/<sp/>double(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>affine<sp/>coordinates<sp/>for<sp/>all<sp/>query<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;affine<sp/>coordinates<sp/>(all<sp/>queries):<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;double&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>queries)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>affine(query,<sp/>std::back_inserter(coordinates));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1depr_example">
<title>Deprecated Coordinates</title>
<para>This example illustrates how to use the deprecated API of this package. The used <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> is inexact and the used coordinates are mean value coordinates. The result is identical to the one from <ref refid="index_1mv_coord_example" kindref="member">this example</ref>.</para>
<para><anchor id="index_1depr_coord_example"/><linebreak/>
<bold>File</bold> <ref refid="Barycentric_coordinates_2_2deprecated_coordinates_8cpp-example" kindref="compound">Barycentric_coordinates_2/deprecated_coordinates.cpp</ref> <programlisting filename="Barycentric_coordinates_2/deprecated_coordinates.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Installation/internal/disable_deprecation_warnings_and_errors.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Mean_value<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2" kindref="compound">CGAL::Barycentric_coordinates::Mean_value_2&lt;Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Mean_value_coordinates<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>star-shaped<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>star_shaped<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.0,<sp/>0.0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(<sp/>0.1,<sp/>-0.8),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.3,<sp/>0.0),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.6,<sp/>-0.5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.6,<sp/>0.1),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(<sp/>1.1,<sp/><sp/>0.6),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.3,<sp/>0.2),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.1,<sp/><sp/>0.8),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.1,<sp/>0.2),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(-0.7,<sp/><sp/>0.0)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>the<sp/>class<sp/>with<sp/>mean<sp/>value<sp/>coordinates</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>the<sp/>star-shaped<sp/>polygon<sp/>defined<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Mean_value_coordinates<sp/>mean_value_coordinates(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>star_shaped.begin(),<sp/>star_shaped.end());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>some<sp/>information<sp/>about<sp/>the<sp/>polygon<sp/>and<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mean_value_coordinates.print_information();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>some<sp/>interior<sp/>points<sp/>in<sp/>the<sp/>polygon.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Point_2&gt;<sp/>interior_points<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.12,<sp/>-0.45),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.55,<sp/>-0.3),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.9<sp/>,<sp/>0.45),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.15,<sp/><sp/>0.35),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(-0.4,<sp/>0.04),<sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.11,<sp/>0.11),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.28,<sp/><sp/>0.12),<sp/></highlight><highlight class="comment">//<sp/>the<sp/>only<sp/>point<sp/>in<sp/>the<sp/>kernel<sp/>of<sp/>the<sp/>star<sp/>shaped<sp/>polygon</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(0.55,<sp/><sp/>0.11)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>speed<sp/>up<sp/>the<sp/>computation<sp/>using<sp/>the<sp/>O(n)<sp/>algorithm<sp/>called<sp/>with<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>parameter<sp/>CGAL::Barycentric_coordinates::FAST.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>default<sp/>one<sp/>is<sp/>CGAL::Barycentric_coordinates::PRECISE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>type_of_algorithm<sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f" kindref="member">CGAL::Barycentric_coordinates::FAST</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>also<sp/>speed<sp/>up<sp/>the<sp/>computation<sp/>by<sp/>using<sp/>the<sp/>parameter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>query_point_location<sp/>=<sp/>CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>query_point_location<sp/>=<sp/><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c" kindref="member">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>vector<sp/>`std::vector`<sp/>to<sp/>store<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>coordinates;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>coordinates.reserve(star_shaped.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>mean<sp/>value<sp/>coordinates<sp/>for<sp/>all<sp/>interior<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>query<sp/>:<sp/>interior_points)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>coordinates.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>result<sp/>=<sp/>mean_value_coordinates(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>query,<sp/>std::back_inserter(coordinates),<sp/>query_point_location,<sp/>type_of_algorithm);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Status<sp/>of<sp/>the<sp/>computation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>status<sp/>=<sp/>(result<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;SUCCESS.&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;FAILURE.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;point:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>count<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>status<sp/>of<sp/>the<sp/>computation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>status<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Output<sp/>the<sp/>coordinates.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>coordinates.size()<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>coordinates[coordinates.size()<sp/>-<sp/>1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>The headers <computeroutput>Segment_coordinates_2.h</computeroutput> and <computeroutput>Triangle_coordinates_2.h</computeroutput> are not capitalized in the new version that is they are named <computeroutput>segment_coordinates_2.h</computeroutput> and <computeroutput>triangle_coordinates_2.h</computeroutput>.</para>
</simplesect>
</para>
</sect2>
</sect1>
<sect1 id="index_1gbc_degeneracies">
<title>Edge Cases</title>
<para>Not all presented coordinates are general enough to handle any query point in the plane, that is why we highly recommend reading this section in order to learn what can be expected from each coordinate function. If you want to get more mathematical details about each coordinate function as well as the complete history and theory behind barycentric coordinates, you should read <ref refid="citelist_1CITEREF_cgal:bc:hs-gbcicg-17" kindref="member">[6]</ref>. You can also read an overview <ulink url="https://susi.usi.ch/usi/documents/318813">here</ulink> (chapters 1 and 2).</para>
<para><anchor id="index_1compute_seg_coord"/></para>
<sect2 id="index_1gbc_deg_segment_coordinates">
<title>Segment Coordinates</title>
<para>The segment coordinate function with respect to a given segment vertex is a linear function along the supporting line of this segment that grows from zero at the opposite vertex to one at the chosen vertex (see the figure below).</para>
<para><anchor id="index_1fig__seg_coord"/> <image type="html" name="seg_coord.svg"></image>
 <image type="latex" name="seg_coord.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__seg_coord" kindref="member">fig__seg_coord</ref> The segment coordinate function with respect to the vertex <formula id="1">$v_0$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Segment coordinates can be computed exactly if an exact number type is chosen. The segment itself, with respect to which we compute coordinates, must be non-degenerate. If both conditions are satisfied, then the computation never fails. However, to compute coordinates, the user must ensure that the query point lies exactly on the line <formula id="2">$L$</formula> supporting the segment. Since in many applications this is not the case, and a query point may lie very close but not exactly on this line, we provide a solution to remedy this situation.</para>
<para><anchor id="index_1fig__seg_coord_projection"/> <image type="html" name="seg_coord_projection.svg"></image>
 <image type="latex" name="seg_coord_projection.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__seg_coord_projection" kindref="member">fig__seg_coord_projection</ref> The orthogonal projection <formula id="3">$p&apos;$</formula> of the vector <formula id="4">$p$</formula> (green) onto the vector <formula id="5">$q$</formula> (red). <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>Suppose that some query point <formula id="6">$v$</formula> does not lie exactly on the line <formula id="2">$L$</formula>, but is some distance <formula id="7">$d$</formula> away as shown in the figure above. If we want to compute the segment coordinate <formula id="8">$b_1(v)$</formula> with respect to the vertex <formula id="9">$v_1$</formula>, we first find the orthogonal projection <formula id="3">$p&apos;$</formula> of the vector <formula id="4">$p$</formula> onto the vector <formula id="5">$q$</formula> and then normalize it by the length of <formula id="5">$q$</formula>. This yields the segment coordinate <formula id="10">$b_1(v&apos;) = b_1(v)$</formula> if <formula id="6">$v$</formula> lies exactly on the line. The other segment coordinate <formula id="11">$b_0(v&apos;)$</formula> that is equal to <formula id="12">$b_0(v)$</formula> when <formula id="6">$v$</formula> is on the line <formula id="2">$L$</formula> is computed the same way but with the projection of the vector <formula id="13">$\vec{vv_1}$</formula>.</para>
<para><bold>Warning:</bold> do not abuse the feature described above, because it does not yield correct segment coordinates for the point <formula id="6">$v$</formula> but rather those for <formula id="14">$v&apos;$</formula>. Moreover, segment coordinates for a point <formula id="6">$v$</formula>, which does not lie exactly on the line <formula id="2">$L$</formula>, do not exist. But if the non-zero distance <formula id="7">$d$</formula> is due to some numerical instability when computing the location of the point <formula id="6">$v$</formula> or any other problem, which causes the point to be not exactly on the line, the final segment coordinates will be, at least approximately, correct.</para>
<para>With inexact number types, the resulting coordinate values are correct up to the precision of the chosen type.</para>
<para><anchor id="index_1compute_tri_coord"/></para>
</sect2>
<sect2 id="index_1gbc_deg_triangular_coordinates">
<title>Triangle Coordinates</title>
<para>The triangle coordinate function with respect to a given triangle vertex is a linear function that grows from zero along the opposite edge to one at the chosen vertex (see the figure below).</para>
<para><anchor id="index_1fig__tri_coord"/> <image type="html" name="tri_coord.svg"></image>
 <image type="latex" name="tri_coord.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__tri_coord" kindref="member">fig__tri_coord</ref> The triangle coordinate function with respect to the vertex <formula id="1">$v_0$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>To compute the triangle coordinates of the query point <formula id="6">$v$</formula>, we adopt the standard simple formula</para>
<para><center> <formula id="15">$b_i = \frac{A_i}{A}$</formula> with <formula id="16">$i = 0\dots 2$</formula> </center></para>
<para>where <formula id="17">$A_i$</formula> is the signed area of the sub-triangle opposite to the vertex <formula id="18">$i$</formula> and <formula id="19">$A$</formula> is the total area of the triangle that is <formula id="20">$A = A_0 + A_1 + A_2$</formula> (see the figure below).</para>
<para><anchor id="index_1tri_notations"/><anchor id="index_1fig__tri_notations"/> <image type="html" name="tri_notations.svg"></image>
 <image type="latex" name="tri_notations.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__tri_notations" kindref="member">fig__tri_notations</ref> Notation for triangle coordinates. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>These coordinates can be computed exactly if an exact number type is chosen, for any query point in the plane and with respect to any non-degenerate triangle. No special cases are handled. The computation always yields the correct result. The notion of correctness depends on the precision of the used number type. Note that for exterior points some coordinate values will be negative.</para>
<para><anchor id="index_1compute_wp_coord"/></para>
</sect2>
<sect2 id="index_1gbc_deg_wachspress_coordinates">
<title>Wachspress Coordinates</title>
<para>Wachspress coordinates are well-defined in the closure of any <emphasis>strictly convex polygon</emphasis>. Therefore, when using an exact number type, for any query point from the polygon&apos;s closure, these coordinates are computed exactly and no false result is expected. For exterior query points, the coordinates can also be computed but not everywhere (see below for more details). For inexact number types, the resulting precision of the computation is due to the involved algorithm and a chosen number type. In the following paragraph, we discuss two available algorithms for computing Wachspress coordinates when an inexact number type is used. The chosen algorithm is specified by a computation policy <computeroutput><ref refid="namespaceCGAL_1_1Barycentric__coordinates_1a478bbcec416216b2274ee4b4e97b0e6c" kindref="member">Barycentric_coordinates::Computation_policy_2</ref></computeroutput>.</para>
<para><anchor id="index_1wp_polygon"/><anchor id="index_1fig__wp_notations"/> <image type="html" name="wp_notations.svg"></image>
 <image type="latex" name="wp_notations.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__wp_notations" kindref="member">fig__wp_notations</ref> Notation for Wachspress coordinates. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>To compute Wachspress weights, we follow <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref> and use the formula</para>
<para><center> <formula id="21">$w_i = \frac{C_i}{A_{i-1}A_i}$</formula> </center></para>
<para>with <formula id="22">$i = 1\dots n$</formula> where <formula id="23">$n$</formula> is the number of polygon vertices. In order to compute the coordinates, we normalize these weights,</para>
<para><center> <formula id="24">$b_i = \frac{w_i}{W^{wp}}\qquad$</formula> with <formula id="25">$\qquad W^{wp} = \sum_{j=1}^n w_j.$</formula> </center></para>
<para>This formula becomes unstable when approaching the boundary of the polygon ( <formula id="26">$\approx 1.0e-10$</formula> and closer). To fix the problem, we modify the weights <formula id="27">$w_i$</formula> as</para>
<para><center> <formula id="28">$\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j$</formula>. </center></para>
<para>After the above normalization, this gives us the precise algorithm to compute Wachspress coordinates but with <formula id="29">$O(n^2)$</formula> performance only. The max speed <formula id="30">$O(n)$</formula> algorithm uses the standard weights <formula id="27">$w_i$</formula>. Note that mathematically this modification does not change the coordinates. One should be cautious when using the unnormalized Wachspress weights. In that case, you must choose the <formula id="30">$O(n)$</formula> type.</para>
<para>It is known that for strictly convex polygons the denominator&apos;s zero set of the Wachspress coordinates ( <formula id="31">$W^{wp} = 0~$</formula>) is a curve, which (in many cases) lies quite far away from the polygon. More specifically, it interpolates the intersection points of the supporting lines of the polygon edges. Therefore, the computation of Wachspress coordinates outside the polygon is possible only at points that do not belong to this curve.</para>
<para><anchor id="index_1fig__wp_zero_set"/> <image type="html" name="wp_zero_set.svg"></image>
 <image type="latex" name="wp_zero_set.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__wp_zero_set" kindref="member">fig__wp_zero_set</ref> Zero set (red) of the Wachspress coordinates&apos; denominator <formula id="32">$W^{wp}$</formula> for a non-regular hexagon. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><bold>Warning:</bold> we do not recommend using Wachspress coordinates for exterior points!</para>
<para><anchor id="index_1compute_dh_coord"/></para>
</sect2>
<sect2 id="index_1gbc_deg_discrete_harmonic_coordinates">
<title>Discrete Harmonic Coordinates</title>
<para>Discrete harmonic coordinates have the same requirements as Wachspress coordinates. They are well-defined in the closure of any <emphasis>strictly convex polygon</emphasis> and, if an exact number type is chosen, they are computed exactly. However, and unlike Wachspress basis functions, these coordinates are not necessarily positive. In particular, the weight <formula id="27">$w_i$</formula> is positive if and only if <formula id="33">$\alpha+\beta &lt; \pi$</formula> (see the figure below for notation). For inexact number types, the precision of the computation is due to the involved algorithm and a chosen number type. Again, we describe two algorithms to compute the coordinates when an inexact number type is used: one is of max precision and one is of max speed.</para>
<para><anchor id="index_1dh_polygon"/><anchor id="index_1fig__dh_notations"/> <image type="html" name="dh_notations.svg"></image>
 <image type="latex" name="dh_notations.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__dh_notations" kindref="member">fig__dh_notations</ref> Notation for discrete harmonic coordinates. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>To compute discrete harmonic weights, we follow <ref refid="citelist_1CITEREF_cgal:bc:fhk-gcbcocp-06" kindref="member">[2]</ref> and use the formula</para>
<para><center> <formula id="34">$w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}$</formula> </center></para>
<para>with <formula id="22">$i = 1\dots n$</formula> where <formula id="23">$n$</formula> is the number of polygon vertices. In order to compute the coordinates, we normalize these weights,</para>
<para><center> <formula id="35">$b_i = \frac{w_i}{W^{dh}}\qquad$</formula> with <formula id="36">$\qquad W^{dh} = \sum_{j=1}^n w_j.$</formula> </center></para>
<para>This formula becomes unstable when approaching the boundary of the polygon ( <formula id="26">$\approx 1.0e-10$</formula> and closer). To fix the problem, similarly to the previous subsection, we modify the weights <formula id="27">$w_i$</formula> as</para>
<para><center> <formula id="37">$\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j$</formula>. </center></para>
<para>After the above normalization, this yields the precise algorithm to compute discrete harmonic coordinates but with <formula id="29">$O(n^2)$</formula> performance only. The max speed <formula id="30">$O(n)$</formula> algorithm uses the standard weights <formula id="27">$w_i$</formula>. Again, mathematically this modification does not change the coordinates, one should be cautious when using the unnormalized discrete harmonic weights. In that case, you must choose the <formula id="30">$O(n)$</formula> type.</para>
<para><bold>Warning:</bold> as for Wachspress coordinates, we do not recommend using discrete harmonic coordinates for exterior points, because the curve <formula id="38">$W^{dh} = 0$</formula> may have several components, and one of them interpolates the polygon vertices. However, if you are sure that the query point does not belong to this curve, you can compute the coordinates as shown in <ref refid="index_1dh_example" kindref="member">this example</ref>.</para>
<para><anchor id="index_1compute_mv_coord"/></para>
</sect2>
<sect2 id="index_1gbc_deg_mean_value_coordinates">
<title>Mean Value Coordinates</title>
<para>Unlike the previous coordinates, mean value coordinates cannot be computed exactly due to an inevitable square root operation. Although, if an exact number type is used, the default precision of the computation depends only on two CGAL functions: <computeroutput><ref refid="group__PkgAlgebraicFoundationsRef_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::to_double()</ref></computeroutput> and <computeroutput><ref refid="group__PkgAlgebraicFoundationsRef_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::sqrt()</ref></computeroutput>. It is worth saying that providing a number type that supports exact or nearly exact computation of the square root is possible, however since such types are usually impractical due to the large overhead, the conversion to a floating-point format above is always effective. On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon. In addition, if your traits class provides a more precise version of the square root function, the final precision of the computation with exact number types will depend only on the precision of that function.</para>
<para><anchor id="index_1mv_polygon"/><anchor id="index_1fig__mv_notations"/> <image type="html" name="mv_notations.svg"></image>
 <image type="latex" name="mv_notations.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__mv_notations" kindref="member">fig__mv_notations</ref> Notation for mean value coordinates. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>For these coordinates, we provide two algorithms: one is of max precision and one is of max speed. The first one works everywhere in the plane, and the precision of the computation depends only on the chosen number type, including the remarks above. This algorithm is based on the following weight formula from <ref refid="citelist_1CITEREF_cgal:bc:f-wmvc-14" kindref="member">[4]</ref></para>
<para><center> <formula id="39">$w_i = \sigma_i\bar{w}_i\qquad$</formula> with <formula id="40">$\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad$</formula> where <formula id="41">$\qquad r_i = \|d_i\|.$</formula> </center></para>
<para>Since <formula id="42">$\bar{w}_i$</formula> is always positive, we must append to it the proper sign <formula id="43">$\sigma_i$</formula> of the signed mean value weight, which can be found efficiently (see the figures below). This weight is always positive to the left of the red piecewise linear curve, and it is negative to the right of this curve, moving in the counterclockwise direction.</para>
<para><anchor id="index_1fig__mv_weight_signs"/> <image type="html" name="mv_weight_signs.svg"></image>
 <image type="latex" name="mv_weight_signs.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__mv_weight_signs" kindref="member">fig__mv_weight_signs</ref> Signs of the mean value weight <formula id="27">$w_i$</formula> depending on the region with respect to a convex polygon <formula id="44">$P$</formula> and a concave polygon <formula id="45">$P&apos;$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>After the normalization of these weights as before</para>
<para><center> <formula id="46">$b_i = \frac{w_i}{W^{mv}}\qquad$</formula> with <formula id="47">$\qquad W^{mv} = \sum_{j=1}^n w_j$</formula> </center></para>
<para>we obtain the max precision <formula id="29">$O(n^2)$</formula> algorithm. The max speed <formula id="30">$O(n)$</formula> algorithm computes the weights <formula id="27">$w_i$</formula> using the pseudocode from <ulink url="https://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</ulink>. These weights</para>
<para><center> <formula id="48">$w_i = \frac{t_{i-1} + t_i}{r_i}\qquad$</formula> with <formula id="49">$\qquad t_i = \frac{\text{det}(d_i, d_{i+1})}{r_ir_{i+1} + d_id_{i+1}}$</formula> </center></para>
<para>are also normalized. Note that they are unstable if a query point is closer than <formula id="26">$\approx 1.0e-10$</formula> to the polygon boundary, similarly to Wachspress and discrete harmonic coordinates and one should be cautious when using the unnormalized mean value weights. In that case, you must choose the <formula id="30">$O(n)$</formula> type.</para>
<para><anchor id="index_1compute_hm_coord"/></para>
</sect2>
<sect2 id="index_1gbc_deg_harmonic_coordinates">
<title>Harmonic Coordinates</title>
<para>The harmonic coordinates are computed by solving the Laplace equation</para>
<para><center> <formula id="50">$\Delta b = 0$</formula> </center></para>
<para>subject to suitable Dirichlet boundary conditions. Harmonic coordinates are the only coordinates in this package, which are guaranteed to be non-negative in the closure of any simple polygon and satisfy all properties of barycentric coordinates, however such desirable properties come with the fact that these coordinates are well-defined only inside a polygon. If an exterior query point is provided, its coordinates are set to zero.</para>
<para>Another disadvantage of these coordinates is that they cannot be computed exactly, because harmonic coordinates do not have a simple closed-form expression and must be approximated. The common way to approximate these coordinates is by discretizing over the space of piecewise linear functions with respect to a triangulation of the polygon. The denser triangulation of the interior part of the polygon, the better approximation of the coordinates. To get a high quality approximation of the coordinates, the user should provide a rather dense partition of the polygon&apos;s interior domain that in turn leads to larger running times when computing the coordinates.</para>
<para><anchor id="index_1terrain_triangulation_fig"/><anchor id="index_1fig__terrain_triangulation"/> <image type="html" name="terrain_triangulation.svg"></image>
 <image type="latex" name="terrain_triangulation.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__terrain_triangulation" kindref="member">fig__terrain_triangulation</ref> Sparse triangulation of the polygon&apos;s interior domain (left): smaller running times, lower coordinates quality; dense triangulation (right): larger running times, higher coordinates quality. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>From all this follows, that any exact <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> will be rejected and it is not possible to compute analytic harmonic weights. However, once the coordinates are computed at the vertices of the triangulation, they can be evaluated analytically at any interior query point. For evaluation, we first locate a triangle that contains the query point and then linearly interpolate harmonic coordinates defined at the vertices of this triangle to the query point with the help of <ref refid="index_1gbc_deg_triangular_coordinates" kindref="member">triangle coordinates</ref> as</para>
<para><center> <formula id="51">$b_i = b_0^{tr} b_i^0 + b_1^{tr} b_i^1 + b_2^{tr} b_i^2$</formula> </center></para>
<para>with <formula id="22">$i = 1\dots n$</formula>, where <formula id="23">$n$</formula> is the number of polygon vertices, <formula id="52">$b_{0}^{tr}$</formula>, <formula id="53">$b_{1}^{tr}$</formula>, and <formula id="54">$b_{2}^{tr}$</formula> are the triangle coordinates of the query point with respect the three vertices of the located triangle, and <formula id="55">$b_i^{0}$</formula>, <formula id="56">$b_i^{1}$</formula>, and <formula id="57">$b_i^{2}$</formula> are the harmonic coordinates pre-computed at the triangle vertices.</para>
</sect2>
</sect1>
<sect1 id="index_1gbc_performance">
<title>Performance</title>
<para>We strive for robustness and efficiency at the same time. Efficiency is especially important. These coordinates are used in many applications where they must be computed for millions of points and, thus, the real time computation of coordinates has been made possible. In this section, we present next the computation runtimes of the implemented algorithms.</para>
<para>The structure of the speed test that we use to evaluate the running times consists of computing coordinate values (or weights) at &gt;= 1 million strictly interior points with respect to a polygon (or triangle, or segment). At each iteration of the loop, we create a query point and compute its coordinates. The time presented in the log-log scale plot at the end of the section is the arithmetic mean of all trials in the loop of 10 iterations. The time presented in the plot is for analytic coordinates only since harmonic coordinates of a reasonable (application-dependent) quality are substantially slower to compute and cannot be fairly compared to the analytic coordinate functions.</para>
<para>The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container, number of points, etc. In our tests, we used the most standard C++ and CGAL features with minimum memory allocation. Therefore, the final time presented is the average time that can be expected without deep optimization but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.</para>
<para>To benchmark analytic coordinates, we used a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores) and 8 GB 1333 MHz DDR3 memory. The installed operating system was OS X 10.9 Maverick. The resulting timings for all closed-form coordinates can be found in the figure below.</para>
<para><anchor id="index_1fig__analytic_timings"/> <image type="html" name="analytic_timings.png"></image>
 <image type="latex" name="analytic_timings.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__analytic_timings" kindref="member">fig__analytic_timings</ref> Time in seconds to compute <formula id="23">$n$</formula> coordinate values for a polygon with <formula id="23">$n$</formula> vertices at 1 million query points with the max speed <formula id="30">$O(n)$</formula> algorithms (dashed) and the max precision <formula id="58">$0(n^2)$</formula> algorithms (solid) for Wachspress (blue), discrete harmonic (red), and mean value (green) coordinates. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>From the figure above we observe that the <formula id="29">$O(n^2)$</formula> algorithm is as fast as the <formula id="30">$O(n)$</formula> algorithm if we have a polygon with a small number of vertices. But as the number of vertices is increased, the linear algorithm outperforms the squared one, as expected. One of the reasons for this behavior is that for a small number of vertices the multiplications of <formula id="59">$n-2$</formula> elements inside the <formula id="29">$O(n^2)$</formula> algorithm take almost the same time as the corresponding divisions in the <formula id="30">$O(n)$</formula> algorithm. For a polygon with many vertices, these multiplications are substantially slower.</para>
<para>To benchmark harmonic coordinates, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. The average time to compute harmonic coordinates in the loop of 10 iterations can be found in the tables below.</para>
<para>The first table shows how the time to compute the coordinates on a unit square depends on the number of triangulation vertices. We show separately the time to setup the matrix, factorize it, and solve it with respect to the four vertices of the unit square.</para>
<para><table rows="9" cols="5"><row>
<entry thead="yes" align='center'><para>Number of queries (approx.) </para>
</entry><entry thead="yes" align='center'><para>Setup (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Factorize (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Solve (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Total (in seconds)  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>100 </para>
</entry><entry thead="no" align='center'><para>0.000056 </para>
</entry><entry thead="no" align='center'><para>0.000099 </para>
</entry><entry thead="no" align='center'><para>0.000015 </para>
</entry><entry thead="no" align='center'><para>0.000170  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>500 </para>
</entry><entry thead="no" align='center'><para>0.000266 </para>
</entry><entry thead="no" align='center'><para>0.000574 </para>
</entry><entry thead="no" align='center'><para>0.000064 </para>
</entry><entry thead="no" align='center'><para>0.000904  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1,000 </para>
</entry><entry thead="no" align='center'><para>0.000509 </para>
</entry><entry thead="no" align='center'><para>0.001194 </para>
</entry><entry thead="no" align='center'><para>0.000147 </para>
</entry><entry thead="no" align='center'><para>0.001850  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>25,000 </para>
</entry><entry thead="no" align='center'><para>0.014749 </para>
</entry><entry thead="no" align='center'><para>0.071152 </para>
</entry><entry thead="no" align='center'><para>0.008191 </para>
</entry><entry thead="no" align='center'><para>0.094092  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>50,000 </para>
</entry><entry thead="no" align='center'><para>0.034255 </para>
</entry><entry thead="no" align='center'><para>0.184237 </para>
</entry><entry thead="no" align='center'><para>0.018166 </para>
</entry><entry thead="no" align='center'><para>0.236658  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>100,000 </para>
</entry><entry thead="no" align='center'><para>0.065117 </para>
</entry><entry thead="no" align='center'><para>0.543177 </para>
</entry><entry thead="no" align='center'><para>0.044088 </para>
</entry><entry thead="no" align='center'><para>0.652382  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>500,000 </para>
</entry><entry thead="no" align='center'><para>0.576530 </para>
</entry><entry thead="no" align='center'><para>7.697143 </para>
</entry><entry thead="no" align='center'><para>0.310765 </para>
</entry><entry thead="no" align='center'><para>8.584438  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1,000,000 </para>
</entry><entry thead="no" align='center'><para>1.295163 </para>
</entry><entry thead="no" align='center'><para>26.76945 </para>
</entry><entry thead="no" align='center'><para>0.737372 </para>
</entry><entry thead="no" align='center'><para>28.80199  </para>
</entry></row>
</table>
</para>
<para>The same results can be seen in the figure.</para>
<para><anchor id="index_1fig__hm_4_bench"/> <image type="html" name="hm_4_bench.svg"></image>
 <image type="latex" name="hm_4_bench.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__hm_4_bench" kindref="member">fig__hm_4_bench</ref> Time in seconds to setup (red), factorize (green), and solve (blue) for harmonic coordinate values with respect to a unit square. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The second table shows how the time to compute the coordinates for 100k queries depends on the number of the polygon vertices. We show separately the time to setup the matrix, factorize it, and solve it with respect to the <formula id="23">$n$</formula> vertices of the polygon. It can be seen that, unlike in the first table, the time to factorize the matrix here stays constant.</para>
<para><table rows="8" cols="5"><row>
<entry thead="yes" align='center'><para>Number of vertices (approx.) </para>
</entry><entry thead="yes" align='center'><para>Setup (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Factorize (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Solve (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Total (in seconds)  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>5 </para>
</entry><entry thead="no" align='center'><para>0.083444 </para>
</entry><entry thead="no" align='center'><para>0.631823 </para>
</entry><entry thead="no" align='center'><para>0.059827 </para>
</entry><entry thead="no" align='center'><para>0.775094  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>10 </para>
</entry><entry thead="no" align='center'><para>0.060294 </para>
</entry><entry thead="no" align='center'><para>0.450534 </para>
</entry><entry thead="no" align='center'><para>0.094583 </para>
</entry><entry thead="no" align='center'><para>0.605411  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>25 </para>
</entry><entry thead="no" align='center'><para>0.062760 </para>
</entry><entry thead="no" align='center'><para>0.478683 </para>
</entry><entry thead="no" align='center'><para>0.254953 </para>
</entry><entry thead="no" align='center'><para>0.796396  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>50 </para>
</entry><entry thead="no" align='center'><para>0.097359 </para>
</entry><entry thead="no" align='center'><para>0.492233 </para>
</entry><entry thead="no" align='center'><para>0.539654 </para>
</entry><entry thead="no" align='center'><para>1.129246  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>100 </para>
</entry><entry thead="no" align='center'><para>0.129487 </para>
</entry><entry thead="no" align='center'><para>0.450771 </para>
</entry><entry thead="no" align='center'><para>1.152544 </para>
</entry><entry thead="no" align='center'><para>1.732802  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>500 </para>
</entry><entry thead="no" align='center'><para>0.430694 </para>
</entry><entry thead="no" align='center'><para>0.460321 </para>
</entry><entry thead="no" align='center'><para>6.620061 </para>
</entry><entry thead="no" align='center'><para>7.511076  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1000 </para>
</entry><entry thead="no" align='center'><para>0.812362 </para>
</entry><entry thead="no" align='center'><para>0.480052 </para>
</entry><entry thead="no" align='center'><para>16.14239 </para>
</entry><entry thead="no" align='center'><para>17.43480  </para>
</entry></row>
</table>
</para>
<para>The same results can be seen in the figure.</para>
<para><anchor id="index_1fig__hm_n_bench"/> <image type="html" name="hm_n_bench.svg"></image>
 <image type="latex" name="hm_n_bench.svg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__hm_n_bench" kindref="member">fig__hm_n_bench</ref> Time in seconds to setup (red), factorize (green), and solve (blue) for harmonic coordinate values with respect to a polygon with <formula id="23">$n$</formula> vertices at 100k query points. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>While, in the first table, the most significant step is to factorize the matrix, in the second table, the slowest step is to solve for coordinates, as expected.</para>
</sect1>
<sect1 id="index_1gbc_history">
<title>History</title>
<para>The package was first released in 2015 and included segment, triangle, Wachspress, discrete harmonic, and mean value coordinates. The API of that version is now deprecated but can still be used. An example of the old API can be found <ref refid="index_1depr_example" kindref="member">here</ref>. The docs of that API are also preserved and maintained <ref refid="group__PkgBarycentricCoordinates2RefDeprecated" kindref="compound">here</ref>.</para>
<para>In 2018, this package was modified and improved by Keyu Chen and Dmitry Anisimov during the Google Summer of Code. The API was changed to the current version. In 2020, the new version was cleaned up and documented that includes:<itemizedlist>
<listitem><para>the classes <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2" kindref="compound">Segment_coordinates_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2" kindref="compound">Triangle_coordinates_2</ref></computeroutput> have been removed, only the free functions are preserved;</para>
</listitem><listitem><para>the entry class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">Generalized_barycentric_coordinates_2</ref></computeroutput> was removed since it is not flexible enough to accommodate all types of 2D barycentric coordinates;</para>
</listitem><listitem><para>the classes <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__2" kindref="compound">Wachspress_2</ref></computeroutput>, <computeroutput>Discrete harmonic_2</computeroutput>, and <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2" kindref="compound">Mean_value_2</ref></computeroutput> have been renamed and modified so that they can be used now on their own without the class <computeroutput><ref refid="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2" kindref="compound">Generalized_barycentric_coordinates_2</ref></computeroutput>;</para>
</listitem><listitem><para>harmonic coordinates have been added;</para>
</listitem><listitem><para>the free functions for segment and triangle coordinates have been modified and improved;</para>
</listitem><listitem><para>the free functions for Wachspress, discrete harmonic, and mean value weights and coordinates have been added;</para>
</listitem><listitem><para>the free functions to compute barycentric coordinates for points on the polygon boundary have been added;</para>
</listitem><listitem><para>all functions and classes are now using ranges and property maps;</para>
</listitem><listitem><para>examples, tests, and benchmarks are modified/extended/improved;</para>
</listitem><listitem><para>the docs are refactored and simplified.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1gbc_acknowledgments">
<title>Acknowledgments</title>
<para>The authors wish to thank <ulink url="https://cs.nyu.edu/~teseo/">Teseo Schneider</ulink> and Randolf Schaerfig for helpful comments and discussions. We also appreciate the great effort invested in this package by our reviewers Andreas Fabri, Sbastien Loriot, and Efi Fogel. </para>
</sect1>
    </detaileddescription>
    <location file="Barycentric_coordinates_2.txt"/>
  </compounddef>
</doxygen>
