<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="structCGAL_1_1Data__access" prot="public">CGAL::Data_access</innerclass>
    <innerclass refid="classCGAL_1_1Interpolation__gradient__fitting__traits__2" prot="public">CGAL::Interpolation_gradient_fitting_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Interpolation__traits__2" prot="public">CGAL::Interpolation_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Voronoi__intersection__2__traits__3" prot="public">CGAL::Voronoi_intersection_2_traits_3</innerclass>
    <innernamespace refid="namespaceCGAL_1_1cpp98">CGAL::cpp98</innernamespace>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgInterpolation2Interpolation_1ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
        </templateparamlist>
        <type>ValueFunctor::result_type::first_type</type>
        <definition>ValueFunctor::result_type::first_type CGAL::linear_interpolation</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, ValueFunctor value_function)</argsstring>
        <name>linear_interpolation</name>
        <qualifiedname>CGAL::linear_interpolation</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" kindref="member">linear_interpolation()</ref></computeroutput> computes the weighted sum of the function values which must be provided via a functor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>CoordinateInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>ForwardIterator</computeroutput> and must have as value type a pair associating an entity, e.g. the <computeroutput>Vertex_handle</computeroutput> or <computeroutput>Point</computeroutput> types of a triangulation, to a (non-normalized) barycentric coordinate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>ValueFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type <computeroutput>VT</computeroutput> must provide an addition operator, and a multiplication operator with the type <computeroutput>Traits::FT</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
A model of the functor <computeroutput>ValueFunctor</computeroutput> is provided by the struct <computeroutput><ref refid="structCGAL_1_1Data__access" kindref="compound">CGAL::Data_access</ref></computeroutput> instantiated with an associative container (e.g. <computeroutput>std::map</computeroutput>) and having:<itemizedlist>
<listitem><para><computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> (the entity type) as <computeroutput>key_type</computeroutput></para>
</listitem><listitem><para><computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</computeroutput> (the coordinate type) as <computeroutput>mapped_type</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>The two template parameters must satisfy the following conditions:<itemizedlist>
<listitem><para><computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> (the entity type) is equivalent to a <computeroutput>ValueFunctor::argument_type</computeroutput>.</para>
</listitem><listitem><para><computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</computeroutput> (the coordinate type) is a field number type that is equivalent to <computeroutput>ValueFunctor::result_type::first_type</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>For example, if <computeroutput>CoordinateInputIterator</computeroutput> is an iterator with value type <computeroutput>std::pair&lt;Vertex_handle, double&gt;</computeroutput>, then the <computeroutput>ValueFunctor</computeroutput> must have argument type <computeroutput>Vertex_handle</computeroutput> (or convertible to) and return type <computeroutput>std::pair&lt;double, bool&gt;</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>beyond</parametername>
</parameternamelist>
<parameterdescription>
<para>is the iterator range for the coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>norm</parametername>
</parameternamelist>
<parameterdescription>
<para>is the normalization factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor of type <computeroutput>ValueFunctor</computeroutput> that allows to access a pair of a function value and a Boolean at a given entity. The Boolean indicates whether the function value could be retrieved correctly. This function generates the interpolated function value as the weighted sum of the values corresponding to each entry of the entity/coordinate pairs in the range <computeroutput>[first, beyond)</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="pre"><para><computeroutput>norm</computeroutput> <formula id="0">$ \neq0$</formula>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>first != beyond</computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>value_function(p.first).second == true</computeroutput> for all pairs <computeroutput>p</computeroutput> in the range <computeroutput>[first, beyond)</computeroutput>.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga50aa68e988b099a99533f26872c639f5" kindref="member">CGAL::quadratic_interpolation()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationNaturalNeighborCoordinates2" kindref="compound">CGAL::natural_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationRegularNeighborCoordinates2" kindref="compound">CGAL::regular_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationSurfaceNeighborCoordinates3" kindref="compound">3D Surface Neighbor Coordinates Functions</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/interpolation_functions.h" line="112" column="1" declfile="CGAL/interpolation_functions.h" declline="112" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolation2Interpolation_1ga50aa68e988b099a99533f26872c639f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class GradFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Point</type>
          </param>
        </templateparamlist>
        <type>ValueFunctor::result_type</type>
        <definition>ValueFunctor::result_type CGAL::quadratic_interpolation</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</argsstring>
        <name>quadratic_interpolation</name>
        <qualifiedname>CGAL::quadratic_interpolation</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>GradFunctor</type>
          <declname>gradient_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga50aa68e988b099a99533f26872c639f5" kindref="member">quadratic_interpolation()</ref></computeroutput> generates the interpolated function value as the weighted sum of the values plus a linear term in the gradient for each entity of the entity/coordinate pairs in the range <computeroutput>[first, beyond)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>If the interpolation was successful, the pair contains the interpolated function value as first and <computeroutput>true</computeroutput> as second value. Otherwise, the second value will be <computeroutput>false</computeroutput>.</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput><ref refid="classInterpolationTraits" kindref="compound">InterpolationTraits</ref></computeroutput>. Note that, contrary to some other interpolation methods, the number type <computeroutput>FT</computeroutput> provided by <computeroutput>Traits</computeroutput> does not need to provide the square root operation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CoordinateInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>ForwardIterator</computeroutput> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> can be of the following types: <itemizedlist>
<listitem>
<para>a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>  </para>
</listitem>
<listitem>
<para>an iterator type providing a <computeroutput>point()</computeroutput> function returning a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>;  </para>
</listitem>
</itemizedlist>
and <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</computeroutput> must be equivalent to <computeroutput>Traits::FT</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>ValueFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <computeroutput>Traits::FT</computeroutput> as well as a constructor with argument <computeroutput>0</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GradFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>GradFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>Functor::result_type</computeroutput> is a pair of the function&apos;s gradient type and a Boolean. The function gradient type must provide a multiplication operation with <computeroutput>Traits::Vector_d</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>must be equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
A model of the functor types <computeroutput>ValueFunctor</computeroutput> (resp. <computeroutput>GradFunctor</computeroutput>) is provided by the struct <computeroutput><ref refid="structCGAL_1_1Data__access" kindref="compound">CGAL::Data_access</ref></computeroutput>. It must be instantiated accordingly with an associative container (e.g. <computeroutput>std::map</computeroutput>) having <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> as <computeroutput>key_type</computeroutput> and the function value type (resp. the function gradient type) as <computeroutput>mapped_type</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>beyond</parametername>
</parameternamelist>
<parameterdescription>
<para>is the iterator range of the barycentric coordinates for the query point <computeroutput>p</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>norm</parametername>
</parameternamelist>
<parameterdescription>
<para>is the normalization factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>is the point at which the interpolated function value is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor that allows to access values of the interpolated function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gradient_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor that allows to access the function gradients. If the functor <computeroutput>gradient_function</computeroutput> cannot supply the gradient of a point, the function returns a pair where the Boolean is set to <computeroutput>false</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is an instance of the traits class.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="pre"><para><computeroutput>norm</computeroutput> <formula id="0">$ \neq0$</formula>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>first != beyond</computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>value_function(p.first).second == true</computeroutput> for pairs <computeroutput>p</computeroutput> in the range <computeroutput>[first, beyond)</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" kindref="member">CGAL::linear_interpolation()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Interpolation__traits__2" kindref="compound">CGAL::Interpolation_traits_2</ref>&lt;K&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationNaturalNeighborCoordinates2" kindref="compound">CGAL::natural_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationRegularNeighborCoordinates2" kindref="compound">CGAL::regular_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationSurfaceNeighborCoordinates3" kindref="compound">3D Surface Neighbor Coordinates Functions</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/interpolation_functions.h" line="178" column="1" declfile="CGAL/interpolation_functions.h" declline="178" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class GradFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Point</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; typename ValueFunctor::result_type, bool &gt;</type>
        <definition>std::pair&lt; typename ValueFunctor::result_type, bool &gt; CGAL::sibson_c1_interpolation</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</argsstring>
        <name>sibson_c1_interpolation</name>
        <qualifiedname>CGAL::sibson_c1_interpolation</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>GradFunctor</type>
          <declname>gradient_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>The function <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" kindref="member">sibson_c1_interpolation()</ref></computeroutput> generates the interpolated function value at the point <computeroutput>p</computeroutput>, using functors for the function values and the gradients, by applying Sibson&apos;s <formula id="1">$ Z^1$</formula> interpolant. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>If the interpolation was successful, the pair contains the interpolated function value as first and <computeroutput>true</computeroutput> as second value. Otherwise, <computeroutput>false</computeroutput> is returned as second value.</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput><ref refid="classInterpolationTraits" kindref="compound">InterpolationTraits</ref></computeroutput>. The number type <computeroutput>FT</computeroutput> provided by <computeroutput>Traits</computeroutput> must support the square root operation <computeroutput>sqrt()</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CoordinateInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>ForwardIterator</computeroutput> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> can be of the following types: <itemizedlist>
<listitem>
<para>a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>  </para>
</listitem>
<listitem>
<para>an iterator type providing a <computeroutput>point()</computeroutput> function returning a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>;  </para>
</listitem>
</itemizedlist>
and <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</computeroutput> must be equivalent to <computeroutput>Traits::FT</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>ValueFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <computeroutput>Traits::FT</computeroutput> as well as a constructor with argument <computeroutput>0</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GradFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>GradFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinatetCoordinateInputIteratorIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>Functor::result_type</computeroutput> is a pair of the function&apos;s gradient type and a Boolean. The function gradient type must provide a multiplication operation with <computeroutput>Traits::Vector_d</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>must be equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
A model of the functor types <computeroutput>ValueFunctor</computeroutput> (resp. <computeroutput>GradFunctor</computeroutput>) is provided by the struct <computeroutput><ref refid="structCGAL_1_1Data__access" kindref="compound">CGAL::Data_access</ref></computeroutput>. It must be instantiated accordingly with an associative container (e.g. <computeroutput>std::map</computeroutput>) having <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> as <computeroutput>key_type</computeroutput> and the function value type (resp. the function gradient type) as <computeroutput>mapped_type</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>beyond</parametername>
</parameternamelist>
<parameterdescription>
<para>is the iterator range of the barycentric coordinates for the query point <computeroutput>p</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>norm</parametername>
</parameternamelist>
<parameterdescription>
<para>is the normalization factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>is the point at which the interpolated function value is computed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor that allows to access values of the interpolated function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gradient_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor that allows to access the function gradients. If the functor <computeroutput>gradient_function</computeroutput> cannot supply the gradient of a point, the function returns a pair where the Boolean is set to <computeroutput>false</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is an instance of the traits class.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="pre"><para><computeroutput>norm</computeroutput> <formula id="0">$ \neq0$</formula>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>first != beyond</computeroutput>. </para>
</simplesect>
<simplesect kind="pre"><para><computeroutput>value_function(q).second == true</computeroutput> for all points <computeroutput>q</computeroutput> of the point/coordinate pairs in the range <computeroutput>[first, beyond)</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Interpolation__traits__2" kindref="compound">CGAL::Interpolation_traits_2</ref>&lt;K&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga1f84e03a02a6602d45c26f600a6d225b" kindref="member">CGAL::sibson_c1_interpolation_square()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationNaturalNeighborCoordinates2" kindref="compound">CGAL::natural_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolationRegularNeighborCoordinates2" kindref="compound">CGAL::regular_neighbor_coordinates_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__PkgInterpolationSurfaceNeighborCoordinates3" kindref="compound">3D Surface Neighbor Coordinates Functions</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/interpolation_functions.h" line="245" column="1" declfile="CGAL/interpolation_functions.h" declline="245" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolation2Interpolation_1ga1f84e03a02a6602d45c26f600a6d225b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class GradFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Point</type>
          </param>
        </templateparamlist>
        <type>ValueFunctor::result_type</type>
        <definition>ValueFunctor::result_type CGAL::sibson_c1_interpolation_square</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</argsstring>
        <name>sibson_c1_interpolation_square</name>
        <qualifiedname>CGAL::sibson_c1_interpolation_square</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>GradFunctor</type>
          <declname>gradient_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" kindref="member">sibson_c1_interpolation()</ref></computeroutput>, except that no square root operation is required for the number type <computeroutput>Traits::FT</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" kindref="member">CGAL::sibson_c1_interpolation()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/interpolation_functions.h" line="262" column="1" declfile="CGAL/interpolation_functions.h" declline="262" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolation2Interpolation_1ga40856de51734ae1b1882cb46e8195c93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class GradFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Point</type>
          </param>
        </templateparamlist>
        <type>ValueFunctor::result_type</type>
        <definition>ValueFunctor::result_type CGAL::farin_c1_interpolation</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</argsstring>
        <name>farin_c1_interpolation</name>
        <qualifiedname>CGAL::farin_c1_interpolation</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>GradFunctor</type>
          <declname>gradient_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Generates the interpolated function value computed by Farin&apos;s interpolant. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Requirements</bold><linebreak/>
</para>
<para>Same requirements as the function <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" kindref="member">sibson_c1_interpolation()</ref></computeroutput>, but the input iterator must provide random access (be a model of <computeroutput>RandomAccessIterator</computeroutput>) and <computeroutput>Traits::FT</computeroutput> does not need to provide the square root operation.</para>
<para><simplesect kind="pre"><para>The range <computeroutput>[first, beyond)</computeroutput> contains either one or more than three elements. The function <computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga40856de51734ae1b1882cb46e8195c93" kindref="member">farin_c1_interpolation()</ref></computeroutput> interpolates the function values and the gradients that are provided by functors using the method described in <ref refid="citelist_1CITEREF_f-sodt-90" kindref="member">[4]</ref>.</para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgInterpolation2Interpolation_1ga79d301865904d46b1fd247594a07db55" kindref="member">CGAL::sibson_c1_interpolation()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/interpolation_functions.h" line="288" column="1" declfile="CGAL/interpolation_functions.h" declline="288" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationNaturalNeighborCoordinates2_1ga25b17c97b024672227dacf7283e2c485" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt; CGAL::natural_neighbor_coordinates_2</definition>
        <argsstring>(const Dt &amp;dt, const typename Dt::Geom_traits::Point_2 &amp;p, CoordinateOutputIterator out, OutputFunctor fct, typename Dt::Face_handle start=typename Dt::Face_handle())</argsstring>
        <name>natural_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::natural_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>typename Dt::Face_handle</type>
          <declname>start</declname>
          <defval>typename Dt::Face_handle()</defval>
        </param>
        <briefdescription>
<para>Computes the natural neighbor coordinates for <computeroutput>p</computeroutput> with respect to the points in the two-dimensional Delaunay triangulation <computeroutput>dt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dt</parametername>
</parameternamelist>
<parameterdescription>
<para>must be of type <computeroutput>Delaunay_triangulation_2&lt;Traits, Tds&gt;</computeroutput>. <computeroutput>Traits</computeroutput> must be a model of the concepts <computeroutput>DelaunayTriangulationTraits_2</computeroutput> and <computeroutput>PolygonTraits_2</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CoordinateOutputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>OutputIterator</computeroutput> and have the value type <computeroutput>OutputFunctor::result_type</computeroutput>. The output computed by the function is placed starting at <computeroutput>out</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor with argument type <computeroutput>std::pair&lt;Dt::Vertex_handle, Dt::Geom_traits::FT&gt;</computeroutput>. See <ref refid="group__PkgInterpolationNaturalNeighborCoordinates2" kindref="compound">above </ref> for a detailed explanation on the usage of <computeroutput>OutputFunctor</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>is the Delaunay triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>is the query point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>CoordinateOutputIterator</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fct</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>OutputFunctor</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>is an optional argument that is used as a hint of where the locate process has to start its search.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A triple consisting of:<itemizedlist>
<listitem><para>a sequence of objects of types <computeroutput>OutputFunctor::result_type</computeroutput>, starting at <computeroutput>out</computeroutput>.</para>
</listitem><listitem><para>the normalization factor of the coordinates.</para>
</listitem><listitem><para>a Boolean value which is set to <computeroutput>true</computeroutput> if the coordinate computation was successful, and <computeroutput>false</computeroutput> otherwise. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/natural_neighbor_coordinates_2.h" line="78" column="1" declfile="CGAL/natural_neighbor_coordinates_2.h" declline="78" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationNaturalNeighborCoordinates2_1gaa5ca9740fd1d6d7445126c0067775154" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
          <param>
            <type>class EdgeIterator</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt; CGAL::natural_neighbor_coordinates_2</definition>
        <argsstring>(const Dt &amp;dt, const typename Dt::Geom_traits::Point_2 &amp;p, CoordinateOutputIterator out, OutputFunctor fct, EdgeIterator hole_begin, EdgeIterator hole_end)</argsstring>
        <name>natural_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::natural_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>EdgeIterator</type>
          <declname>hole_begin</declname>
        </param>
        <param>
          <type>EdgeIterator</type>
          <declname>hole_end</declname>
        </param>
        <briefdescription>
<para>Computes the natural neighbor coordinates for <computeroutput>p</computeroutput> with respect to the points in the two-dimensional Delaunay triangulation <computeroutput>dt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The iterator range <computeroutput>[hole_begin, hole_end)</computeroutput> determines the boundary edges of the conflict zone of <computeroutput>p</computeroutput> in the triangulation. It can, for example, be computed using the function: <ref refid="" kindref="compound"><computeroutput>dt.get_boundary_of_conflicts(p, std::back_inserter(hole), start)</computeroutput></ref>.</para>
<para><bold>Requirements</bold><linebreak/>
 Same as above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/natural_neighbor_coordinates_2.h" line="98" column="1" declfile="CGAL/natural_neighbor_coordinates_2.h" declline="98" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationNaturalNeighborCoordinates2_1gaad9f638706f9df1f6667c30112638cb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Dt::Geom_traits::FT, bool &gt; CGAL::natural_neighbor_coordinates_2</definition>
        <argsstring>(const Dt &amp;dt, typename Dt::Vertex_handle vh, CoordinateOutputIterator out, OutputFunctor fct)</argsstring>
        <name>natural_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::natural_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>typename Dt::Vertex_handle</type>
          <declname>vh</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <briefdescription>
<para>Computes the natural neighbor coordinates of the point <computeroutput>vh-&gt;point()</computeroutput> with respect to the vertices of <computeroutput>dt</computeroutput> excluding <computeroutput>vh-&gt;point()</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Requirements</bold><linebreak/>
 Same as above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/natural_neighbor_coordinates_2.h" line="113" column="1" declfile="CGAL/natural_neighbor_coordinates_2.h" declline="113" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationRegularNeighborCoordinates2_1ga8fc26e371da4e18ee766d68b22af4106" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Rt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Rt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Rt::Geom_traits::FT, bool &gt; CGAL::regular_neighbor_coordinates_2</definition>
        <argsstring>(const Rt &amp;rt, const typename Rt::Weighted_point &amp;p, CoordinateOutputIterator out, OutputFunctor fct, typename Rt::Face_handle start=typename Rt::Face_handle())</argsstring>
        <name>regular_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::regular_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Rt &amp;</type>
          <declname>rt</declname>
        </param>
        <param>
          <type>const typename Rt::Weighted_point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>typename Rt::Face_handle</type>
          <declname>start</declname>
          <defval>typename Rt::Face_handle()</defval>
        </param>
        <briefdescription>
<para>Computes the regular neighbor coordinates for <computeroutput>p</computeroutput> with respect to the weighted points in the two-dimensional regular triangulation <computeroutput>rt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Rt</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a <computeroutput>Regular_triangulation_2&lt;Traits, Tds&gt;</computeroutput>. <computeroutput>Traits</computeroutput> must be a model of the concepts <computeroutput>RegularTriangulationTraits_2</computeroutput> and <computeroutput>PolygonTraits_2</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CoordinateOutputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>OutputIterator</computeroutput> and have the value type <computeroutput>OutputFunctor::result_type</computeroutput>. The output computed by the function is placed starting at <computeroutput>out</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor with argument type <computeroutput>std::pair&lt;Rt::Vertex_handle, Rt::Geom_traits::FT&gt;</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
See <ref refid="group__PkgInterpolationRegularNeighborCoordinates2" kindref="compound">above </ref> for a detailed explanation on the usage of <computeroutput>OutputFunctor</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rt</parametername>
</parameternamelist>
<parameterdescription>
<para>is the regular triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>is the query point. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>CoordinateOutputIterator</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fct</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>OutputFunctor</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>is an optional argument that is used as a hint of where the locate process has to start its search.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A triple consisting of:<itemizedlist>
<listitem><para>a sequence of objects of types <computeroutput>OutputFunctor::result_type</computeroutput>, starting at <computeroutput>out</computeroutput>.</para>
</listitem><listitem><para>the normalization factor of the coordinates.</para>
</listitem><listitem><para>a Boolean value which is set to <computeroutput>true</computeroutput> if the coordinate computation was successful, and <computeroutput>false</computeroutput> otherwise.</para>
</listitem></itemizedlist>
</para>
</simplesect>
<simplesect kind="warning"><para>If the weight of <computeroutput>p</computeroutput> is so small that the point <computeroutput>p</computeroutput> would not have any power cell if it were inserted in the power diagram, then the resulting triple will be <computeroutput>(out, 0, true)</computeroutput> with no additional entry in <computeroutput>out</computeroutput> (compared to its state in input). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/regular_neighbor_coordinates_2.h" line="85" column="1" declfile="CGAL/regular_neighbor_coordinates_2.h" declline="85" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationRegularNeighborCoordinates2_1ga5cc28acccca6ea608abfcc2525a8bf2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Rt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
          <param>
            <type>class EdgeIterator</type>
          </param>
          <param>
            <type>class VertexIterator</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Traits::FT, bool &gt; CGAL::regular_neighbor_coordinates_2</definition>
        <argsstring>(const Rt &amp;rt, const typename Traits::Weighted_point &amp;p, CoordinateOutputIterator out, OutputFunctor fct, EdgeIterator hole_begin, EdgeIterator hole_end, VertexIterator hidden_vertices_begin, VertexIterator hidden_vertices_end)</argsstring>
        <name>regular_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::regular_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Rt &amp;</type>
          <declname>rt</declname>
        </param>
        <param>
          <type>const typename Traits::Weighted_point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>EdgeIterator</type>
          <declname>hole_begin</declname>
        </param>
        <param>
          <type>EdgeIterator</type>
          <declname>hole_end</declname>
        </param>
        <param>
          <type>VertexIterator</type>
          <declname>hidden_vertices_begin</declname>
        </param>
        <param>
          <type>VertexIterator</type>
          <declname>hidden_vertices_end</declname>
        </param>
        <briefdescription>
<para>Computes the regular neighbor coordinates for <computeroutput>p</computeroutput> with respect to the weighted points in the two-dimensional regular triangulation <computeroutput>rt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The iterator range <computeroutput>[hole_begin, hole_end)</computeroutput> determines the boundary edges of the conflict zone of <computeroutput>p</computeroutput> in the triangulation <computeroutput>rt</computeroutput>. <ref refid="" kindref="compound"><computeroutput>rt.hidden_vertices_begin()</computeroutput></ref> and <ref refid="" kindref="compound"><computeroutput>rt.hidden_vertices_end()</computeroutput></ref> determines the iterator range over the hidden vertices of the conflict zone of <computeroutput>p</computeroutput> in<computeroutput>rt</computeroutput>. Those ranges can, for example, be computed using the function <ref refid="" kindref="compound"><computeroutput>rt.get_boundary_of_conflicts_and_hidden_vertices(p,std::back_inserter(hole), std::back_inserter(hidden_vertices), start)</computeroutput></ref>.</para>
<para><bold>Requirements</bold><linebreak/>
 Same as above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/regular_neighbor_coordinates_2.h" line="110" column="1" declfile="CGAL/regular_neighbor_coordinates_2.h" declline="110" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationRegularNeighborCoordinates2_1ga92a6a6277e01784518649cfb1d952af8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Rt</type>
          </param>
          <param>
            <type>class CoordinateOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; CoordinateOutputIterator, typename Rt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; CoordinateOutputIterator, typename Rt::Geom_traits::FT, bool &gt; CGAL::regular_neighbor_coordinates_2</definition>
        <argsstring>(const Rt &amp;rt, typename Rt::Vertex_handle vh, CoordinateOutputIterator out, OutputFunctor fct)</argsstring>
        <name>regular_neighbor_coordinates_2</name>
        <qualifiedname>CGAL::regular_neighbor_coordinates_2</qualifiedname>
        <param>
          <type>const Rt &amp;</type>
          <declname>rt</declname>
        </param>
        <param>
          <type>typename Rt::Vertex_handle</type>
          <declname>vh</declname>
        </param>
        <param>
          <type>CoordinateOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <briefdescription>
<para>Computes the regular neighbor coordinates of the point <computeroutput>vh-&gt;point()</computeroutput> with respect to the vertices of <computeroutput>rt</computeroutput> excluding <computeroutput>vh-&gt;point()</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><bold>Requirements</bold><linebreak/>
 Same as above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/regular_neighbor_coordinates_2.h" line="126" column="1" declfile="CGAL/regular_neighbor_coordinates_2.h" declline="126" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSibsonGradientFitting_1ga9c4601224b6352ed583f247fe3fee826" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class CoordinateInputIterator</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
          <param>
            <type>class Point</type>
          </param>
        </templateparamlist>
        <type>Traits::Vector_d</type>
        <definition>Traits::Vector_d CGAL::sibson_gradient_fitting</definition>
        <argsstring>(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, const typename ValueFunctor::result_type::first_type fn, const Traits &amp;traits)</argsstring>
        <name>sibson_gradient_fitting</name>
        <qualifiedname>CGAL::sibson_gradient_fitting</qualifiedname>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>CoordinateInputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>const Point &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>const typename ValueFunctor::result_type::first_type</type>
          <declname>fn</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Estimates the gradient of a function at a query point. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>CoordinateInputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>ForwardIterator</computeroutput> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> can be of the following types: <itemizedlist>
<listitem>
<para>a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>  </para>
</listitem>
<listitem>
<para>an iterator type providing a <computeroutput>point()</computeroutput> function returning a type equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>;  </para>
</listitem>
</itemizedlist>
and <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</computeroutput> must be equivalent to <computeroutput>Traits::FT</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where <computeroutput>ValueFunctor::argument_type</computeroutput> must be equivalent to <computeroutput>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</computeroutput> and <computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <computeroutput>Traits::FT</computeroutput> as well as a constructor with argument <computeroutput>0</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of the concept <computeroutput><ref refid="classGradientFittingTraits" kindref="compound">GradientFittingTraits</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Point</parametername>
</parameternamelist>
<parameterdescription>
<para>must be equivalent to <computeroutput>Traits::Point_d</computeroutput> or <computeroutput>Traits::Weighted_point_d</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
An example of compatible types for <computeroutput>CoordinateInputIterator</computeroutput> and <computeroutput>ValueFunctor</computeroutput> is a forward iterator with value type <computeroutput>std::pair&lt;Vertex_handle, Traits::FT&gt;</computeroutput> and a functor with argument type <computeroutput>Vertex_handle</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>beyond</parametername>
</parameternamelist>
<parameterdescription>
<para>is the iterator range of the neighbor coordinates for the query point <computeroutput>p</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>norm</parametername>
</parameternamelist>
<parameterdescription>
<para>is the normalization factor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>is the query point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor that allows to access values of the interpolated function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fn</parametername>
</parameternamelist>
<parameterdescription>
<para>is the value of the function at <computeroutput>p</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is an instance of the gradient fitting traits class.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the gradient at the point <computeroutput>p</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/sibson_gradient_fitting.h" line="70" column="1" declfile="CGAL/sibson_gradient_fitting.h" declline="70" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSibsonGradientFitting_1ga2063ef2d118d601f4d0789ffcf2c191f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class GradientOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>GradientOutputIterator</type>
        <definition>GradientOutputIterator CGAL::sibson_gradient_fitting_nn_2</definition>
        <argsstring>(const Dt &amp;dt, GradientOutputIterator out, OutputFunctor fct, ValueFunctor value_function, const Traits &amp;traits)</argsstring>
        <name>sibson_gradient_fitting_nn_2</name>
        <qualifiedname>CGAL::sibson_gradient_fitting_nn_2</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>GradientOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Estimates the function gradients at all vertices of the Delaunay triangulation <computeroutput>dt</computeroutput> that lie inside the convex hull, using the coordinates computed by the function <ref refid="group__PkgInterpolationNaturalNeighborCoordinates2" kindref="compound">CGAL::natural_neighbor_coordinates_2()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Dt</parametername>
</parameternamelist>
<parameterdescription>
<para>must be of type <computeroutput>Delaunay_triangulation_2&lt;Dt_Traits, Tds&gt;</computeroutput>. <computeroutput>Dt_Traits</computeroutput> must be a model of the concepts <computeroutput>DelaunayTriangulationTraits_2</computeroutput> and <computeroutput>PolygonTraits_2</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GradientOutputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>OutputIterator</computeroutput> with value type <computeroutput>OutputFunctor::result_type</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor with argument type <computeroutput>std::pair&lt;Dt::Vertex_handle, Traits::Vector_d&gt;</computeroutput>. Note that the result type of the functor is not specified and is chosen by users to fit their needs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where:<itemizedlist>
<listitem><para><computeroutput>ValueFunctor::argument_type</computeroutput> must be either <computeroutput>Dt::Vertex_handle</computeroutput> or <computeroutput>Dt::Point</computeroutput>.</para>
</listitem><listitem><para><computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <computeroutput>Traits::FT</computeroutput> as well as a constructor with argument <computeroutput>0</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput><ref refid="classGradientFittingTraits" kindref="compound">GradientFittingTraits</ref></computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>is the Delaunay triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>GradientOutputIterator</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fct</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>OutputFunctor</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor of type <computeroutput>ValueFunctor</computeroutput> that gives access to the values of the function at points of the triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is an instance of the gradient fitting traits class.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An output iterator with value type <computeroutput>OutputFunctor::result_type</computeroutput>. The sequence is written starting at <computeroutput>out</computeroutput>. The function returns an iterator that is placed past-the-end of the resulting sequence. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/sibson_gradient_fitting.h" line="108" column="1" declfile="CGAL/sibson_gradient_fitting.h" declline="108" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSibsonGradientFitting_1gadd232ce2ff777c055c039aa9bcff7e90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Rt</type>
          </param>
          <param>
            <type>class GradientOutputIterator</type>
          </param>
          <param>
            <type>class OutputFunctor</type>
          </param>
          <param>
            <type>class ValueFunctor</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>GradientOutputIterator</type>
        <definition>GradientOutputIterator CGAL::sibson_gradient_fitting_rn_2</definition>
        <argsstring>(const Rt &amp;rt, GradientOutputIterator out, OutputFunctor fct, ValueFunctor value_function, const Traits &amp;traits)</argsstring>
        <name>sibson_gradient_fitting_rn_2</name>
        <qualifiedname>CGAL::sibson_gradient_fitting_rn_2</qualifiedname>
        <param>
          <type>const Rt &amp;</type>
          <declname>rt</declname>
        </param>
        <param>
          <type>GradientOutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>OutputFunctor</type>
          <declname>fct</declname>
        </param>
        <param>
          <type>ValueFunctor</type>
          <declname>value_function</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Estimates the function gradients at all vertices of <computeroutput>rt</computeroutput> that lie inside the convex hull using the coordinates computed by the functions <ref refid="group__PkgInterpolationRegularNeighborCoordinates2" kindref="compound">CGAL::regular_neighbor_coordinates_2()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Rt</parametername>
</parameternamelist>
<parameterdescription>
<para>must be of type <computeroutput>Regular_triangulation_2&lt;Rt_Traits, Tds&gt;</computeroutput>. <computeroutput>Rt_Traits</computeroutput> must be a model of the concepts <computeroutput>RegularTriangulationTraits_2</computeroutput> and <computeroutput>PolygonTraits_2</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GradientOutputIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput>OutputIterator</computeroutput> with value type <computeroutput>OutputFunctor::result_type</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor with argument type <computeroutput>std::pair&lt;Rt::Vertex_handle, Traits::Vector_d&gt;</computeroutput>. Note that the result type of the functor is not specified and is chosen by users to fit their needs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueFunctor</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a functor where:<itemizedlist>
<listitem><para><computeroutput>ValueFunctor::argument_type</computeroutput> must be either <computeroutput>Rt::Vertex_handle</computeroutput> or <computeroutput>Rt::Weighted_point</computeroutput>.</para>
</listitem><listitem><para><computeroutput>ValueFunctor::result_type</computeroutput> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <computeroutput>Traits::FT</computeroutput> as well as a constructor with argument <computeroutput>0</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of <computeroutput><ref refid="classGradientFittingTraits" kindref="compound">GradientFittingTraits</ref></computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rt</parametername>
</parameternamelist>
<parameterdescription>
<para>is the regular triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>GradientOutputIterator</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fct</parametername>
</parameternamelist>
<parameterdescription>
<para>is an object of type <computeroutput>OutputFunctor</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_function</parametername>
</parameternamelist>
<parameterdescription>
<para>is a functor of type <computeroutput>ValueFunctor</computeroutput> that gives access to the values of the function at points of the triangulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is an instance of the gradient fitting traits class.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An output iterator with value type <computeroutput>OutputFunctor::result_type</computeroutput>. The sequence is written starting at <computeroutput>out</computeroutput>. The function returns an iterator that is placed past-the-end of the resulting sequence. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/sibson_gradient_fitting.h" line="145" column="1" declfile="CGAL/sibson_gradient_fitting.h" declline="145" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga07c7f1c1efbbbe293fcb2835ca39ed0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; OutputIterator, typename Kernel::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; OutputIterator, typename Kernel::FT, bool &gt; CGAL::surface_neighbor_coordinates_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::Vector_3 &amp;normal, OutputIterator out, const Kernel &amp;K)</argsstring>
        <name>surface_neighbor_coordinates_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>K</declname>
        </param>
        <briefdescription>
<para>The sample points <formula id="2">$ \mathcal{P}$</formula> are provided in the range <computeroutput>[first, beyond)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type of <computeroutput>InputIterator</computeroutput> is the point type <computeroutput>Kernel::Point_3</computeroutput>. The tangent plane is defined by the point <computeroutput>p</computeroutput> and the vector <computeroutput>normal</computeroutput>. The parameter <computeroutput>K</computeroutput> determines the kernel type that will instantiate the template parameter of <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>.</para>
<para>The natural neighbor coordinates for <computeroutput>p</computeroutput> are computed in the power diagram that results from the intersection of the <computeroutput>3D</computeroutput> Voronoi diagram of <formula id="2">$ \mathcal{P}$</formula> with the tangent plane. The sequence of point/coordinate pairs that is computed by the function is placed starting at <computeroutput>out</computeroutput>. The function returns a triple with an iterator that is placed past-the-end of the resulting sequence of point/coordinate pairs, the normalization factor of the coordinates and a Boolean value which is set to true iff the coordinate computation was successful, i.e. if <computeroutput>p</computeroutput> lies inside the convex hull of the projection of the points <formula id="2">$ \mathcal{P}$</formula> onto the tangent plane. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="77" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="77" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1gaf3828379a27f58a146e0a617b4838b73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; OutputIterator, typename ITraits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; OutputIterator, typename ITraits::FT, bool &gt; CGAL::surface_neighbor_coordinates_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbor_coordinates_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above only that the traits class must be instantiated by the user. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="89" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="89" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga34727b94b9c03ff1e5c23df456b11bc5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>CGAL::Quadruple&lt; OutputIterator, typename Kernel::FT, bool, bool &gt;</type>
        <definition>CGAL::Quadruple&lt; OutputIterator, typename Kernel::FT, bool, bool &gt; CGAL::surface_neighbor_coordinates_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::Vector_3 &amp;normal, OutputIterator out, const Kernel &amp;K)</argsstring>
        <name>surface_neighbor_coordinates_certified_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>K</declname>
        </param>
        <briefdescription>
<para>Similar to the first function. </para>
        </briefdescription>
        <detaileddescription>
<para>The additional fourth return value is <computeroutput>true</computeroutput> if the furthest point in the range <computeroutput>[first, beyond)</computeroutput> is further away from <computeroutput>p</computeroutput> than twice the distance from <computeroutput>p</computeroutput> to the furthest vertex of the intersection of the Voronoi cell of <computeroutput>p</computeroutput> with the tangent plane defined by <computeroutput>(p,normal)</computeroutput>. It is <computeroutput>false</computeroutput> otherwise. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="105" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="105" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga3d558dc6eb0e33cb30d57cb948012611" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>CGAL::Quadruple&lt; OutputIterator, typename Kernel::FT, bool, bool &gt;</type>
        <definition>CGAL::Quadruple&lt; OutputIterator, typename Kernel::FT, bool, bool &gt; CGAL::surface_neighbor_coordinates_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::FT &amp;max_distance, OutputIterator out, const Kernel &amp;kernel)</argsstring>
        <name>surface_neighbor_coordinates_certified_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>max_distance</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>kernel</declname>
        </param>
        <briefdescription>
<para>Same as above except that this function takes the maximal distance from p to the points in the range <computeroutput>[first, beyond)</computeroutput> as additional parameter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="118" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="118" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1gaf835452218b269d904d347b1eb744b3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>CGAL::Quadruple&lt; OutputIterator, typename ITraits::FT, bool, bool &gt;</type>
        <definition>CGAL::Quadruple&lt; OutputIterator, typename ITraits::FT, bool, bool &gt; CGAL::surface_neighbor_coordinates_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbor_coordinates_certified_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above only that the traits class must be instantiated by the user and without the parameter <computeroutput>max_distance</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="131" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="131" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga17b70d8ed51990a120bda048ad40c670" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>CGAL::Quadruple&lt; OutputIterator, typename ITraits::FT, bool, bool &gt;</type>
        <definition>CGAL::Quadruple&lt; OutputIterator, typename ITraits::FT, bool, bool &gt; CGAL::surface_neighbor_coordinates_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, const typename ITraits::FT &amp;max_distance, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbor_coordinates_certified_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename ITraits::FT &amp;</type>
          <declname>max_distance</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above with the parameter <computeroutput>max_distance</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="141" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="141" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga1acd1dbfd84236f120b25aac9f94de9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; OutputIterator, typename Dt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; OutputIterator, typename Dt::Geom_traits::FT, bool &gt; CGAL::surface_neighbor_coordinates_3</definition>
        <argsstring>(const Dt &amp;dt, const typename Dt::Geom_traits::Point_3 &amp;p, const typename Dt::Geom_traits::Vector_3 &amp;normal, OutputIterator out, typename Dt::Cell_handle start=typename Dt::Cell_handle())</argsstring>
        <name>surface_neighbor_coordinates_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_3</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>typename Dt::Cell_handle</type>
          <declname>start</declname>
          <defval>typename Dt::Cell_handle()</defval>
        </param>
        <briefdescription>
<para>Computes the surface neighbor coordinates with respect to the points that are vertices of the Delaunay triangulation <computeroutput>dt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The type <computeroutput>Dt</computeroutput> must be equivalent to <computeroutput>Delaunay_triangulation_3&lt;Gt, Tds&gt;</computeroutput>. The optional parameter <computeroutput>start</computeroutput> is used as a starting place for the search of the conflict zone. It may be the result of the call <computeroutput>dt.locate(p)</computeroutput>. This function instantiates the template parameter <computeroutput>ITraits</computeroutput> to be <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;Dt::Geom_traits&gt;</computeroutput>.</para>
<para>This function allows to filter some potential neighbors of the query point <computeroutput>p</computeroutput> from <formula id="2">$ \mathcal{P}$</formula> via its three-dimensional Delaunay triangulation. All surface neighbors of <computeroutput>p</computeroutput> are necessarily neighbors in the Delaunay triangulation of <formula id="3">$ \mathcal{P}
\cup \{p\}$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="164" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="164" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighborCoordinates3_1ga76b9a4682f5d5ae934cb471c1e6bad45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>CGAL::Triple&lt; OutputIterator, typename Dt::Geom_traits::FT, bool &gt;</type>
        <definition>CGAL::Triple&lt; OutputIterator, typename Dt::Geom_traits::FT, bool &gt; CGAL::surface_neighbor_coordinates_3</definition>
        <argsstring>(const Dt &amp;dt, const typename Dt::Geom_traits::Point_3 &amp;p, OutputIterator out, const ITraits &amp;traits, typename Dt::Cell_handle start=typename Dt::Cell_handle())</argsstring>
        <name>surface_neighbor_coordinates_3</name>
        <qualifiedname>CGAL::surface_neighbor_coordinates_3</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <param>
          <type>typename Dt::Cell_handle</type>
          <declname>start</declname>
          <defval>typename Dt::Cell_handle()</defval>
        </param>
        <briefdescription>
<para>Same as above only that the parameter traits instantiates the geometric traits class. </para>
        </briefdescription>
        <detaileddescription>
<para>Its type <computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbor_coordinates_3.h" line="177" column="1" declfile="CGAL/surface_neighbor_coordinates_3.h" declline="177" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1gaa7b22ceb4ba69de0f4485b6fef0973d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::surface_neighbors_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::Vector_3 &amp;normal, OutputIterator out, const Kernel &amp;K)</argsstring>
        <name>surface_neighbors_3</name>
        <qualifiedname>CGAL::surface_neighbors_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>K</declname>
        </param>
        <briefdescription>
<para>The sample points <formula id="2">$ \mathcal{P}$</formula> are provided in the range <computeroutput>[first, beyond)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>InputIterator::value_type</computeroutput> is the point type <computeroutput>Kernel::Point_3</computeroutput>. The tangent plane is defined by the point <computeroutput>p</computeroutput> and the vector <computeroutput>normal</computeroutput>. The parameter <computeroutput>K</computeroutput> determines the kernel type that will instantiate the template parameter of <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>.</para>
<para>The surface neighbors of <computeroutput>p</computeroutput> are computed which are the neighbors of <computeroutput>p</computeroutput> in the regular triangulation that is dual to the intersection of the 3D Voronoi diagram of <formula id="2">$ \mathcal{P}$</formula> with the tangent plane. The point sequence that is computed by the function is placed starting at <computeroutput>out</computeroutput>. The function returns an iterator that is placed past-the-end of the resulting point sequence. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="69" column="1" declfile="CGAL/surface_neighbors_3.h" declline="69" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1gacf9c8082674c6e1a0e6de53e11674d81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::surface_neighbors_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbors_3</name>
        <qualifiedname>CGAL::surface_neighbors_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above only that the traits class must be instantiated by the user. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="81" column="16" declfile="CGAL/surface_neighbors_3.h" declline="81" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1ga6aaf7c3b7940aa904153ac3dda9c5c35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; OutputIterator, bool &gt;</type>
        <definition>std::pair&lt; OutputIterator, bool &gt; CGAL::surface_neighbors_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::Vector_3 &amp;normal, OutputIterator out, const Kernel &amp;K)</argsstring>
        <name>surface_neighbors_certified_3</name>
        <qualifiedname>CGAL::surface_neighbors_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>K</declname>
        </param>
        <briefdescription>
<para>Similar to the first function. </para>
        </briefdescription>
        <detaileddescription>
<para>The additional third return value is <computeroutput>true</computeroutput> if the furthest point in the range <computeroutput>[first, beyond)</computeroutput> is further away from <computeroutput>p</computeroutput> than twice the distance from <computeroutput>p</computeroutput> to the furthest vertex of the intersection of the Voronoi cell of <computeroutput>p</computeroutput> with the tangent plane defined be <computeroutput>(p,normal)</computeroutput>. It is <computeroutput>false</computeroutput> otherwise. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="97" column="1" declfile="CGAL/surface_neighbors_3.h" declline="97" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1ga3b788888878de29aafc20307331860d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class Kernel</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; OutputIterator, bool &gt;</type>
        <definition>std::pair&lt; OutputIterator, bool &gt; CGAL::surface_neighbors_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename Kernel::Point_3 &amp;p, const typename Kernel::Vector_3 &amp;normal, const typename Kernel::FT &amp;max_distance, OutputIterator out, const Kernel &amp;kernel)</argsstring>
        <name>surface_neighbors_certified_3</name>
        <qualifiedname>CGAL::surface_neighbors_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename Kernel::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Kernel::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>max_distance</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const Kernel &amp;</type>
          <declname>kernel</declname>
        </param>
        <briefdescription>
<para>Same as above except that this function takes the maximal distance from <computeroutput>p</computeroutput> to the points in the range <computeroutput>[first, beyond)</computeroutput> as additional parameter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="110" column="1" declfile="CGAL/surface_neighbors_3.h" declline="110" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1ga51de5ac908b02ab18ef32da495d782f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; OutputIterator, bool &gt;</type>
        <definition>std::pair&lt; OutputIterator, bool &gt; CGAL::surface_neighbors_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbors_certified_3</name>
        <qualifiedname>CGAL::surface_neighbors_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above only that the traits class must be instantiated by the user. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. There is no parameter <computeroutput>max_distance</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="124" column="1" declfile="CGAL/surface_neighbors_3.h" declline="124" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1gac679bc9786ba7bb5de2909c53c10070a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class InputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; OutputIterator, bool &gt;</type>
        <definition>std::pair&lt; OutputIterator, bool &gt; CGAL::surface_neighbors_certified_3</definition>
        <argsstring>(InputIterator first, InputIterator beyond, const typename ITraits::Point_2 &amp;p, const typename ITraits::FT &amp;max_distance, OutputIterator out, const ITraits &amp;traits)</argsstring>
        <name>surface_neighbors_certified_3</name>
        <qualifiedname>CGAL::surface_neighbors_certified_3</qualifiedname>
        <param>
          <type>InputIterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIterator</type>
          <declname>beyond</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename ITraits::FT &amp;</type>
          <declname>max_distance</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Same as above with the parameter <computeroutput>max_distance</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="134" column="1" declfile="CGAL/surface_neighbors_3.h" declline="134" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1gae791b29493f15c9785a837cc766b38d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::surface_neighbors_3</definition>
        <argsstring>(const Dt &amp;dt, const typename Dt::Geom_traits::Point_3 &amp;p, const typename Dt::Geom_traits::Vector_3 &amp;normal, OutputIterator out, typename Dt::Cell_handle start=typename Dt::Cell_handle())</argsstring>
        <name>surface_neighbors_3</name>
        <qualifiedname>CGAL::surface_neighbors_3</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Point_3 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const typename Dt::Geom_traits::Vector_3 &amp;</type>
          <declname>normal</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>typename Dt::Cell_handle</type>
          <declname>start</declname>
          <defval>typename Dt::Cell_handle()</defval>
        </param>
        <briefdescription>
<para>Computes the surface neighbor coordinates with respect to the points that are vertices of the Delaunay triangulation <computeroutput>dt</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The type <computeroutput>Dt</computeroutput> must be equivalent to <computeroutput>Delaunay_triangulation_3&lt;Gt, Tds&gt;</computeroutput>. The optional parameter <computeroutput>start</computeroutput> is used for the used as a starting place for the search of the conflict zone. It may be the result of the call <computeroutput>dt.locate(p)</computeroutput>. This function instantiates the template parameter <computeroutput>ITraits</computeroutput> to be <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;Dt::Geom_traits&gt;</computeroutput>.</para>
<para>This function allows to filter some potential neighbors of the query point <computeroutput>p</computeroutput> from <formula id="2">$ \mathcal{P}$</formula> via its three-dimensional Delaunay triangulation. All surface neighbors of <computeroutput>p</computeroutput> are necessarily neighbors in the Delaunay triangulation of <formula id="3">$ \mathcal{P}
\cup \{p\}$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="157" column="1" declfile="CGAL/surface_neighbors_3.h" declline="157" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgInterpolationSurfaceNeighbors3_1gad7e91370dfb898f80196c9f3453b655a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Dt</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class ITraits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::surface_neighbors_3</definition>
        <argsstring>(const Dt &amp;dt, const typename ITraits::Point_2 &amp;p, OutputIterator out, const ITraits &amp;traits, typename Dt::Cell_handle start=typename Dt::Cell_handle())</argsstring>
        <name>surface_neighbors_3</name>
        <qualifiedname>CGAL::surface_neighbors_3</qualifiedname>
        <param>
          <type>const Dt &amp;</type>
          <declname>dt</declname>
        </param>
        <param>
          <type>const typename ITraits::Point_2 &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const ITraits &amp;</type>
          <declname>traits</declname>
        </param>
        <param>
          <type>typename Dt::Cell_handle</type>
          <declname>start</declname>
          <defval>typename Dt::Cell_handle()</defval>
        </param>
        <briefdescription>
<para>Same as above only that the parameter <computeroutput>traits</computeroutput> instantiates the geometric traits class. </para>
        </briefdescription>
        <detaileddescription>
<para>Its type <computeroutput>ITraits</computeroutput> must be equivalent to <computeroutput><ref refid="classCGAL_1_1Voronoi__intersection__2__traits__3" kindref="compound">Voronoi_intersection_2_traits_3</ref>&lt;K&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/surface_neighbors_3.h" line="169" column="16" declfile="CGAL/surface_neighbors_3.h" declline="169" declcolumn="16"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="CGAL/interpolation_functions.h" line="2" column="1"/>
  </compounddef>
</doxygen>
