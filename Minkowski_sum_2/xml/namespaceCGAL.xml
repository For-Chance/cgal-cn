<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="classCGAL_1_1Greene__convex__decomposition__2" prot="public">CGAL::Greene_convex_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Hertel__Mehlhorn__convex__decomposition__2" prot="public">CGAL::Hertel_Mehlhorn_convex_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Optimal__convex__decomposition__2" prot="public">CGAL::Optimal_convex_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Polygon__nop__decomposition__2" prot="public">CGAL::Polygon_nop_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Polygon__triangulation__decomposition__2" prot="public">CGAL::Polygon_triangulation_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Polygon__vertical__decomposition__2" prot="public">CGAL::Polygon_vertical_decomposition_2</innerclass>
    <innerclass refid="classCGAL_1_1Small__side__angle__bisector__decomposition__2" prot="public">CGAL::Small_side_angle_bisector_decomposition_2</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga80e273611a4e3568a0208d5fb1551669" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Kernel</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::approximated_inset_2</definition>
        <argsstring>(const Polygon_2&lt; Kernel, Container &gt; &amp;pgn, const typename Kernel::FT &amp;r, const double &amp;eps, OutputIterator oi)</argsstring>
        <name>approximated_inset_2</name>
        <qualifiedname>CGAL::approximated_inset_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>pgn</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>eps</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>Provides a guaranteed approximation of the inset, or inner offset, of the given polygon <computeroutput>P</computeroutput> by a given radius <computeroutput>r</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>Namely, the function computes the set of points inside the polygon whose distance from <formula id="0">$ P$</formula>&apos;s boundary is at least <formula id="1">$ r$</formula>: <formula id="2">$ \{ p \in P \;|\; {\rm dist}(p, \partial P) \geq r \}$</formula>, with the approximation error bounded by <computeroutput>eps</computeroutput>. Note that as the input polygon may not be convex, its inset may comprise several disconnected components. The result is therefore represented as a sequence of generalized polygons, whose edges are either line segments or circular arcs. The output sequence is returned via the output iterator <computeroutput>oi</computeroutput>, whose value-type must be <computeroutput>Gps_circle_segment_traits_2&lt;Kernel&gt;::Polygon_2</computeroutput>. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/approximated_offset_2.h" line="22" column="1" declfile="CGAL/approximated_offset_2.h" declline="22" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gacf5b99f4a2d42658866f0fda2e26729b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Kernel</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2</type>
        <definition>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2 CGAL::approximated_offset_2</definition>
        <argsstring>(const Polygon_2&lt; Kernel, Container &gt; &amp;P, const typename Kernel::FT &amp;r, const double &amp;eps)</argsstring>
        <name>approximated_offset_2</name>
        <qualifiedname>CGAL::approximated_offset_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>eps</declname>
        </param>
        <briefdescription>
<para>Provides a guaranteed approximation of the offset of the given polygon <computeroutput>P</computeroutput> by a given radius <computeroutput>r</computeroutput> - namely, the function computes the Minkowski sum <formula id="3">$ P \oplus B_r$</formula>, where <formula id="4">$ B_r$</formula> is a disc of radius <computeroutput>r</computeroutput> centered at the origin. </para>
        </briefdescription>
        <detaileddescription>
<para>The function actually outputs a set <formula id="5">$ S$</formula> that contains the Minkowski sum, such that the approximation error is bounded by <computeroutput>eps</computeroutput>. Note that as the input polygon may not be convex, its offset may not be a simple polygon. The result is therefore represented as a polygon with holes, whose edges are either line segments or circular arcs. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/approximated_offset_2.h" line="47" column="1" declfile="CGAL/approximated_offset_2.h" declline="47" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gaa243d6a80e605898a4ab4ca8d9ca46a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Kernel</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2</type>
        <definition>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2 CGAL::approximated_offset_2</definition>
        <argsstring>(const Polygon_with_holes_2&lt; Kernel, Container &gt; &amp;wh, const typename Kernel::FT &amp;r, const double &amp;eps)</argsstring>
        <name>approximated_offset_2</name>
        <qualifiedname>CGAL::approximated_offset_2</qualifiedname>
        <param>
          <type>const Polygon_with_holes_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>wh</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>eps</declname>
        </param>
        <briefdescription>
<para>Provides a guaranteed approximation of offset the given polygon with holes <computeroutput>pwh</computeroutput> by a given radius <computeroutput>r</computeroutput>, such that the approximation error is bounded by <computeroutput>eps</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>It does so by offsetting outer boundary of <computeroutput>pwh</computeroutput> and insetting its holes. The result is represented as a generalized polygon with holes, such that the edges of the polygon correspond to line segment and circular arcs. <simplesect kind="pre"><para><computeroutput>pwh</computeroutput> is <emphasis>not</emphasis> unbounded (it has a valid outer boundary). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/approximated_offset_2.h" line="64" column="1" declfile="CGAL/approximated_offset_2.h" declline="64" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga4f853c197d83c40960d236482034ad5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Kernel</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class DecompositionStrategy</type>
          </param>
        </templateparamlist>
        <type>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2</type>
        <definition>Gps_circle_segment_traits_2&lt; Kernel &gt;::Polygon_with_holes_2 CGAL::approximated_offset_2</definition>
        <argsstring>(const Polygon_2&lt; Kernel, Container &gt; &amp;P, const typename Kernel::FT &amp;r, const double &amp;eps, const DecompositionStrategy &amp;decomp)</argsstring>
        <name>approximated_offset_2</name>
        <qualifiedname>CGAL::approximated_offset_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const typename Kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>eps</declname>
        </param>
        <param>
          <type>const DecompositionStrategy &amp;</type>
          <declname>decomp</declname>
        </param>
        <briefdescription>
<para>Provides a guaranteed approximation of the offset of the given polygon <computeroutput>P</computeroutput> by a radius <computeroutput>r</computeroutput>, as described above. </para>
        </briefdescription>
        <detaileddescription>
<para>If the input polygon <computeroutput>P</computeroutput> is not convex, the function decomposes it into convex sub-polygons <formula id="6">$ P_1, \ldots, P_k$</formula> and computes the union of the sub-offsets (namely <formula id="7">$ \bigcup_{i}{(P_i \oplus B_r)}$</formula>). The decomposition is performed using the given decomposition strategy <computeroutput>decomp</computeroutput>, which must be an instance of a class that models the concept <computeroutput>PolygonConvexDecomposition</computeroutput>. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/approximated_offset_2.h" line="84" column="1" declfile="CGAL/approximated_offset_2.h" declline="84" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gadc61bdbdc41e092737140cc96f63e4c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_2</definition>
        <argsstring>(const PolygonType1&lt; Kernel, Container &gt; &amp;P, const PolygonType2&lt; Kernel, Container &gt; &amp;Q)</argsstring>
        <name>minkowski_sum_2</name>
        <qualifiedname>CGAL::minkowski_sum_2</qualifiedname>
        <param>
          <type>const PolygonType1&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const PolygonType2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of two given polygons (which may have holes). </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>PolygonType1</computeroutput> and <computeroutput>PolygonType2</computeroutput> can be any combination of:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Polygon_2</computeroutput></para>
</listitem><listitem><para><computeroutput>Polygon_with_holes_2</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>This method defaults to the reduced convolution method, see below.</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgMinkowskiSum2Ref_1ga576d3fd3dc2f138790bc97cbd0cefaa5" kindref="member">CGAL::minkowski_sum_by_reduced_convolution_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgMinkowskiSum2Ref_1gacc6b6f3b4de3d05e37a7dd516902fcdb" kindref="member">CGAL::minkowski_sum_by_full_convolution_2()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="19" column="1" declfile="CGAL/minkowski_sum_2.h" declline="19" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga576d3fd3dc2f138790bc97cbd0cefaa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_by_reduced_convolution_2</definition>
        <argsstring>(const PolygonType1&lt; Kernel, Container &gt; &amp;P, const PolygonType2&lt; Kernel, Container &gt; &amp;Q)</argsstring>
        <name>minkowski_sum_by_reduced_convolution_2</name>
        <qualifiedname>CGAL::minkowski_sum_by_reduced_convolution_2</qualifiedname>
        <param>
          <type>const PolygonType1&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const PolygonType2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of the two given polygons. </para>
        </briefdescription>
        <detaileddescription>
<para>The function computes the reduced convolution <ref refid="citelist_1CITEREF_cgal:bl-frmsurc-11" kindref="member">[3]</ref> of the two polygons and extracts those loops of the convolution that are part of the Minkowsi sum. This method works very efficiently, regardless of whether <computeroutput>P</computeroutput> and <computeroutput>Q</computeroutput> are convex or non-convex. In general, it is more efficient than the full convolution method, except for degenerate cases where the output polygon has many holes.</para>
<para><computeroutput>PolygonType1</computeroutput> and <computeroutput>PolygonType2</computeroutput> can be any combination of:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Polygon_2</computeroutput></para>
</listitem><listitem><para><computeroutput>Polygon_with_holes_2</computeroutput> </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="41" column="1" declfile="CGAL/minkowski_sum_2.h" declline="41" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gacc6b6f3b4de3d05e37a7dd516902fcdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_by_full_convolution_2</definition>
        <argsstring>(const Polygon_2&lt; Kernel, Container &gt; &amp;P, const Polygon_2&lt; Kernel, Container &gt; &amp;Q)</argsstring>
        <name>minkowski_sum_by_full_convolution_2</name>
        <qualifiedname>CGAL::minkowski_sum_by_full_convolution_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const Polygon_2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of the two given polygons. </para>
        </briefdescription>
        <detaileddescription>
<para>The function computes the (full) convolution cycles of the two polygons and extract the regions having positive winding number with respect to these cycles. This method work very efficiently, regardless of whether <computeroutput>P</computeroutput> and <computeroutput>Q</computeroutput> are convex or non-convex.</para>
<para><computeroutput>PolygonType1</computeroutput> and <computeroutput>PolygonType2</computeroutput> can be any combination of:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Polygon_2</computeroutput></para>
</listitem><listitem><para><computeroutput>Polygon_with_holes_2</computeroutput> </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="60" column="1" declfile="CGAL/minkowski_sum_2.h" declline="60" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gac067b3aba5c2529786291e55986015f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
          <param>
            <type>typename PolygonConvexDecompositionP_2_</type>
          </param>
          <param>
            <type>typename PolygonConvexDecompositionQ_2_</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_2</definition>
        <argsstring>(const PolygonType1&lt; Kernel, Container &gt; &amp;P, const PolygonType2&lt; Kernel, Container &gt; &amp;Q, const PolygonConvexDecompositionP_2_ &amp;decomp_P, const PolygonConvexDecompositionQ_2_ &amp;decomp_Q, const Gps_segment_traits_2 &amp;traits=Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;())</argsstring>
        <name>minkowski_sum_2</name>
        <qualifiedname>CGAL::minkowski_sum_2</qualifiedname>
        <param>
          <type>const PolygonType1&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const PolygonType2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <param>
          <type>const PolygonConvexDecompositionP_2_ &amp;</type>
          <declname>decomp_P</declname>
        </param>
        <param>
          <type>const PolygonConvexDecompositionQ_2_ &amp;</type>
          <declname>decomp_Q</declname>
        </param>
        <param>
          <type>const Gps_segment_traits_2 &amp;</type>
          <declname>traits</declname>
          <defval>Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;()</defval>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of the two given polygons. </para>
        </briefdescription>
        <detaileddescription>
<para>The function decomposes the summand <computeroutput>P</computeroutput> into convex sub-polygons <formula id="6">$ P_1, \ldots, P_k$</formula> using the given decomposition method <computeroutput>decomp_P</computeroutput>. If the summand <computeroutput>P</computeroutput> is of type <computeroutput>Polygon_2</computeroutput>, then <computeroutput>decomp_P</computeroutput> must be an instance of a class template that models the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. If <computeroutput>P</computeroutput> is of type <computeroutput>Polygon_with_holes_2</computeroutput>, then <computeroutput>decomp_P</computeroutput> must be an instance of a class template that models the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>. Similarly, the function decomposes the summand <computeroutput>Q</computeroutput> into convex sub-polygons <formula id="9">$ Q_1, \ldots, Q_k$</formula> using the given decomposition method <computeroutput>decomp_Q</computeroutput>. If the summand <computeroutput>Q</computeroutput> is of type <computeroutput>Polygon_2</computeroutput>, then <computeroutput>decomp_Q</computeroutput> must be an instance of a class template that models the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. If <computeroutput>Q</computeroutput> is of type <computeroutput>Polygon_with_holes_2</computeroutput>, then <computeroutput>decomp_Q</computeroutput> must be an instance of a class template that models the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>. Then, the function computes the union of pairwise sub-sums (namely <formula id="10">$ \bigcup_{i,j}{(P_i \oplus Q_j)}$</formula>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="88" column="1" declfile="CGAL/minkowski_sum_2.h" declline="88" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga5553f3c656da0479fb7b8890c166d23b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
          <param>
            <type>typename PolygonConvexDecomposition_2_</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_2</definition>
        <argsstring>(const PolygonType1&lt; Kernel, Container &gt; &amp;P, const PolygonType2&lt; Kernel, Container &gt; &amp;Q, const PolygonConvexDecomposition_2_ &amp;decomp, const Gps_segment_traits_2 &amp;traits=Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;())</argsstring>
        <name>minkowski_sum_2</name>
        <qualifiedname>CGAL::minkowski_sum_2</qualifiedname>
        <param>
          <type>const PolygonType1&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const PolygonType2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <param>
          <type>const PolygonConvexDecomposition_2_ &amp;</type>
          <declname>decomp</declname>
        </param>
        <param>
          <type>const Gps_segment_traits_2 &amp;</type>
          <declname>traits</declname>
          <defval>Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;()</defval>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of the two given polygons. </para>
        </briefdescription>
        <detaileddescription>
<para>The function decomposes the summands <computeroutput>P</computeroutput> and <computeroutput>Q</computeroutput> into convex sub-polygons <formula id="6">$ P_1, \ldots, P_k$</formula> and <formula id="11">$ Q_1, \ldots, Q_{\ell}$</formula>, respectively. Then, it computes the union of pairwise sub-sums (namely <formula id="10">$ \bigcup_{i,j}{(P_i \oplus Q_j)}$</formula>). The decomposition is performed using the given decomposition method <computeroutput>decomp</computeroutput>. If both summands <formula id="8">$ P \oplus Q$</formula> are of type <computeroutput>Polygon_2</computeroutput>, then <computeroutput>decomp</computeroutput> must be instance of a class template that models the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. If both summands are of type <computeroutput>Polygon_with_holes_2</computeroutput>, then <computeroutput>decomp</computeroutput> must be a model of the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="111" column="1" declfile="CGAL/minkowski_sum_2.h" declline="111" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gab7af8172c52c759f611fdb52cf6c94ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Kernel</type>
          </param>
          <param>
            <type>typename Container</type>
          </param>
          <param>
            <type>typename PolygonNoHolesConvexDecomposition_2_</type>
          </param>
          <param>
            <type>typename PolygonWithHolesConvexDecomposition_2_</type>
          </param>
        </templateparamlist>
        <type>Polygon_with_holes_2&lt; Kernel, Container &gt;</type>
        <definition>Polygon_with_holes_2&lt; Kernel, Container &gt; CGAL::minkowski_sum_by_decomposition_2</definition>
        <argsstring>(const PolygonType1&lt; Kernel, Container &gt; &amp;P, const PolygonType2&lt; Kernel, Container &gt; &amp;Q, const PolygonNoHolesConvexDecomposition_2_ &amp;no_holes_decomp, const PolygonWithHolesConvexDecomposition_2_ &amp;with_holes_decomp, const Gps_segment_traits_2 &amp;traits=Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;())</argsstring>
        <name>minkowski_sum_by_decomposition_2</name>
        <qualifiedname>CGAL::minkowski_sum_by_decomposition_2</qualifiedname>
        <param>
          <type>const PolygonType1&lt; Kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const PolygonType2&lt; Kernel, Container &gt; &amp;</type>
          <declname>Q</declname>
        </param>
        <param>
          <type>const PolygonNoHolesConvexDecomposition_2_ &amp;</type>
          <declname>no_holes_decomp</declname>
        </param>
        <param>
          <type>const PolygonWithHolesConvexDecomposition_2_ &amp;</type>
          <declname>with_holes_decomp</declname>
        </param>
        <param>
          <type>const Gps_segment_traits_2 &amp;</type>
          <declname>traits</declname>
          <defval>Gps_segment_traits_2&lt; Kernel, Container, Arr_segment_traits &gt;()</defval>
        </param>
        <briefdescription>
<para>Computes the Minkowski sum <formula id="8">$ P \oplus Q$</formula> of the two given polygons using the decomposition strategy. </para>
        </briefdescription>
        <detaileddescription>
<para>It decomposes the summands <computeroutput>P</computeroutput> and <computeroutput>Q</computeroutput> into convex sub-polygons <formula id="6">$ P_1, \ldots, P_k$</formula> and <formula id="11">$ Q_1, \ldots, Q_{\ell}$</formula>, respectively. Then, it computes the union of pairwise sub-sums (namely <formula id="10">$ \bigcup_{i,j}{(P_i \oplus Q_j)}$</formula>).</para>
<para>If the summand <computeroutput>P</computeroutput> is of type <computeroutput>Polygon_with_holes_2</computeroutput>, then the function first applies the hole filteration on <computeroutput>P</computeroutput>. If the summand <computeroutput>P</computeroutput> remains a polygon with holes, then the function decomposes the summand <computeroutput>P</computeroutput> using the given decomposition method <computeroutput>with_holes_decomp</computeroutput>. If, however, <computeroutput>P</computeroutput> turns into a polygon without holes, then the function decomposes the summand <computeroutput>P</computeroutput> using the given decomposition method <computeroutput>no_holes_decomp</computeroutput>, unless the result is a convex polygon, in which case the nop strategy is applied; namely, an instance of the class template <computeroutput><ref refid="classCGAL_1_1Polygon__nop__decomposition__2" kindref="compound">Polygon_nop_decomposition_2</ref></computeroutput> is used. If <computeroutput>P</computeroutput> is a polygon without holes to start with, then only convexity is checked (checking whether the result is convex inccurs a small overhead though). Then depending on the result either <computeroutput>no_holes_decomp</computeroutput> or the nop strategy is applied. Similarly, if the summand <computeroutput>Q</computeroutput> is of type <computeroutput>Polygon_with_holes_2</computeroutput>, then the function first applies the hole filteration on <computeroutput>Q</computeroutput>. If the summand <computeroutput>Q</computeroutput> remains a polygon with holes, then the function decomposes the summand <computeroutput>Q</computeroutput> using the given decomposition method <computeroutput>with_holes_decomp</computeroutput>. If, however, <computeroutput>Q</computeroutput> turns into a polygon without holes, then the function decomposes the summand <computeroutput>Q</computeroutput> using the given decomposition method <computeroutput>no_holes_decomp</computeroutput>, unless the result is a convex polygon, in which case the nop strategy is applied. If <computeroutput>Q</computeroutput> is a polygon without holes to start with, then only convexity is checked and the decomposition strategy is chosen accordingly.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PolygonNoHolesConvexDecomposition_2_</parametername>
</parameternamelist>
<parameterdescription>
<para>a model of the concept <computeroutput><ref refid="classPolygonConvexDecomposition__2" kindref="compound">PolygonConvexDecomposition_2</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PolygonWithHolesConvexDecomposition_2_</parametername>
</parameternamelist>
<parameterdescription>
<para>a model of the concept <computeroutput><ref refid="classPolygonWithHolesConvexDecomposition__2" kindref="compound">PolygonWithHolesConvexDecomposition_2</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/minkowski_sum_2.h" line="155" column="1" declfile="CGAL/minkowski_sum_2.h" declline="155" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga6ab5808d9bc7ba5e958b8b5bcb9e9824" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ConicTraits</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::inset_polygon_2</definition>
        <argsstring>(const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;P, const typename ConicTraits::Rat_kernel::FT &amp;r, const ConicTraits &amp;traits, OutputIterator oi)</argsstring>
        <name>inset_polygon_2</name>
        <qualifiedname>CGAL::inset_polygon_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const typename ConicTraits::Rat_kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const ConicTraits &amp;</type>
          <declname>traits</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>oi</declname>
        </param>
        <briefdescription>
<para>Computes the inset, or inner offset, of the given polygon <computeroutput>P</computeroutput> by a given radius <computeroutput>r</computeroutput> - namely, the function computes the set of points inside the polygon whose distance from <formula id="0">$ P$</formula>&apos;s boundary is at least <formula id="1">$ r$</formula>: <formula id="2">$ \{ p \in P \;|\; {\rm dist}(p, \partial P) \geq r \}$</formula>. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that as the input polygon may not be convex, its inset may comprise several disconnected components. The result is therefore represented as a sequence of generalized polygons, such that the edges of each polygon correspond to line segments and circular arcs, both are special types of conic arcs, as represented by the <computeroutput>traits</computeroutput> class. The output sequence is returned via the output iterator <computeroutput>oi</computeroutput>, whose value-type must be <computeroutput>Gps_traits_2::Polygon_2</computeroutput>. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/offset_polygon_2.h" line="20" column="16" declfile="CGAL/offset_polygon_2.h" declline="20" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gaac8e82c4a600a12f11f65e9bcf7fbd31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ConicTraits</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2</type>
        <definition>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2 CGAL::offset_polygon_2</definition>
        <argsstring>(const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;P, const typename ConicTraits::Rat_kernel::FT &amp;r, const ConicTraits &amp;traits)</argsstring>
        <name>offset_polygon_2</name>
        <qualifiedname>CGAL::offset_polygon_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const typename ConicTraits::Rat_kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const ConicTraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Computes the offset of the given polygon <computeroutput>P</computeroutput> by a given radius <computeroutput>r</computeroutput> - namely, the function computes the Minkowski sum <formula id="3">$ P \oplus B_r$</formula>, where <formula id="4">$ B_r$</formula> is a disc of radius <computeroutput>r</computeroutput> centered at the origin. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that as the input polygon may not be convex, its offset may not be a simple polygon. The result is therefore represented as a generalized polygon with holes, such that the edges of the polygon correspond to line segments and circular arcs, both are special types of conic arcs, as represented by the <computeroutput>traits</computeroutput> class. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/offset_polygon_2.h" line="47" column="1" declfile="CGAL/offset_polygon_2.h" declline="47" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1ga6c9a467989556ad495607bb11f9f50e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ConicTraits</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2</type>
        <definition>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2 CGAL::offset_polygon_2</definition>
        <argsstring>(const Polygon_with_holes_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;pwh, const typename ConicTraits::Rat_kernel::FT &amp;r, const ConicTraits &amp;traits)</argsstring>
        <name>offset_polygon_2</name>
        <qualifiedname>CGAL::offset_polygon_2</qualifiedname>
        <param>
          <type>const Polygon_with_holes_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;</type>
          <declname>pwh</declname>
        </param>
        <param>
          <type>const typename ConicTraits::Rat_kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const ConicTraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Computes the offset of the given polygon with holes <computeroutput>pwh</computeroutput> by a given radius <computeroutput>r</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>It does so by offsetting outer boundary of <computeroutput>pwh</computeroutput> and insetting its holes. The result is represented as a generalized polygon with holes, such that the edges of the polygon correspond to line segments and circular arcs, both are special types of conic arcs, as represented by the <computeroutput>traits</computeroutput> class. <simplesect kind="pre"><para><computeroutput>pwh</computeroutput> is <emphasis>not</emphasis> unbounded (it has a valid outer boundary). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/offset_polygon_2.h" line="66" column="1" declfile="CGAL/offset_polygon_2.h" declline="66" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMinkowskiSum2Ref_1gabbe0dbf3c0bc0d5045abe53ad1ea191d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ConicTraits</type>
          </param>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class DecompositionStrategy</type>
          </param>
        </templateparamlist>
        <type>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2</type>
        <definition>Gps_traits_2&lt; ConicTraits &gt;::Polygon_with_holes_2 CGAL::offset_polygon_2</definition>
        <argsstring>(const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;P, const typename ConicTraits::Rat_kernel::FT &amp;r, const DecompositionStrategy &amp;decomp, const ConicTraits &amp;traits)</argsstring>
        <name>offset_polygon_2</name>
        <qualifiedname>CGAL::offset_polygon_2</qualifiedname>
        <param>
          <type>const Polygon_2&lt; typename ConicTraits::Rat_kernel, Container &gt; &amp;</type>
          <declname>P</declname>
        </param>
        <param>
          <type>const typename ConicTraits::Rat_kernel::FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const DecompositionStrategy &amp;</type>
          <declname>decomp</declname>
        </param>
        <param>
          <type>const ConicTraits &amp;</type>
          <declname>traits</declname>
        </param>
        <briefdescription>
<para>Computes the exact representation of the offset of the given polygon <computeroutput>P</computeroutput> by a radius <computeroutput>r</computeroutput>, as described above. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>P</computeroutput> is not convex, the function decomposes it into convex sub-polygons <formula id="6">$ P_1, \ldots, P_k$</formula> and computes the union of sub-offsets (namely <formula id="7">$ \bigcup_{i}{(P_i \oplus B_r)}$</formula>). The decomposition is performed using the given decomposition strategy <computeroutput>decomp</computeroutput>, which must be an instance of a class that models the concept <computeroutput>PolygonConvexDecomposition</computeroutput>. <simplesect kind="pre"><para><computeroutput>P</computeroutput> is a simple polygon. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/offset_polygon_2.h" line="88" column="1" declfile="CGAL/offset_polygon_2.h" declline="88" declcolumn="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="CGAL/approximated_offset_2.h" line="1" column="1"/>
  </compounddef>
</doxygen>
