<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="group__STLAlgos" kind="group">
    <compoundname>STLAlgos</compoundname>
    <title>Generic Algorithms</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__STLAlgos_1ga2f3822e4faf8eca315ef0f49c373d05a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>, <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref> &gt;</type>
        <definition>std::pair&lt; ForwardIterator, ForwardIterator &gt; CGAL::min_max_element</definition>
        <argsstring>(ForwardIterator first, ForwardIterator last)</argsstring>
        <name>min_max_element</name>
        <qualifiedname>CGAL::min_max_element</qualifiedname>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Computes the minimal and the maximal element of a range. </para>
        </briefdescription>
        <detaileddescription>
<para>It is modeled after the STL functions <ulink url="https://en.cppreference.com/w/cpp/algorithm/min_element"><computeroutput>std::min_element</computeroutput></ulink> and <ulink url="https://en.cppreference.com/w/cpp/algorithm/max_element"><computeroutput>std::max_element</computeroutput></ulink>. The advantage of <computeroutput><ref refid="group__STLAlgos_1ga2f3822e4faf8eca315ef0f49c373d05a" kindref="member">min_max_element()</ref></computeroutput> compared to calling both STL functions is that one only iterates once over the sequence. This is more efficient especially for large and/or complex sequences.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para>The following example program computes the minimal and maximal element of the sequence <computeroutput>(3,\,6,\,5)</computeroutput>. Hence the output is <computeroutput>min = 3, max = 6</computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="STL_Extension_2min_max_element_example_8cpp-example" kindref="compound">STL_Extension/min_max_element_example.cpp</ref> <programlisting filename="STL_Extension/min_max_element_example.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">std::vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">std::pair;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">std::cout;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="group__STLAlgos_1ga2f3822e4faf8eca315ef0f49c373d05a" kindref="member">CGAL::min_max_element</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;<sp/>int<sp/>&gt;<sp/>v;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v.push_back(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v.push_back(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>v.push_back(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;<sp/>int<sp/>&gt;::iterator<sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pair&lt;<sp/>iterator,<sp/>iterator<sp/>&gt;<sp/>p<sp/>=<sp/><ref refid="group__STLAlgos_1ga2f3822e4faf8eca315ef0f49c373d05a" kindref="member">min_max_element</ref>(v.begin(),<sp/>v.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;min<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*p.first<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>max<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*p.second<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="return"><para>a pair of iterators where the first component refers to the minimal and the second component refers to the maximal element in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>). The ordering is defined by <computeroutput>operator&lt;</computeroutput> on the value type of <computeroutput><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/algorithm.h" line="34" column="2" declfile="CGAL/algorithm.h" declline="34" declcolumn="2"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1gaf404b198e27ef4018bc5185c9e7da751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          </param>
          <param>
            <type>class CompareMin</type>
          </param>
          <param>
            <type>class CompareMax</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref>, <ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref> &gt;</type>
        <definition>std::pair&lt; ForwardIterator, ForwardIterator &gt; CGAL::min_max_element</definition>
        <argsstring>(ForwardIterator first, ForwardIterator last, CompareMin comp_min, CompareMax comp_max)</argsstring>
        <name>min_max_element</name>
        <qualifiedname>CGAL::min_max_element</qualifiedname>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type>CompareMin</type>
          <declname>comp_min</declname>
        </param>
        <param>
          <type>CompareMax</type>
          <declname>comp_max</declname>
        </param>
        <briefdescription>
<para>Computes the minimal and the maximal element of a range. </para>
        </briefdescription>
        <detaileddescription>
<para>It is modeled after the STL functions <ulink url="https://en.cppreference.com/w/cpp/algorithm/min_element"><computeroutput>std::min_element</computeroutput></ulink> and <ulink url="https://en.cppreference.com/w/cpp/algorithm/max_element"><computeroutput>std::max_element</computeroutput></ulink>. The advantage of <computeroutput><ref refid="group__STLAlgos_1ga2f3822e4faf8eca315ef0f49c373d05a" kindref="member">min_max_element()</ref></computeroutput> compared to calling both STL functions is that one only iterates once over the sequence. This is more efficient especially for large and/or complex sequences.</para>
<para><simplesect kind="return"><para>a pair of iterators where the first component refers to the minimal and the second component refers to the maximal element in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>).</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>CompareMin</parametername>
</parameternamelist>
<parameterdescription>
<para>is an adaptable binary function object: <computeroutput>VT</computeroutput> <formula id="0">$ \times$</formula> <computeroutput>VT</computeroutput> <formula id="1">$ \rightarrow$</formula> <computeroutput>bool</computeroutput> where <computeroutput>VT</computeroutput> is the value type of <computeroutput><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></computeroutput>.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CompareMax</parametername>
</parameternamelist>
<parameterdescription>
<para>is an adaptable binary function object: <computeroutput>VT</computeroutput> <formula id="0">$ \times$</formula> <computeroutput>VT</computeroutput> <formula id="1">$ \rightarrow$</formula> <computeroutput>bool</computeroutput> where <computeroutput>VT</computeroutput> is the value type of <computeroutput><ref refid="classForwardIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">ForwardIterator</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/algorithm.h" line="65" column="1" declfile="CGAL/algorithm.h" declline="65" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1ga03da480625f380d4d06ea64de211add4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          </param>
          <param>
            <type>class RandomGenerator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::cpp98::random_shuffle</definition>
        <argsstring>(RandomAccessIterator begin, RandomAccessIterator end, RandomGenerator &amp;random)</argsstring>
        <name>random_shuffle</name>
        <qualifiedname>CGAL::cpp98::random_shuffle</qualifiedname>
        <param>
          <type><ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          <declname>begin</declname>
        </param>
        <param>
          <type><ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          <declname>end</declname>
        </param>
        <param>
          <type>RandomGenerator &amp;</type>
          <declname>random</declname>
        </param>
        <briefdescription>
<para>Replacement for <ulink url="https://en.cppreference.com/w/cpp/algorithm/random_shuffle"><computeroutput>std::random_shuffle</computeroutput></ulink> which was deprecated in C++14, and removed by C++17. </para>
        </briefdescription>
        <detaileddescription>
<para>In the STL it was replaced by <computeroutput>std::shuffle</computeroutput>.</para>
<para><simplesect kind="note"><para>The implementation in CGAL produces the same order on all platforms. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/algorithm.h" line="88" column="1" declfile="CGAL/algorithm.h" declline="88" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__STLAlgos_1gae51e106684360ea3c9ce4eaa2ba68218" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::cpp98::random_shuffle</definition>
        <argsstring>(RandomAccessIterator begin, RandomAccessIterator end)</argsstring>
        <name>random_shuffle</name>
        <qualifiedname>CGAL::cpp98::random_shuffle</qualifiedname>
        <param>
          <type><ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          <declname>begin</declname>
        </param>
        <param>
          <type><ref refid="classRandomAccessIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">RandomAccessIterator</ref></type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Replacement for <ulink url="https://en.cppreference.com/w/cpp/algorithm/random_shuffle"><computeroutput>std::random_shuffle</computeroutput></ulink> which was deprecated in C++14, and removed by C++17. </para>
        </briefdescription>
        <detaileddescription>
<para>In the STL it was replaced by <computeroutput>std::shuffle</computeroutput>.</para>
<para><simplesect kind="note"><para>The implementation in CGAL produces the same order on all platforms. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/algorithm.h" line="101" column="1" declfile="CGAL/algorithm.h" declline="101" declcolumn="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
