<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classCGAL_1_1Multiset" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Multiset</compoundname>
    <includes local="no">CGAL/Multiset.h</includes>
    <templateparamlist>
      <param>
        <type>typename Type</type>
      </param>
      <param>
        <type>typename Compare</type>
      </param>
      <param>
        <type>typename Allocator</type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <description><para>In compliance with STL, the types <computeroutput>value_type</computeroutput> and <computeroutput>key_type</computeroutput> (both equivalent to <computeroutput>Type</computeroutput>), <computeroutput>reference</computeroutput> and <computeroutput>const_reference</computeroutput> (reference to a value-type), <computeroutput>key_compare</computeroutput> and <computeroutput>value_compare</computeroutput> (both equivalent to <computeroutput>Compare</computeroutput>), <computeroutput>size_type</computeroutput> and <computeroutput>difference_type</computeroutput> are defined as well. </para>
</description>
      <memberdef kind="typedef" id="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Multiset&lt; Type, Compare, Allocator &gt;::iterator</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <qualifiedname>CGAL::Multiset::iterator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="126" column="26" bodyfile="CGAL/Multiset.h" bodystart="126" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Multiset_1a7e20d7e960306e8b3c25c9174e4a4075" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Multiset&lt; Type, Compare, Allocator &gt;::const_iterator</definition>
        <argsstring></argsstring>
        <name>const_iterator</name>
        <qualifiedname>CGAL::Multiset::const_iterator</qualifiedname>
        <briefdescription>
<para>bi-directional iterators for the elements stored in the set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="131" column="26" bodyfile="CGAL/Multiset.h" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Multiset_1a5b73fc6a125e01bd662d59bd2b7965c6" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Multiset&lt; Type, Compare, Allocator &gt;::reverse_iterator</definition>
        <argsstring></argsstring>
        <name>reverse_iterator</name>
        <qualifiedname>CGAL::Multiset::reverse_iterator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="137" column="26" bodyfile="CGAL/Multiset.h" bodystart="137" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Multiset_1a2c52a692f7283555e88ad75c2681a7b0" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Multiset&lt; Type, Compare, Allocator &gt;::const_reverse_iterator</definition>
        <argsstring></argsstring>
        <name>const_reverse_iterator</name>
        <qualifiedname>CGAL::Multiset::const_reverse_iterator</qualifiedname>
        <briefdescription>
<para>reverse bi-directional iterators for the elements stored in the set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="142" column="26" bodyfile="CGAL/Multiset.h" bodystart="142" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ac279545948dac161fb8a16b0dbc7ac2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Multiset&lt; Type, Compare, Allocator &gt;::Multiset</definition>
        <argsstring>()</argsstring>
        <name>Multiset</name>
        <qualifiedname>CGAL::Multiset::Multiset</qualifiedname>
        <briefdescription>
<para>creates an an empty set <computeroutput>s</computeroutput> that uses a default comparison functor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="142" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a57d2a5a483e7df5231703916a2a0bfee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Multiset&lt; Type, Compare, Allocator &gt;::Multiset</definition>
        <argsstring>(const Compare &amp;comp)</argsstring>
        <name>Multiset</name>
        <qualifiedname>CGAL::Multiset::Multiset</qualifiedname>
        <param>
          <type>const Compare &amp;</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>creates an an empty set <computeroutput>s</computeroutput> that uses the given comparison functor <computeroutput>comp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="142" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a75bd014fdd6f115cd60a3290e3165af7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Multiset&lt; Type, Compare, Allocator &gt;::Multiset</definition>
        <argsstring>(InputIterator first, InputIterator last, const Compare &amp;comp=Compare())</argsstring>
        <name>Multiset</name>
        <qualifiedname>CGAL::Multiset::Multiset</qualifiedname>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <param>
          <type>const Compare &amp;</type>
          <declname>comp</declname>
          <defval>Compare()</defval>
        </param>
        <briefdescription>
<para>creates a set <computeroutput>s</computeroutput> containing all elements in the range <computeroutput>[first, last)</computeroutput>, that uses the comparison functor <computeroutput>comp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="142" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1afc7a2011be4ed7ad5122c44a83939722" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Multiset&lt; Type, Compare, Allocator &gt;::Multiset</definition>
        <argsstring>(const Multiset&lt; Type, Compare, Allocator &gt; &amp;other)</argsstring>
        <name>Multiset</name>
        <qualifiedname>CGAL::Multiset::Multiset</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>copy constructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="142" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a677412d4304005cefedb3f7547c878e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
        <definition>const Multiset&lt; Type, Compare, Allocator &gt; &amp; CGAL::Multiset&lt; Type, Compare, Allocator &gt;::operator=</definition>
        <argsstring>(const Multiset&lt; Type, Compare, Allocator &gt; &amp;other)</argsstring>
        <name>operator=</name>
        <qualifiedname>CGAL::Multiset::operator=</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>assignment operator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="213" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a8394ebc72a1bec73a8e6ab2b10875357" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::swap</definition>
        <argsstring>(Multiset&lt; Type, Compare, Allocator &gt; &amp;other)</argsstring>
        <name>swap</name>
        <qualifiedname>CGAL::Multiset::swap</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>swaps the contents of <computeroutput>s</computeroutput> with those of the other set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="227" column="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Access Member Functions</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a5b9a2ec88f7d2842d977b0a0b8b82e3f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Compare</type>
        <definition>Compare CGAL::Multiset&lt; Type, Compare, Allocator &gt;::key_comp</definition>
        <argsstring>() const</argsstring>
        <name>key_comp</name>
        <qualifiedname>CGAL::Multiset::key_comp</qualifiedname>
        <briefdescription>
<para>the comparison functor used. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="240" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a03efda11d41cc87e99f2da84287d3fec" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Compare</type>
        <definition>Compare CGAL::Multiset&lt; Type, Compare, Allocator &gt;::value_comp</definition>
        <argsstring>() const</argsstring>
        <name>value_comp</name>
        <qualifiedname>CGAL::Multiset::value_comp</qualifiedname>
        <briefdescription>
<para>the comparison functor used (same as above). </para>
        </briefdescription>
        <detaileddescription>
<para>Both functions have a non-const version that return a reference to the comparison functor. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="255" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a002b03e915e8589f4f121f20dd5e689c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Multiset&lt; Type, Compare, Allocator &gt;::empty</definition>
        <argsstring>()</argsstring>
        <name>empty</name>
        <qualifiedname>CGAL::Multiset::empty</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> if the set is empty, <computeroutput>false</computeroutput> otherwise. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="268" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a2cbe7ebc009b815552b7f91f39861d26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t CGAL::Multiset&lt; Type, Compare, Allocator &gt;::size</definition>
        <argsstring>()</argsstring>
        <name>size</name>
        <qualifiedname>CGAL::Multiset::size</qualifiedname>
        <briefdescription>
<para>returns the number of elements stored in the set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="281" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a8b5cd63c730990c614f55756ae3a6ae2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t CGAL::Multiset&lt; Type, Compare, Allocator &gt;::max_size</definition>
        <argsstring>()</argsstring>
        <name>max_size</name>
        <qualifiedname>CGAL::Multiset::max_size</qualifiedname>
        <briefdescription>
<para>returns the maximal number of elements the set can store (same as <computeroutput><ref refid="classCGAL_1_1Multiset_1a2cbe7ebc009b815552b7f91f39861d26" kindref="member">size()</ref></computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="295" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a2428093d3eb307834678072d107aae18" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <qualifiedname>CGAL::Multiset::begin</qualifiedname>
        <briefdescription>
<para>returns an iterator pointing to the first element stored in the set (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="309" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <qualifiedname>CGAL::Multiset::end</qualifiedname>
        <briefdescription>
<para>returns an iterator pointing beyond the last element stored in the set (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="323" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a039a792a26bfabc10bd3f2e180da1f4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1a5b73fc6a125e01bd662d59bd2b7965c6" kindref="member">reverse_iterator</ref></type>
        <definition>reverse_iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::rbegin</definition>
        <argsstring>()</argsstring>
        <name>rbegin</name>
        <qualifiedname>CGAL::Multiset::rbegin</qualifiedname>
        <briefdescription>
<para>returns a reverse iterator pointing beyond the last element stored in the set (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="337" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a71e79822809560ce3e1cc7ac5352b533" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1a5b73fc6a125e01bd662d59bd2b7965c6" kindref="member">reverse_iterator</ref></type>
        <definition>reverse_iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::rend</definition>
        <argsstring>()</argsstring>
        <name>rend</name>
        <qualifiedname>CGAL::Multiset::rend</qualifiedname>
        <briefdescription>
<para>returns a reverse iterator pointing to the first element stored in the set (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="351" column="18"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Comparison Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a717f06e6a6f7ee880fe8f6eab1579960" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Multiset&lt; Type, Compare, Allocator &gt;::operator==</definition>
        <argsstring>(const Multiset&lt; Type, Compare, Allocator &gt; &amp;other) const</argsstring>
        <name>operator==</name>
        <qualifiedname>CGAL::Multiset::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> if the sequences of elements in the two sets are pairwise equal (using the comparison functor). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="365" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ac51a626d8a5bb74b00dcdf40e8c5d8ff" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Multiset&lt; Type, Compare, Allocator &gt;::operator&lt;</definition>
        <argsstring>(const Multiset&lt; Type, Compare, Allocator &gt; &amp;other) const</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>CGAL::Multiset::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref>&lt; Type, Compare, Allocator &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> if the element sequence in <computeroutput>s</computeroutput> is lexicographically smaller than the element sequence of <computeroutput>other</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="380" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Insertion Methods</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a38025b7f2edf0c1658e797712efbafe5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::insert</definition>
        <argsstring>(const Type &amp;x)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::Multiset::insert</qualifiedname>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>inserts the element <computeroutput>x</computeroutput> into the set and returns an iterator pointing to the newly inserted element. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="395" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a0cf593a9103b8110358027db5736290b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::insert</definition>
        <argsstring>(InputIterator first, InputIterator last)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::Multiset::insert</qualifiedname>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>first</declname>
        </param>
        <param>
          <type><ref refid="classInputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">InputIterator</ref></type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>inserts all elements in the range <computeroutput>[first, last)</computeroutput> into the set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="410" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a4eeaf8f905eeb2674e29d2c0439a1c6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::insert</definition>
        <argsstring>(iterator position, const Type &amp;x)</argsstring>
        <name>insert</name>
        <qualifiedname>CGAL::Multiset::insert</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>inserts the element <computeroutput>x</computeroutput> with a given iterator used as a hint for the position of the new element. </para>
        </briefdescription>
        <detaileddescription>
<para>It Returns an iterator pointing to the newly inserted element. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="425" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a28e033f431134f9abcb888f33371b6a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::insert_before</definition>
        <argsstring>(iterator position, const Type &amp;x)</argsstring>
        <name>insert_before</name>
        <qualifiedname>CGAL::Multiset::insert_before</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>inserts the element <computeroutput>x</computeroutput> as the predecessor of the element at the given position. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The operation does not violate the set order - that is, <computeroutput>x</computeroutput> is not greater than the element pointed by <computeroutput>position</computeroutput> and not less than its current predecessor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="442" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a6a9a6e1d5be4e10b9377455cce7cc89b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::insert_after</definition>
        <argsstring>(iterator position, const Type &amp;x)</argsstring>
        <name>insert_after</name>
        <qualifiedname>CGAL::Multiset::insert_after</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>inserts the element <computeroutput>x</computeroutput> as the successor of the element at the given position. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The operation does not violate the set order - that is, <computeroutput>x</computeroutput> is not less than the element pointed by <computeroutput>position</computeroutput> and not greater than its current successor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="459" column="10"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Removal Methods</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a8844fd265441635f374fac7f0507cc80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t CGAL::Multiset&lt; Type, Compare, Allocator &gt;::erase</definition>
        <argsstring>(const Type &amp;x)</argsstring>
        <name>erase</name>
        <qualifiedname>CGAL::Multiset::erase</qualifiedname>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>erases all elements equivalent to <computeroutput>x</computeroutput> from the set and returns the number of erased elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="473" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ae9c79a7f3c1f85b96cdc6e8e89e06472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::erase</definition>
        <argsstring>(iterator position)</argsstring>
        <name>erase</name>
        <qualifiedname>CGAL::Multiset::erase</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <briefdescription>
<para>erases the element pointed by <computeroutput>position</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="486" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a726e1bbf117a2e76c02241e7ba5cb5a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <qualifiedname>CGAL::Multiset::clear</qualifiedname>
        <briefdescription>
<para>clears the set (erases all stored elements). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="499" column="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Look-up Methods</header>
      <description><para>All methods listed in this section can also accept a <computeroutput>Type</computeroutput> element as a look-up key.</para>
<para>In this case, it is not necessary to supply a <computeroutput>CompareKey</computeroutput> functor, as the <computeroutput>Compare</computeroutput> functor will be used by default. </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1acf24c120c80b8a15a2fb0cdffad6bb1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::find</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key)</argsstring>
        <name>find</name>
        <qualifiedname>CGAL::Multiset::find</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>searches for the an element equivalent to <computeroutput>key</computeroutput> in the set. </para>
        </briefdescription>
        <detaileddescription>
<para>If the set contains objects equivalent to <computeroutput>key</computeroutput>, it returns an iterator pointing to the first one. Otherwise, <computeroutput><ref refid="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" kindref="member">end()</ref></computeroutput> is returned (a <computeroutput>const</computeroutput> version is also available). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="522" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1aab0ca799d988fde17441fdf5aabfad10" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t CGAL::Multiset&lt; Type, Compare, Allocator &gt;::count</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key) const</argsstring>
        <name>count</name>
        <qualifiedname>CGAL::Multiset::count</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>returns the number of elements equivalent to <computeroutput>key</computeroutput> in the set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="529" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ada002f4a091eb4885bbdabcb7fd1020a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::lower_bound</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key)</argsstring>
        <name>lower_bound</name>
        <qualifiedname>CGAL::Multiset::lower_bound</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>returns an iterator pointing to the first element in the set that is not less than <computeroutput>key</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If all set elements are less than <computeroutput>key</computeroutput>, <computeroutput><ref refid="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" kindref="member">end()</ref></computeroutput> is returned (a <computeroutput>const</computeroutput> version is also available). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="538" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a7997169c93dd4df7ff093b17f032e778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
        <definition>iterator CGAL::Multiset&lt; Type, Compare, Allocator &gt;::upper_bound</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key)</argsstring>
        <name>upper_bound</name>
        <qualifiedname>CGAL::Multiset::upper_bound</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>returns an iterator pointing to the first element in the set that is greater than <computeroutput>key</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If no set element is greater than <computeroutput>key</computeroutput>, <computeroutput><ref refid="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" kindref="member">end()</ref></computeroutput> is returned (a <computeroutput>const</computeroutput> version is also available). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="547" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ade51c5efac307f59c0a655d666206477" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; <ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref>, <ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref> &gt;</type>
        <definition>std::pair&lt; iterator, iterator &gt; CGAL::Multiset&lt; Type, Compare, Allocator &gt;::equal_range</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key)</argsstring>
        <name>equal_range</name>
        <qualifiedname>CGAL::Multiset::equal_range</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>returns the range of set elements equivalent to the given key, namely <computeroutput>(lower_bound(key), upper_bound(key))</computeroutput> (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="557" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a44a416a2fd9238420e959fc8f76bcc78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; <ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref>, bool &gt;</type>
        <definition>std::pair&lt; iterator, bool &gt; CGAL::Multiset&lt; Type, Compare, Allocator &gt;::find_lower</definition>
        <argsstring>(const Key &amp;key, const CompareKey &amp;comp_key)</argsstring>
        <name>find_lower</name>
        <qualifiedname>CGAL::Multiset::find_lower</qualifiedname>
        <param>
          <type>const Key &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const CompareKey &amp;</type>
          <declname>comp_key</declname>
        </param>
        <briefdescription>
<para>returns a pair comprised of <computeroutput>lower_bound(key)</computeroutput> and a Boolean flag indicating whether this iterator points to an element equivalent to the given key (a <computeroutput>const</computeroutput> version is also available). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="568" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Special Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1ac5560e651858b35365af3f45e7854a73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::replace</definition>
        <argsstring>(iterator position, const Type &amp;x)</argsstring>
        <name>replace</name>
        <qualifiedname>CGAL::Multiset::replace</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>const Type &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>replaces the element stored at the given position with <computeroutput>x</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The operation does not violate the set order - that is, <computeroutput>x</computeroutput> is not less that <computeroutput>position</computeroutput>&apos;s predecessor and not greater than its successor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="583" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a9d72aeedf37177117efac368604081e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::swap</definition>
        <argsstring>(iterator pos1, iterator pos2)</argsstring>
        <name>swap</name>
        <qualifiedname>CGAL::Multiset::swap</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>pos1</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>pos2</declname>
        </param>
        <briefdescription>
<para>swaps places between the two elements given by <computeroutput>pos1</computeroutput> and <computeroutput>pos2</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para>The operation does not violate the set order - that is, <computeroutput>pos1</computeroutput> and <computeroutput>pos2</computeroutput> store equivalent elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="598" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a1be039295328763c3094388b630c4fe7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::catenate</definition>
        <argsstring>(Self &amp;s_prime)</argsstring>
        <name>catenate</name>
        <qualifiedname>CGAL::Multiset::catenate</qualifiedname>
        <param>
          <type>Self &amp;</type>
          <declname>s_prime</declname>
        </param>
        <briefdescription>
<para>concatenates all elements in <computeroutput>s_prime</computeroutput> into <computeroutput>s</computeroutput> and clears <computeroutput>s_prime</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>All iterators to <computeroutput>s</computeroutput> and to <computeroutput>s_prime</computeroutput> remain valid. <simplesect kind="pre"><para>The maximal element in <computeroutput>s</computeroutput> is not greater than the minimal element in <computeroutput>s_prime</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="615" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1a2ae90f67b298c349a83a6ef2304cc11c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Key</type>
          </param>
          <param>
            <type>class CompareKey</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::split</definition>
        <argsstring>(Key key, CompareKey comp_key, Self &amp;s_prime)</argsstring>
        <name>split</name>
        <qualifiedname>CGAL::Multiset::split</qualifiedname>
        <param>
          <type>Key</type>
          <declname>key</declname>
        </param>
        <param>
          <type>CompareKey</type>
          <declname>comp_key</declname>
        </param>
        <param>
          <type>Self &amp;</type>
          <declname>s_prime</declname>
        </param>
        <briefdescription>
<para>splits <computeroutput>s</computeroutput> such that it contains all elements that are less than the given <computeroutput>key</computeroutput> and such that <computeroutput>s_prime</computeroutput> contains all other elements. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>s_prime</computeroutput> is initially empty. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="631" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Multiset_1aa4257434f06b5553ff71e94d7a6a182e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CGAL::Multiset&lt; Type, Compare, Allocator &gt;::split</definition>
        <argsstring>(iterator position, Self &amp;s_prime)</argsstring>
        <name>split</name>
        <qualifiedname>CGAL::Multiset::split</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" kindref="member">iterator</ref></type>
          <declname>position</declname>
        </param>
        <param>
          <type>Self &amp;</type>
          <declname>s_prime</declname>
        </param>
        <briefdescription>
<para>splits <computeroutput>s</computeroutput> such that it contains all set elements in the range <computeroutput>[begin, position)</computeroutput> and such that <computeroutput>s_prime</computeroutput> contains all elements in the range <computeroutput>[position, <ref refid="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" kindref="member">end()</ref>)</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>s_prime</computeroutput> is initially empty. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Multiset.h" line="647" column="6"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><anchor id="classCGAL_1_1Multiset_1classcgal_multimap"/></para>
    </briefdescription>
    <detaileddescription>
<para>An instance <computeroutput>s</computeroutput> of the parametrized data type <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> is a multi-set of elements of type <computeroutput>Type</computeroutput>, represented as a red-black tree (see [<ref refid="citelist_1CITEREF_clrs-ia-01" kindref="member">[3]</ref> Chapter 13 for an excellent introduction to red-black trees). The main difference between <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> and the STL <computeroutput>std::multiset</computeroutput> is that the latter uses a less-than functor with a Boolean return type, while our <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> class is parameterized by a comparison functor <computeroutput>Compare</computeroutput> that returns the three-valued <computeroutput>Comparison_result</computeroutput> (namely it returns either <computeroutput>SMALLER</computeroutput>, <computeroutput>EQUAL</computeroutput>, or <computeroutput>LARGER</computeroutput>). It is thus possible to maintain the underlying red-black tree with less invocations of the comparison functor. This leads to a speedup of about 5% even if we maintain a set of integers. When each comparison of two elements of type <computeroutput>Type</computeroutput> is an expensive operation (for example, when they are geometric entities represented using exact arithmetic), the usage of a three-valued comparison functor can lead to considerable decrease in the running times.</para>
<para>Moreover, <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> allows the insertion of an element into the set given its <emphasis>exact</emphasis> position, and not just using an insertion hint, as done by <computeroutput>std::multiset</computeroutput>. This can further reduce the running times, as additional comparison operations can be avoided.</para>
<para>In addition, the <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> guarantees that the order of elements sent to the comparison functor is fixed. For example, if we insert a new element <computeroutput>x</computeroutput> into the set (or erase an element from the set), then we always invoke <computeroutput>Compare() (x, y)</computeroutput> (and never <computeroutput>Compare() (y, x)</computeroutput>), where <computeroutput>y</computeroutput> is an element already stored in the set. This behavior, not supported by <computeroutput>std::multiset</computeroutput>, is sometimes crucial for designing more efficient comparison predicates.</para>
<para><computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> also allows for look-up of keys whose type may differ from <computeroutput>Type</computeroutput>, as long as users supply a comparison functor <computeroutput>CompareKey</computeroutput>, where <computeroutput>CompareKey() (key, y)</computeroutput> returns the three-valued <computeroutput>Comparison_result</computeroutput> (<computeroutput>key</computeroutput> is the look-up key and <computeroutput>y</computeroutput> is an element of type <computeroutput>Type</computeroutput>). Indeed, it is very convenient to look-up equivalent objects in the set given just by their key. We note however that it is also possible to use a key of type <computeroutput>Type</computeroutput> and to employ the default <computeroutput>Compare</computeroutput> functor for the look-up, as done when using the <computeroutput>std::multiset</computeroutput> class.</para>
<para><simplesect kind="warning"><para>Finally, <computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> introduces the <computeroutput><ref refid="classCGAL_1_1Multiset_1a1be039295328763c3094388b630c4fe7" kindref="member">catenate()</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Multiset_1a2ae90f67b298c349a83a6ef2304cc11c" kindref="member">split()</ref></computeroutput> functions. The first function operates on <computeroutput>s</computeroutput> and accepts a second set <computeroutput>s2</computeroutput>, such that the maximum element in <computeroutput>s</computeroutput> is not greater than the minimal element in <computeroutput>s2</computeroutput>, and concatenates <computeroutput>s2</computeroutput> to <computeroutput>s</computeroutput>. The second function splits <computeroutput>s</computeroutput> into two sets, one containing all the elements that are less than a given key, and the other contains all elements greater than (or equal to) this key.</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>the type of the stored elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Compare</parametername>
</parameternamelist>
<parameterdescription>
<para>the comparison-functor type. This type should provide the following operator for comparing two <computeroutput>Type</computeroutput> elements, namely: <linebreak/>
 <computeroutput>Comparison_result operator() (const Type&amp; t1, const Type&amp; t2) const;</computeroutput> <linebreak/>
 The <computeroutput>CGAL::Compare&lt;Type&gt;</computeroutput> functor is used by default. In this case, <computeroutput>Type</computeroutput> must support an equality operator (<computeroutput>operator==</computeroutput>) and a less-than operator (<computeroutput>operator&lt;</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>the allocator type. <computeroutput>CGAL_ALLOCATOR</computeroutput> is used by default.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Implementation</bold><linebreak/>
</para>
<para><computeroutput><ref refid="classCGAL_1_1Multiset" kindref="compound">Multiset</ref></computeroutput> uses a proprietary implementation of a red-black tree data-structure. The red-black tree invariants guarantee that the height of a tree containing <formula id="8">$ n$</formula> elements is <formula id="12">$O(\log{n})$</formula> (more precisely, it is bounded by <formula id="13">$ 2 \log_{2}{n}$</formula>). As a consequence, all methods that accept an element and need to locate it in the tree (namely <computeroutput>insert(x)</computeroutput>, <computeroutput>erase(x)</computeroutput>, <computeroutput>find(x)</computeroutput>, <computeroutput>count(x)</computeroutput>, <computeroutput>lower_bound(x)</computeroutput> , <computeroutput>upper_bound(x)</computeroutput>, <computeroutput>find_lower(x)</computeroutput> and <computeroutput>equal_range(x)</computeroutput>) take <formula id="12">$O(\log{n})$</formula> time and perform <formula id="12">$O(\log{n})$</formula> comparison operations.</para>
<para>On the other hand, the set operations that accept a position iterator (namely <computeroutput>insert_before(pos, x)</computeroutput>, <computeroutput>insert_after(pos, x)</computeroutput> and <computeroutput>erase(pos)</computeroutput>) are much more efficient as they can be performed at a <emphasis>constant</emphasis> amortized cost (see <ref refid="citelist_1CITEREF_gs-dfbt-78" kindref="member">[4]</ref> and <ref refid="citelist_1CITEREF_t-dsna-83" kindref="member">[6]</ref> for more details). More important, these set operations require <emphasis>no</emphasis> comparison operations. Therefore, it is highly recommended to maintain the set via iterators to the stored elements, whenever possible. The function <computeroutput>insert(pos, x)</computeroutput> is safer to use, but it takes amortized <formula id="14">$O(\min{d,\log{n}})$</formula> time, where <formula id="15">$ d$</formula> is the distance between the given position and the true position of <computeroutput>x</computeroutput>. In addition, it always performs at least two comparison operations.</para>
<para>The <computeroutput><ref refid="classCGAL_1_1Multiset_1a1be039295328763c3094388b630c4fe7" kindref="member">catenate()</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Multiset_1a2ae90f67b298c349a83a6ef2304cc11c" kindref="member">split()</ref></computeroutput> functions are also very efficient, and can be performed in <formula id="12">$O(\log{n})$</formula> time, where <formula id="8">$ n$</formula> is the total number of elements in the sets, and without performing any comparison operations (see <ref refid="citelist_1CITEREF_t-dsna-83" kindref="member">[6]</ref> for the details). Note however that the size of two sets resulting from a split operation is initially unknown, as it is impossible to compute it in less than linear time. Thus, the first invocation of <computeroutput><ref refid="classCGAL_1_1Multiset_1a2cbe7ebc009b815552b7f91f39861d26" kindref="member">size()</ref></computeroutput> on such a set takes linear time, and <emphasis>not</emphasis> constant time.</para>
<para>The design is derived from the STL <computeroutput>multiset</computeroutput> class-template (see, e.g, <ref refid="citelist_1CITEREF_cgal:ms-strg-96" kindref="member">[5]</ref>), where the main differences between the two classes are highlighted in the class definition above. </para>
    </detaileddescription>
    <location file="CGAL/Multiset.h" line="109" column="1" bodyfile="CGAL/Multiset.h" bodystart="109" bodyend="655"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Multiset_1a2428093d3eb307834678072d107aae18" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>begin</name></member>
      <member refid="classCGAL_1_1Multiset_1a1be039295328763c3094388b630c4fe7" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>catenate</name></member>
      <member refid="classCGAL_1_1Multiset_1a726e1bbf117a2e76c02241e7ba5cb5a0" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>clear</name></member>
      <member refid="classCGAL_1_1Multiset_1a7e20d7e960306e8b3c25c9174e4a4075" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>const_iterator</name></member>
      <member refid="classCGAL_1_1Multiset_1a2c52a692f7283555e88ad75c2681a7b0" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>const_reverse_iterator</name></member>
      <member refid="classCGAL_1_1Multiset_1aab0ca799d988fde17441fdf5aabfad10" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>count</name></member>
      <member refid="classCGAL_1_1Multiset_1a002b03e915e8589f4f121f20dd5e689c" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>empty</name></member>
      <member refid="classCGAL_1_1Multiset_1a105830a7f979031fd40c96e88db7d49b" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>end</name></member>
      <member refid="classCGAL_1_1Multiset_1ade51c5efac307f59c0a655d666206477" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>equal_range</name></member>
      <member refid="classCGAL_1_1Multiset_1a8844fd265441635f374fac7f0507cc80" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>erase</name></member>
      <member refid="classCGAL_1_1Multiset_1ae9c79a7f3c1f85b96cdc6e8e89e06472" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>erase</name></member>
      <member refid="classCGAL_1_1Multiset_1acf24c120c80b8a15a2fb0cdffad6bb1a" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>find</name></member>
      <member refid="classCGAL_1_1Multiset_1a44a416a2fd9238420e959fc8f76bcc78" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>find_lower</name></member>
      <member refid="classCGAL_1_1Multiset_1a38025b7f2edf0c1658e797712efbafe5" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Multiset_1a0cf593a9103b8110358027db5736290b" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Multiset_1a4eeaf8f905eeb2674e29d2c0439a1c6b" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>insert</name></member>
      <member refid="classCGAL_1_1Multiset_1a6a9a6e1d5be4e10b9377455cce7cc89b" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>insert_after</name></member>
      <member refid="classCGAL_1_1Multiset_1a28e033f431134f9abcb888f33371b6a9" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>insert_before</name></member>
      <member refid="classCGAL_1_1Multiset_1ab6755f133101132f62eaf49e4f8a2faa" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>iterator</name></member>
      <member refid="classCGAL_1_1Multiset_1a5b9a2ec88f7d2842d977b0a0b8b82e3f" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>key_comp</name></member>
      <member refid="classCGAL_1_1Multiset_1ada002f4a091eb4885bbdabcb7fd1020a" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>lower_bound</name></member>
      <member refid="classCGAL_1_1Multiset_1a8b5cd63c730990c614f55756ae3a6ae2" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>max_size</name></member>
      <member refid="classCGAL_1_1Multiset_1ac279545948dac161fb8a16b0dbc7ac2a" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>Multiset</name></member>
      <member refid="classCGAL_1_1Multiset_1a57d2a5a483e7df5231703916a2a0bfee" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>Multiset</name></member>
      <member refid="classCGAL_1_1Multiset_1a75bd014fdd6f115cd60a3290e3165af7" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>Multiset</name></member>
      <member refid="classCGAL_1_1Multiset_1afc7a2011be4ed7ad5122c44a83939722" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>Multiset</name></member>
      <member refid="classCGAL_1_1Multiset_1ac51a626d8a5bb74b00dcdf40e8c5d8ff" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>operator&lt;</name></member>
      <member refid="classCGAL_1_1Multiset_1a677412d4304005cefedb3f7547c878e4" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>operator=</name></member>
      <member refid="classCGAL_1_1Multiset_1a717f06e6a6f7ee880fe8f6eab1579960" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>operator==</name></member>
      <member refid="classCGAL_1_1Multiset_1a039a792a26bfabc10bd3f2e180da1f4c" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>rbegin</name></member>
      <member refid="classCGAL_1_1Multiset_1a71e79822809560ce3e1cc7ac5352b533" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>rend</name></member>
      <member refid="classCGAL_1_1Multiset_1ac5560e651858b35365af3f45e7854a73" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>replace</name></member>
      <member refid="classCGAL_1_1Multiset_1a5b73fc6a125e01bd662d59bd2b7965c6" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>reverse_iterator</name></member>
      <member refid="classCGAL_1_1Multiset_1a2cbe7ebc009b815552b7f91f39861d26" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>size</name></member>
      <member refid="classCGAL_1_1Multiset_1a2ae90f67b298c349a83a6ef2304cc11c" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>split</name></member>
      <member refid="classCGAL_1_1Multiset_1aa4257434f06b5553ff71e94d7a6a182e" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>split</name></member>
      <member refid="classCGAL_1_1Multiset_1a8394ebc72a1bec73a8e6ab2b10875357" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>swap</name></member>
      <member refid="classCGAL_1_1Multiset_1a9d72aeedf37177117efac368604081e6" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>swap</name></member>
      <member refid="classCGAL_1_1Multiset_1a7997169c93dd4df7ff093b17f032e778" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>upper_bound</name></member>
      <member refid="classCGAL_1_1Multiset_1a03efda11d41cc87e99f2da84287d3fec" prot="public" virt="non-virtual"><scope>CGAL::Multiset</scope><name>value_comp</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
