<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_Poisson_Surface_Reconstruction"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly></para>
<para><simplesect kind="authors"><para>Pierre Alliez, Laurent Saboret, Ga<eumlaut/>l Guennebaud</para>
</simplesect>
</para>
<sect1 id="index_1Poisson_surface_reconstruction_3Introduction">
<title>Introduction</title>
<para>This CGAL component implements a surface reconstruction method which takes as input point sets with oriented normals and computes an implicit function. We assume that the input points contain no outliers and little noise. The output surface mesh is generated by extracting an isosurface of this function with the CGAL Surface Mesh Generator <ref refid="citelist_1CITEREF_cgal:ry-gsddrm-06" kindref="member">[4]</ref> or potentially with any other surface contouring algorithm.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figintroduction"/> <image type="html" name="introduction.jpg"></image>
 <image type="latex" name="introduction.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figintroduction" kindref="member">fig__Poisson_surface_reconstruction_3figintroduction</ref> Poisson surface reconstruction.<linebreak/>
Left: 17K points sampled on the statue of an elephant with a Minolta laser scanner. Right: reconstructed surface mesh. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>More specifically, the core surface reconstruction algorithm consists of computing an implicit function which is an approximate indicator function of the inferred solid (Poisson Surface Reconstruction - referred to as Poisson). Poisson is a two steps process: it requires solving for the implicit function before function evaluation.</para>
<para><simplesect kind="note"><para>A <ref refid="tuto_reconstruction" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">detailed tutorial on surface reconstruction</ref> is provided with a guide to choose the most appropriate method along with pre- and post-processing.</para>
</simplesect>
</para>
</sect1>
<sect1 id="index_1Poisson_surface_reconstruction_3Common">
<title>Common Reconstruction Pipeline</title>
<para>Surface reconstruction from point sets is often a sequential process with the following steps: 1) Scanning and scan alignment produce a set of points or points with normals; 2) Outlier removal; 3) Simplification to reduce the number of input points; 4) Smoothing to reduce noise in the input data; 5) Normal estimation and orientation when the normals are not already provided by the acquisition device; and 6) Surface reconstruction.</para>
<para>CGAL provides algorithms for all steps listed above except alignment.</para>
<para>Chapter <ref refid="index_1chappoint_set_processing_3" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">Point Set Processing</ref> describes algorithms to pre-process the point set before reconstruction with functions devoted to the simplification, outlier removal, smoothing, normal estimation and normal orientation.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figpipeline"/> <image type="html" name="pipeline.jpg"></image>
 <image type="latex" name="pipeline.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figpipeline" kindref="member">fig__Poisson_surface_reconstruction_3figpipeline</ref> Common surface reconstruction pipeline. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1Poisson_surface_reconstruction_3Poisson">
<title>Poisson</title>
<para>Given a set of 3D points with oriented normals (denoted oriented points in the sequel) sampled on the boundary of a 3D solid, the Poisson Surface Reconstruction method <ref refid="citelist_1CITEREF_Kazhdan06" kindref="member">[2]</ref> solves for an approximate indicator function of the inferred solid, whose gradient best matches the input normals. The output scalar function, represented in an adaptive octree, is then iso-contoured using an adaptive marching cubes.</para>
<para>CGAL implements a variant of this algorithm which solves for a piecewise linear function on a 3D Delaunay triangulation instead of an adaptive octree. The algorithm takes as input a set of 3D oriented points. It builds a 3D Delaunay triangulation from these points and refines it by Delaunay refinement so as to remove all badly shaped (non isotropic) tetrahedra and to tessellate a loose bounding box of the input oriented points. The normal of each Steiner point added during refinement is set to zero. It then solves for a scalar indicator function <formula id="0">$ f$</formula> represented as a piecewise linear function over the refined triangulation. More specifically, it solves for the Poisson equation <formula id="1">$ \Delta f = div(\mathbf{n})$</formula> at each vertex of the triangulation using a sparse linear solver. Eventually, the CGAL surface mesh generator extracts an isosurface with function value set by default to be the median value of <formula id="0">$ f$</formula> at all input points.</para>
</sect1>
<sect1 id="index_1Poisson_surface_reconstruction_3Function">
<title>Reconstruction Function</title>
<para>A global function <computeroutput><ref refid="group__PkgPoissonSurfaceReconstruction3Ref_1ga2470854cf03552ecee02f11c17024ddf" kindref="member">poisson_surface_reconstruction_delaunay()</ref></computeroutput> is provided. It takes points with normals as input and handles the whole reconstruction pipeline :</para>
<para><itemizedlist>
<listitem><para>it computes the implicit function</para>
</listitem><listitem><para>it reconstructs the surface with a given precision using the CGAL surface mesh generator based on Delaunay refinement <ref refid="citelist_1CITEREF_cgal:ry-gsddrm-06" kindref="member">[4]</ref> <ref refid="citelist_1CITEREF_cgal:bo-pgsms-05" kindref="member">[1]</ref></para>
</listitem><listitem><para>it outputs the result in a polygon mesh.</para>
</listitem></itemizedlist>
</para>
<para>This function aims at providing a quick and user-friendly API for Poisson reconstruction. Advanced users may be interested in using the class (see <ref refid="index_1Poisson_surface_reconstruction_3Class" kindref="member">Reconstruction Class</ref>) which allows them, for example, to use another surface mesher or a different output structure.</para>
<sect2 id="index_1Poisson_surface_reconstruction_3Example_function">
<title>Example</title>
<para>The following example reads a point set and reconstructs a surface using Poisson reconstruction.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Poisson_surface_reconstruction_3_2poisson_reconstruction_function_8cpp-example" kindref="compound">Poisson_surface_reconstruction_3/poisson_reconstruction_function.cpp</ref> <programlisting filename="Poisson_surface_reconstruction_3/poisson_reconstruction_function.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/poisson_surface_reconstruction.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>Pwn;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;Kernel&gt;<sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Pwn&gt;<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/kitten.xyz&quot;</highlight><highlight class="normal">),<sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(CGAL::First_of_pair_property_map&lt;Pwn&gt;())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.normal_map(CGAL::Second_of_pair_property_map&lt;Pwn&gt;())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyhedron<sp/>output_mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>average_spacing<sp/>=<sp/>CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(points,<sp/>6,<sp/>CGAL::parameters::point_map(CGAL::First_of_pair_property_map&lt;Pwn&gt;()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="group__PkgPoissonSurfaceReconstruction3Ref_1ga2470854cf03552ecee02f11c17024ddf" kindref="member">CGAL::poisson_surface_reconstruction_delaunay</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(points.begin(),<sp/>points.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::First_of_pair_property_map&lt;Pwn&gt;(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::Second_of_pair_property_map&lt;Pwn&gt;(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_mesh,<sp/>average_spacing))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;kitten_poisson-20-30-0.375.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>output_mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1Poisson_surface_reconstruction_3Class">
<title>Reconstruction Class</title>
<para>The class template declaration is <computeroutput>template&lt;class Gt&gt; class <ref refid="classCGAL_1_1Poisson__reconstruction__function" kindref="compound">Poisson_reconstruction_function</ref></computeroutput> where <computeroutput>Gt</computeroutput> is a geometric traits class.</para>
<para>For details see: <computeroutput><ref refid="classCGAL_1_1Poisson__reconstruction__function" kindref="compound">Poisson_reconstruction_function</ref>&lt;GeomTraits&gt;</computeroutput></para>
<sect2 id="index_1Poisson_surface_reconstruction_3Example_class">
<title>Example</title>
<para>The following example reads a point set, creates a Poisson implicit function and reconstructs a surface.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Poisson_surface_reconstruction_3_2poisson_reconstruction_example_8cpp-example" kindref="compound">Poisson_surface_reconstruction_3/poisson_reconstruction_example.cpp</ref> <programlisting filename="Poisson_surface_reconstruction_3/poisson_reconstruction_example.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Poisson_reconstruction_function.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Mesh_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Mesh_complex_3_in_triangulation_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Mesh_criteria_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Labeled_mesh_domain_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/make_mesh_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/facets_in_complex_3_to_triangle_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/compute_average_spacing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_mesh_processing/distance.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/transform_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/>Vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Point,<sp/>Vector&gt;<sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;<sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;<sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Sphere__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Sphere_3</ref><sp/>Sphere;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/>PointList;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polyhedron_3&lt;Kernel&gt;<sp/>Polyhedron;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Poisson__reconstruction__function" kindref="compound">CGAL::Poisson_reconstruction_function&lt;Kernel&gt;</ref><sp/><ref refid="classCGAL_1_1Poisson__reconstruction__function" kindref="compound">Poisson_reconstruction_function</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Labeled_mesh_domain_3&lt;Kernel&gt;<sp/>Mesh_domain;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Mesh_triangulation_3&lt;Mesh_domain&gt;::type<sp/>Tr;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Mesh_complex_3_in_triangulation_3&lt;Tr&gt;<sp/>C3t3;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Mesh_criteria_3&lt;Tr&gt;<sp/>Mesh_criteria;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Poisson<sp/>options</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sm_angle<sp/>=<sp/>20.0;<sp/></highlight><highlight class="comment">//<sp/>Min<sp/>triangle<sp/>angle<sp/>in<sp/>degrees.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sm_radius<sp/>=<sp/>30;<sp/></highlight><highlight class="comment">//<sp/>Max<sp/>triangle<sp/>size<sp/>w.r.t.<sp/>point<sp/>set<sp/>average<sp/>spacing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sm_distance<sp/>=<sp/>0.375;<sp/></highlight><highlight class="comment">//<sp/>Surface<sp/>Approximation<sp/>error<sp/>w.r.t.<sp/>point<sp/>set<sp/>average<sp/>spacing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reads<sp/>the<sp/>point<sp/>set<sp/>file<sp/>in<sp/>points[].</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>read_points()<sp/>requires<sp/>an<sp/>iterator<sp/>over<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>+<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each<sp/>point&apos;s<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PointList<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(<ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/kitten.xyz&quot;</highlight><highlight class="normal">),<sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.normal_map<sp/>(Normal_map())))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Creates<sp/>implicit<sp/>function<sp/>from<sp/>the<sp/>read<sp/>points<sp/>using<sp/>the<sp/>default<sp/>solver.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Note:<sp/>this<sp/>method<sp/>requires<sp/>an<sp/>iterator<sp/>over<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>+<sp/>property<sp/>maps<sp/>to<sp/>access<sp/>each<sp/>point&apos;s<sp/>position<sp/>and<sp/>normal.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Poisson_reconstruction_function<sp/>function(points.begin(),<sp/>points.end(),<sp/>Point_map(),<sp/>Normal_map());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Computes<sp/>the<sp/>Poisson<sp/>indicator<sp/>function<sp/>f()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>at<sp/>each<sp/>vertex<sp/>of<sp/>the<sp/>triangulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>!<sp/>function.compute_implicit_function()<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Computes<sp/>average<sp/>spacing</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>average_spacing<sp/>=<sp/>CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(points,<sp/>6<sp/></highlight><highlight class="comment">/*<sp/>knn<sp/>=<sp/>1<sp/>ring<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map<sp/>(Point_map()));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Computes<sp/>implicit<sp/>function<sp/>bounding<sp/>sphere<sp/>radius.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Sphere<sp/>bsphere<sp/>=<sp/>function.bounding_sphere();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>radius<sp/>=<sp/>std::sqrt(bsphere.squared_radius());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sm_sphere_radius<sp/>=<sp/>5.0<sp/>*<sp/>radius;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sm_dichotomy_error<sp/>=<sp/>sm_distance*average_spacing/1000.0;<sp/></highlight><highlight class="comment">//<sp/>Dichotomy<sp/>error<sp/>must<sp/>be<sp/>&lt;&lt;<sp/>sm_distance</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>surface<sp/>mesh<sp/>generation<sp/>criteria</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Mesh_criteria<sp/>criteria(CGAL::parameters::facet_angle<sp/>=<sp/>sm_angle,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::facet_size<sp/>=<sp/>sm_radius*average_spacing,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::facet_distance<sp/>=<sp/>sm_distance*average_spacing);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>mesh<sp/>domain</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Mesh_domain<sp/>domain<sp/>=<sp/>Mesh_domain::create_implicit_mesh_domain(function,<sp/>bsphere,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::relative_error_bound(sm_dichotomy_error<sp/>/<sp/>sm_sphere_radius));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Generates<sp/>mesh<sp/>with<sp/>manifold<sp/>option</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>C3t3<sp/>c3t3<sp/>=<sp/>CGAL::make_mesh_3&lt;C3t3&gt;(domain,<sp/>criteria,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::no_exude().no_perturb()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.manifold_with_boundary());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Tr&amp;<sp/>tr<sp/>=<sp/>c3t3.triangulation();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(tr.number_of_vertices()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>saves<sp/>reconstructed<sp/>surface<sp/>mesh</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;kitten_poisson-20-30-0.375.off&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Polyhedron<sp/>output_mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::facets_in_complex_3_to_triangle_mesh(c3t3,<sp/>output_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>&lt;&lt;<sp/>output_mesh;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>computes<sp/>the<sp/>approximation<sp/>error<sp/>of<sp/>the<sp/>reconstruction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>max_dist<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::Polygon_mesh_processing::approximate_max_distance_to_point_set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(output_mesh,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1ac87cfb03dd80e388d2fe53af9e53e9ed" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::make_range</ref><sp/>(boost::make_transform_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(points.begin(),<sp/>CGAL::Property_map_to_unary_function&lt;Point_map&gt;()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>boost::make_transform_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(points.end(),<sp/>CGAL::Property_map_to_unary_function&lt;Point_map&gt;())),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>4000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Max<sp/>distance<sp/>to<sp/>point_set:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>max_dist<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3Contouring">
<title>Contouring</title>
<para>The computed implicit functions can be iso-contoured to reconstruct a surface by using the CGAL surface mesh generator <ref refid="citelist_1CITEREF_cgal:ry-gsddrm-06" kindref="member">[4]</ref> <ref refid="citelist_1CITEREF_cgal:bo-pgsms-05" kindref="member">[1]</ref> :</para>
<para><computeroutput>make_surface_mesh()</computeroutput></para>
<para>The parameter <computeroutput>Tag</computeroutput> affects the behavior of <computeroutput>make_surface_mesh()</computeroutput>:<itemizedlist>
<listitem><para><computeroutput><ref refid="structCGAL_1_1Manifold__tag" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Manifold_tag</ref></computeroutput>: the output mesh is guaranteed to be a manifold surface without boundary.</para>
</listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Manifold__with__boundary__tag" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Manifold_with_boundary_tag</ref></computeroutput>: the output mesh is guaranteed to be manifold and may have boundaries.</para>
</listitem><listitem><para><computeroutput><ref refid="structCGAL_1_1Non__manifold__tag" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Non_manifold_tag</ref></computeroutput>: the output mesh has no guarantee and hence is outputted as a polygon soup.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3Output">
<title>Output</title>
<para>The surface reconstructed by <computeroutput>make_surface_mesh()</computeroutput> is required to be a model of the concept <computeroutput>SurfaceMeshComplex_2InTriangulation_3</computeroutput>, a data structure devised to represent a two dimensional complex embedded into a three dimensional triangulation.</para>
<para><computeroutput>SurfaceMeshComplex_2InTriangulation_3</computeroutput> defines the methods to traverse the reconstructed surface, and e.g. convert it to a triangle soup.</para>
<para>Other CGAL components provide functions to write the reconstructed surface mesh to the Object File Format (OFF) <ref refid="citelist_1CITEREF_cgal:p-gmgv16-96" kindref="member">[3]</ref> and to convert it to a polyhedron (when it is manifold):<itemizedlist>
<listitem><para><computeroutput>output_surface_facets_to_off()</computeroutput></para>
</listitem><listitem><para><computeroutput>output_surface_facets_to_polyhedron()</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>See <ref refid="Poisson_surface_reconstruction_3_2poisson_reconstruction_example_8cpp-example" kindref="compound">poisson_reconstruction_example.cpp</ref> example above.</para>
</sect2>
</sect1>
<sect1 id="index_1surface_reconstruction_section_case_studies">
<title>Case Studies</title>
<para>The surface reconstruction problem being inherently ill-posed, the proposed algorithm does not pretend to reconstruct all kinds of surfaces with arbitrary sampling conditions. This section provides the user with some hints about the ideal sampling and contouring conditions, and depicts some failure cases when these conditions are not matched.</para>
<sect2 id="index_1Poisson_surface_reconstruction_3IdealConditions">
<title>Ideal Conditions</title>
<para>The user must keep in mind that the Poisson surface reconstruction algorithm comprises two phases (computing the implicit function from the input point set and contouring an iso-surface of this function). Both require some care in terms of sampling conditions and parameter tuning.</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3PointSet">
<title>Point Set</title>
<para>Ideally the current implementation of the Poisson surface reconstruction method expects a dense 3D oriented point set (typically matching the epsilon-sampling condition <ref refid="citelist_1CITEREF_cgal:bo-pgsms-05" kindref="member">[1]</ref>) and sampled over a closed, smooth surface. Oriented herein means that all 3D points must come with consistently oriented normals to the inferred surface. <ref refid="index_1fig__Poisson_surface_reconstruction_3figbimba" kindref="member">fig__Poisson_surface_reconstruction_3figbimba</ref> and <ref refid="index_1fig__Poisson_surface_reconstruction_3figeros" kindref="member">fig__Poisson_surface_reconstruction_3figeros</ref> illustrate cases where these ideal conditions are met.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figbimba"/> <image type="html" name="bimba.jpg"></image>
 <image type="latex" name="bimba.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figbimba" kindref="member">fig__Poisson_surface_reconstruction_3figbimba</ref> Poisson reconstruction. Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figeros"/> <image type="html" name="eros.jpg"></image>
 <image type="latex" name="eros.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figeros" kindref="member">fig__Poisson_surface_reconstruction_3figeros</ref> Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The algorithm is fairly robust to anisotropic sampling and to noise. It is also robust to missing data through filling the corresponding holes as the algorithm is designed to reconstruct the indicator function of an inferred solid (see <ref refid="index_1fig__Poisson_surface_reconstruction_3figholes_good" kindref="member">fig__Poisson_surface_reconstruction_3figholes_good</ref>).</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figholes_good"/> <image type="html" name="holes_good.jpg"></image>
 <image type="latex" name="holes_good.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figholes_good" kindref="member">fig__Poisson_surface_reconstruction_3figholes_good</ref> Top left: 65K points sampled on a hand (Kreon laser scanner). Bottom left: the point set is highly anisotropic due to the scanning technology. Right: reconstructed surface mesh and closeup. The holes are properly closed. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The algorithm is in general not robust to outliers, although a few outliers do not always create a failure, see <ref refid="index_1fig__Poisson_surface_reconstruction_3figoutliers" kindref="member">fig__Poisson_surface_reconstruction_3figoutliers</ref>.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figoutliers"/> <image type="html" name="outliers.jpg"></image>
 <image type="latex" name="outliers.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figoutliers" kindref="member">fig__Poisson_surface_reconstruction_3figoutliers</ref> Left: 70K points sampled on an elephant with few outliers emphasized with disks. Right: reconstructed surface mesh. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The algorithm works well even when the inferred surface is composed of several connected components, provided that both all normals are properly estimated and oriented (the current CGAL normal orienter algorithm may fail in some cases, see <computeroutput><ref refid="group__PkgPointSetProcessing3Algorithms_1ga17c3c558c3799b65bd23fba971a82a5c" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">mst_orient_normals()</ref></computeroutput>), and that the final contouring algorithm is properly seeded for each component. When the inferred surface is composed of several nested connected components care should be taken to orient the normals of each component in alternation (inward/outward) so that the final contouring stage picks a proper contouring value.</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3ContouringP">
<title>Contouring Parameters</title>
<para>Our implementation of the Poisson surface reconstruction algorithm computes an implicit function represented as a piecewise linear function over the tetrahedra of a 3D Delaunay triangulation constructed from the input points then refined through Delaunay refinement. For this reason, any iso-surface is also piecewise linear and hence may contain sharp creases. As the contouring algorithm <computeroutput>make_surface_mesh()</computeroutput> expects a smooth implicit function these sharp creases may create spurious clusters of vertices in the final reconstructed surface mesh when setting a small mesh sizing or surface approximation error parameter (see <ref refid="index_1fig__Poisson_surface_reconstruction_3figcontouring_bad" kindref="member">fig__Poisson_surface_reconstruction_3figcontouring_bad</ref>).</para>
<para>One way to avoid these spurious clusters consists of adjusting the mesh sizing and surface approximation parameters large enough compared to the average sampling density (obtained through <computeroutput><ref refid="group__PkgPointSetProcessing3Algorithms_1ga8b330397a3fb68176c851fd7d214b513" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">compute_average_spacing()</ref></computeroutput>) so that the contouring algorithm <emphasis>perceives</emphasis> a smooth iso-surface. We recommend to use the following contouring parameters:</para>
<para><itemizedlist>
<listitem><para>Max triangle radius: at least 100 times the average spacing.</para>
</listitem><listitem><para>Approximation distance: at least 0.25 times the average spacing.</para>
</listitem></itemizedlist>
</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figcontouring_bad"/> <image type="html" name="contouring_bad.jpg"></image>
 <image type="latex" name="contouring_bad.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figcontouring_bad" kindref="member">fig__Poisson_surface_reconstruction_3figcontouring_bad</ref> Left: surface reconstructed with approximation distance = 0.25 * average spacing. Right: surface reconstructed with approximation distance = 0.15 * average spacing. Notice the spurious cluster on the cheek. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3DegradedConditions">
<title>Degraded Conditions</title>
<para>The conditions listed above are rather restrictive and in practice not all of them are met in the applications. We now illustrates the behavior of the algorithm when the conditions are not met in terms of sampling, wrongly oriented normals, noise and sharp creases.</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3SparseSampling">
<title>Sparse Sampling</title>
<para>The reconstruction algorithm expects a sufficiently dense point set. Although there is no formal proof of correctness of the algorithm under certain density conditions due to its variational nature, our experiments show that the algorithm reconstructs well all thin features when the local spacing is at most one tenth of the local feature size (the distance to the medial axis, which captures altogether curvature, thickness and separation). When this condition is not met the reconstruction does not reconstruct the thin undersampled features (see <ref refid="index_1fig__Poisson_surface_reconstruction_3figsampling" kindref="member">fig__Poisson_surface_reconstruction_3figsampling</ref>).</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figsampling"/> <image type="html" name="sampling.jpg"></image>
 <image type="latex" name="sampling.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figsampling" kindref="member">fig__Poisson_surface_reconstruction_3figsampling</ref> Left: 50K points sampled on the Neptune trident. The reconstruction (not shown) is successful in this case. Right: point set simplified to 1K points then reconstructed (all input points are depicted with normals). The thin feature is not reconstructed. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3LargeHoles">
<title>Large Holes</title>
<para>The reconstruction is devised to solve for an implicit function which is an approximate indicator function of an inferred solid. For this reason the contouring algorithm always extracts a closed surface mesh and hence is able to fill the small holes where data are missing due, e.g., to occlusions during acquisition (see <ref refid="index_1fig__Poisson_surface_reconstruction_3figholes_bad" kindref="member">fig__Poisson_surface_reconstruction_3figholes_bad</ref>).</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figholes_bad"/> <image type="html" name="holes_bad.jpg"></image>
 <image type="latex" name="holes_bad.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figholes_bad" kindref="member">fig__Poisson_surface_reconstruction_3figholes_bad</ref> Left: 65K points sampled on a hand with no data captured at the wrist base. Right: reconstructed surface mesh. The surface is properly closed on the fingers and also closed at the wrist but in a less plausible manner. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>In case of large holes the algorithm still closes them all but the resulting piecewise linear implicit function may exhibit large triangle patches and sharp creases as the 3D Delaunay triangulation used for solving is very coarse where the holes are filled. This can be avoided by a two pass approach. The first pass for a subset of the points serves to get an approximation of the surface at the holes. This surface then serves to compute a smoother 3D Delaunay triangulation for the second pass with the full set of points.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3-fig-two_passes"/> <image type="html" name="two-passes.png"></image>
 <image type="latex" name="two-passes.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3-fig-two_passes" kindref="member">fig__Poisson_surface_reconstruction_3-fig-two_passes</ref> Left: The wrist. Middle: one pass. Right: two passes. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3WronglyOriented">
<title>Wrongly Oriented Normals</title>
<para>The Poisson surface reconstruction approaches solves for an implicit function whose gradient best matches a set of input normals. Because it solves this problem in the least squares sense, it is robust to few isolated wrongly oriented (flipped) normals. Nevertheless a cluster of wrongly oriented normals leads to an incorrect implicit function and hence to spurious geometric or even topological distortion (see <ref refid="index_1fig__Poisson_surface_reconstruction_3figflipped_normals" kindref="member">fig__Poisson_surface_reconstruction_3figflipped_normals</ref>).</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figflipped_normals"/> <image type="html" name="flipped_normals.jpg"></image>
 <image type="latex" name="flipped_normals.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figflipped_normals" kindref="member">fig__Poisson_surface_reconstruction_3figflipped_normals</ref> Left: points sampled on a sphere with a cluster of wrongly oriented normals. Right: reconstructed surface mesh with a spurious bump. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3NoiseandOutliers">
<title>Noise and Outliers</title>
<para>A large amount of noise inevitably impacts on the reconstruction (see <ref refid="index_1fig__Poisson_surface_reconstruction_3fignoise" kindref="member">fig__Poisson_surface_reconstruction_3fignoise</ref>, top) and the current implementation does not provide any mean to trade data fitting for smoothness. Nevertheless if the signal-to-noise ratio is sufficiently high and/or the surface approximation and sizing parameters set for contouring the iso-surface is large with respect to the noise level the output surface mesh will appear smooth (not shown). If the user wants to produce a smooth and detailed output surface mesh, we recommend to apply smoothing through <computeroutput><ref refid="group__PkgPointSetProcessing3Algorithms_1ga96a3738be3b2b9bd1587af78ae10e67a" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">jet_smooth_point_set()</ref></computeroutput> (see <ref refid="index_1fig__Poisson_surface_reconstruction_3fignoise" kindref="member">fig__Poisson_surface_reconstruction_3fignoise</ref>, bottom).</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3fignoise"/> <image type="html" name="noise.jpg"></image>
 <image type="latex" name="noise.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3fignoise" kindref="member">fig__Poisson_surface_reconstruction_3fignoise</ref> Top-left: points sampled on a sphere and corrupted with a lot of noise. Top-right: reconstructed surface mesh. Bottom-left: smoothed point set. Bottom-right: reconstructed surface mesh. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>For a large number of outliers the failure cases (not shown) translate into spurious small connected components and massive distortion near the inferred surface. In this case the outliers must be removed through <computeroutput><ref refid="group__PkgPointSetProcessing3Algorithms_1ga50c708584a8219847ce04f636dcad4b3" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">remove_outliers()</ref></computeroutput>.</para>
</sect2>
<sect2 id="index_1Poisson_surface_reconstruction_3SharpCreases">
<title>Sharp Creases</title>
<para>The current reconstruction algorithm is not able to recover the sharp creases and corners present in the inferred surface. This translates into smoothed sharp creases.</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3figsharp_features"/> <image type="html" name="sharp_features.jpg"></image>
 <image type="latex" name="sharp_features.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3figsharp_features" kindref="member">fig__Poisson_surface_reconstruction_3figsharp_features</ref> Left: 5K points sampled on a mechanical piece with sharp features (creases, darts and corners). Right: reconstructed surface mesh with smoothed creases. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="index_1SurfReconstPerformances">
<title>Performances</title>
<para>We provide some performance numbers for scanning data. We measure the Poisson implicit function computation time, the contouring time for a range of approximation distances, the memory occupancy as well as the influence of the point set simplification. The machine used is a PC running Windows 7 64 bits with an Intel CPU Core 2 Duo processor clocked at 2.81 GHz and with 8 GB of RAM. The software is compiled with Visual C++ 2010 (VC9) compiler with the 03 option which maximizes speed. All measurements were done using the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library.</para>
<sect2 id="index_1SurfReconstPerfPIF">
<title>Poisson Implicit Function</title>
<para>The point set chosen for benchmarking the Poisson implicit function is the Bimba con Nastrino point set (1.6 million points) depicted by <ref refid="index_1fig__Poisson_surface_reconstruction_3-fig-contouring_bench" kindref="member">fig__Poisson_surface_reconstruction_3-fig-contouring_bench</ref>. We measure the Poisson implicit function computation (i.e., the call to <computeroutput><ref refid="classCGAL_1_1Poisson__reconstruction__function_1a5b01f27b151690449f33c9eb421f7c97" kindref="member">Poisson_reconstruction_function::compute_implicit_function()</ref></computeroutput> denoted by Poisson solve hereafter) for this point set as well as for simplified versions obtained through random simplification. The following table provides Poisson solve computation times in seconds for an increasing number of points.</para>
<para><table rows="10" cols="2"><row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para></para>
<para>Number of points (x1000) </para>
</entry><entry thead="no" class="math" align="center"><para>Poisson solve duration (in s) </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>60 </para>
</entry><entry thead="no" class="math" align="center"><para>15 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>100 </para>
</entry><entry thead="no" class="math" align="center"><para>25 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>250 </para>
</entry><entry thead="no" class="math" align="center"><para>96 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>500 </para>
</entry><entry thead="no" class="math" align="center"><para>150 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,000 </para>
</entry><entry thead="no" class="math" align="center"><para>249 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,800 </para>
</entry><entry thead="no" class="math" align="center"><para>478 </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="index_1SurfReconstPerfCont">
<title>Contouring</title>
<para>The point set chosen for benchmarking the contouring stage is the Bimba con Nastrino point set simplified to 100k points. We measure the contouring (i.e. the call to <computeroutput>make_surface_mesh()</computeroutput>) duration and the reconstruction error for a range of approximation distances. The reconstruction error is expressed as the average distance from input points to the reconstructed surface in mm (the Bimba con Nastrino statue is 324 mm tall).</para>
<para><table rows="9" cols="3"><row>
<entry thead="no" align="left" colspan="3"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>Approx. distance (*average spacing) </para>
</entry><entry thead="no" class="math" align="center"><para>Contouring duration (in s) </para>
</entry><entry thead="no" class="math" align="center"><para>Reconstruction error (mm) </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="3"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>0.1 </para>
</entry><entry thead="no" class="math" align="center"><para>19.2 </para>
</entry><entry thead="no" class="math" align="center"><para>0.055 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>0.25 </para>
</entry><entry thead="no" class="math" align="center"><para>6.9 </para>
</entry><entry thead="no" class="math" align="center"><para>0.106 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>0.5 </para>
</entry><entry thead="no" class="math" align="center"><para>3.2 </para>
</entry><entry thead="no" class="math" align="center"><para>0.18 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1 </para>
</entry><entry thead="no" class="math" align="center"><para>1.65 </para>
</entry><entry thead="no" class="math" align="center"><para>0.36 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>2 </para>
</entry><entry thead="no" class="math" align="center"><para>0.8 </para>
</entry><entry thead="no" class="math" align="center"><para>0.76 </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="3"><para><hruler/>
 </para>
</entry></row>
</table>
</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3-fig-contouring_bench"/> <image type="html" name="contouring_bench.jpg"></image>
 <image type="latex" name="contouring_bench.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3-fig-contouring_bench" kindref="member">fig__Poisson_surface_reconstruction_3-fig-contouring_bench</ref> Contouring duration (in s) and reconstruction error (mm) against several approximation distance parameters for the Bimba con Nastrino point set simplified to 100k points. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1SurfReconstPerfMem">
<title>Memory</title>
<para>We measure the memory occupancy for the reconstruction of the full Bimba con Nastrino point set (1.8 millions points) as well as for simplified versions.<linebreak/>
The Poisson implicit function computation has a memory peak when solving the Poisson linear system using the sparse linear solver.</para>
<para><table rows="10" cols="2"><row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>Number of points (x1000) </para>
</entry><entry thead="no" class="math" align="center"><para>Memory occupancy (MBytes) </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>60 </para>
</entry><entry thead="no" class="math" align="center"><para>180 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>100 </para>
</entry><entry thead="no" class="math" align="center"><para>270 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>250 </para>
</entry><entry thead="no" class="math" align="center"><para>790 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>500 </para>
</entry><entry thead="no" class="math" align="center"><para>1300 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,000 </para>
</entry><entry thead="no" class="math" align="center"><para>2200 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,800 </para>
</entry><entry thead="no" class="math" align="center"><para>3800 </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="index_1SurfReconstPerfPSS">
<title>Point Set Simplification</title>
<para>Due to the memory limitations described above, we recommend to simplify the point sets captured by laser scanners.<linebreak/>
We measure the reconstruction error for the Bimba con Nastrino point set (1.6M points) as well as for simplified versions. All reconstructions use the recommended contouring parameter <computeroutput>approximation distance = 0.25 * the input point</computeroutput> set&apos;s average spacing. The reconstruction error is expressed as the average distance from input points to the reconstructed surface in mm (the Bimba con Nastrino statue is 324 mm tall).</para>
<para><table rows="11" cols="2"><row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>Number of points (x1000) </para>
</entry><entry thead="no" class="math" align="center"><para>Reconstruction error (mm) </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>60 </para>
</entry><entry thead="no" class="math" align="center"><para>0.27 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>120 </para>
</entry><entry thead="no" class="math" align="center"><para>0.15 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>250 </para>
</entry><entry thead="no" class="math" align="center"><para>0.11 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>500 </para>
</entry><entry thead="no" class="math" align="center"><para>0.079 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,000 </para>
</entry><entry thead="no" class="math" align="center"><para>0.066 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,500 </para>
</entry><entry thead="no" class="math" align="center"><para>0.061 </para>
</entry></row>
<row>
<entry thead="no" class="math" align="center"><para>1,600 </para>
</entry><entry thead="no" class="math" align="center"><para>0.06 </para>
</entry></row>
<row>
<entry thead="no" align="left" colspan="2"><para><hruler/>
 </para>
</entry></row>
</table>
</para>
<para><anchor id="index_1fig__Poisson_surface_reconstruction_3-fig-simplification_bench"/> <image type="html" name="simplification_bench.jpg"></image>
 <image type="latex" name="simplification_bench.jpg" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Poisson_surface_reconstruction_3-fig-simplification_bench" kindref="member">fig__Poisson_surface_reconstruction_3-fig-simplification_bench</ref> Reconstruction error (mm) against number of points for the Bimba con Nastrino point set with 1.6M points as well as for simplified versions. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="index_1SurfReconstDesignHistory">
<title>Design and Implementation History</title>
<para>The initial implementation was essentially done by Laurent Saboret, guided by Pierre Alliez and Ga"el Guennebaud. For later releases of the package Andreas Fabri worked on performance improvements, and Laurent Rineau added the two passes for dealing with holes. </para>
</sect1>
    </detaileddescription>
    <location file="Poisson_surface_reconstruction_3.txt"/>
  </compounddef>
</doxygen>
