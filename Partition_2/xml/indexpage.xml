<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Polygon_Partitioning"/><anchor id="index_1chappolygonpartition"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="author"><para>Susan Hert</para>
</simplesect>
</para>
<sect1 id="index_1secpartition_2_intro">
<title>Introduction</title>
<para>A <emphasis>partition</emphasis> of a polygon <formula id="27">$ P$</formula> is a set of polygons such that the interiors of the polygons do not intersect and the union of the polygons is equal to the interior of the original polygon <formula id="27">$ P$</formula>. This chapter describes functions for partitioning planar polygons into two types of subpolygons - <formula id="0">$ y$</formula>-monotone polygons and convex polygons. The partitions are produced without introducing new (Steiner) vertices.</para>
<para>All the partitioning functions present the same interface to the user. That is, the user provides a pair of input iterators, <computeroutput>first</computeroutput> and <computeroutput>beyond</computeroutput>, an output iterator <computeroutput>result</computeroutput>, and a traits class <computeroutput>traits</computeroutput>. The points in the range [<computeroutput>first</computeroutput>, <computeroutput>beyond</computeroutput>) are assumed to define a simple polygon whose vertices are in counterclockwise order. The computed partition polygons, whose vertices are also oriented counterclockwise, are written to the sequence starting at position <computeroutput>result</computeroutput> and the past-the-end iterator for the resulting sequence of polygons is returned. The traits classes for the functions specify the types of the input points and output polygons as well as a few other types and function objects that are required by the various algorithms.</para>
</sect1>
<sect1 id="index_1secpartition_2_monotone">
<title>Monotone Partitioning</title>
<para>A <emphasis> <formula id="0">$ y$</formula>-monotone polygon</emphasis> is a polygon whose vertices <formula id="28">$ v_1, \ldots, v_n$</formula> can be divided into two chains <formula id="29">$ v_1, \ldots, v_k$</formula> and <formula id="30">$ v_k, \ldots, v_n, v_1$</formula>, such that any horizontal line intersects either chain at most once. For producing a <formula id="0">$ y$</formula>-monotone partition of a given polygon, the sweep-line algorithm presented in <ref refid="citelist_1CITEREF_bkos-cgaa-97" kindref="member">[1]</ref> is implemented by the function <computeroutput><ref refid="group__PkgPartition2Ref_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput>. This algorithm runs in <formula id="3">$O(n \log n)$</formula> time and requires <formula id="1">$O(n)$</formula> space. This algorithm does not guarantee a bound on the number of polygons produced with respect to the optimal number.</para>
<para>For checking the validity of the partitions produced by <computeroutput><ref refid="group__PkgPartition2Ref_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput>, we provide a function <computeroutput><ref refid="group__PkgPartition2Ref_1gae795b8beb8626322c448706e20a8ac9b" kindref="member">is_y_monotone_2()</ref></computeroutput>, which determines if a sequence of points in 2D defines a <formula id="0">$ y$</formula>-monotone polygon or not. For examples of the use of these functions, see the corresponding reference pages.</para>
</sect1>
<sect1 id="index_1secpartition_2_convex">
<title>Convex Partitioning</title>
<para>Three functions are provided for producing convex partitions of polygons. One produces a partition that is optimal in the number of pieces. The other two functions produce approximately optimal convex partitions. Both these functions produce convex decompositions by first decomposing the polygon into simpler polygons; the first uses a triangulation and the second a monotone partition. These two functions both guarantee that they will produce no more than four times the optimal number of convex pieces but they differ in their runtime complexities. Though the triangulation-based approximation algorithm often results in fewer convex pieces, this is not always the case.</para>
<para><anchor id="index_1fig__P2_approxvsopti"/> <image type="html" name="approximate_optimal_vs_optimal.png"></image>
 <image type="latex" name="approximate_optimal_vs_optimal.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__P2_approxvsopti" kindref="member">fig__P2_approxvsopti</ref> Examples of an approximate optimal convex partition (left) and an optimal convex partition (right). <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>An optimal convex partition can be produced using the function <computeroutput><ref refid="group__PkgPartition2Ref_1ga3ca9fb1f363f9f792bfbbeca65ad5cc5" kindref="member">optimal_convex_partition_2()</ref></computeroutput>.</para>
<para>This function provides an implementation of Greene&apos;s dynamic programming algorithm for optimal partitioning <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref>. This algorithm requires <formula id="4">$O(n^4)$</formula> time and <formula id="5">$O(n^3)$</formula> space in the worst case.</para>
<para>The function <computeroutput><ref refid="group__PkgPartition2Ref_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">approx_convex_partition_2()</ref></computeroutput> implements the simple approximation algorithm of Hertel and Mehlhorn <ref refid="citelist_1CITEREF_hm-ftsp-83" kindref="member">[3]</ref> that produces a convex partitioning of a polygon from a triangulation by throwing out unnecessary triangulation edges. The triangulation used in this function is one produced by the 2-dimensional constrained triangulation package of CGAL. For a given triangulation, this convex partitioning algorithm requires <formula id="1">$O(n)$</formula> time and space to construct a decomposition into no more than four times the optimal number of convex pieces.</para>
<para>The sweep-line approximation algorithm of Greene <ref refid="citelist_1CITEREF_g-dpcp-83" kindref="member">[2]</ref>, which, given a monotone partition of a polygon, produces a convex partition in <formula id="3">$O(n \log n)$</formula> time and <formula id="1">$O(n)$</formula> space, is implemented by the function <computeroutput><ref refid="group__PkgPartition2Ref_1ga68139e1ee98dffa8f72cb295881f4647" kindref="member">greene_approx_convex_partition_2()</ref></computeroutput>. The function <computeroutput><ref refid="group__PkgPartition2Ref_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">y_monotone_partition_2()</ref></computeroutput> described in Section <ref refid="index_1secpartition_2_monotone" kindref="member">Monotone Partitioning</ref> is used to produce the monotone partition. This algorithm provides the same worst-case approximation guarantee as the algorithm of Hertel and Mehlhorn implemented with <computeroutput><ref refid="group__PkgPartition2Ref_1gab9cf8c2b097fd562da09dd23d0c74edf" kindref="member">approx_convex_partition_2()</ref></computeroutput> but can sometimes produce better results (i.e., convex partitions with fewer pieces).</para>
</sect1>
<sect1 id="index_1secpartition_2_examples">
<title>Examples</title>
<para>Examples of the uses of all of the above partition functions are provided with the corresponding reference pages.</para>
<para>In the following we illustrate how to use a property map to enable the trais class to deal with polygons where the vertices are not points. In the example the points are in a vector and the polygons are sequences of indices.</para>
<para>The class <computeroutput>Partition_2</computeroutput> has two template parameters, namely a geometric traits class, and a property map to obtain points, in the example by accessing <computeroutput>points[i]</computeroutput> for the polygon vertex <computeroutput>i</computeroutput>, and it then performs the predicates required by the concept <computeroutput><ref refid="classPartitionTraits__2" kindref="compound">PartitionTraits_2</ref></computeroutput> on these points.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Partition_2_2y_monotone_partition_indices_2_8cpp-example" kindref="compound">Partition_2/y_monotone_partition_indices_2.cpp</ref> <programlisting filename="Partition_2/y_monotone_partition_indices_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/partition_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Partition_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">CGAL::Partition_traits_2&lt;K, CGAL::Pointer_property_map&lt;K::Point_2&gt;::type</ref><sp/>&gt;<sp/><ref refid="classCGAL_1_1Partition__traits__2" kindref="compound">Partition_traits_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Partition__traits__2_1a62c198d9da3e45f8bcbbcd0176289d82" kindref="member">Partition_traits_2::Point_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Polygon.tag">Partition_traits_2::Polygon_2</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Polygon__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Polygon.tag">Polygon_2</ref>;<sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>polygon<sp/>of<sp/>indices</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::list&lt;Polygon_2&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_list;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>v4<sp/><sp/><sp/><sp/><sp/>v2</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>\<sp/><sp/><sp/>/|</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>\<sp/>/<sp/>|</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>v3<sp/><sp/>|</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>v0-----v1</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;K::Point_2&gt;<sp/>points<sp/>=<sp/>{<sp/>K::Point_2(0,0),<sp/>K::Point_2(2,0),<sp/>K::Point_2(2,2),<sp/>K::Point_2(1,1),<sp/>K::Point_2(0,2)<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Partition_traits_2<sp/>traits(CGAL::make_property_map(points));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon.push_back(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon.push_back(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon.push_back(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon.push_back(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>polygon.push_back(4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_list<sp/>partition_polys;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgPartition2Ref_1ga35cdd9f604522c2ce4ca97d928a41f38" kindref="member">CGAL::y_monotone_partition_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(partition_polys),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Polygon_2&amp;<sp/>poly<sp/>:<sp/>partition_polys){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(Point_2<sp/>p<sp/>:<sp/>poly.container()){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;points[&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>=<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>points[p]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>assert(<ref refid="group__PkgPartition2Ref_1gaa4c7b5c06a64608fca50ddb2af49d498" kindref="member">CGAL::partition_is_valid_2</ref>(polygon.vertices_begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polygon.vertices_end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.begin(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_polys.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>In a similar way, the use of an appropriate property map enables to partition faces of a polygonal mesh, or to access points which are a component of a <computeroutput>std::tuple</computeroutput>.</para>
</sect1>
<sect1 id="index_1secpartition_2_history">
<title>Implementation History</title>
<para>This package has originally been written by Susan Hert while working at the Max-Planck Institute for Infomatics in Germany. The algorithms have been made free of constructions, and the property map has been added by GeometryFactory for CGAL 5.0. </para>
</sect1>
    </detaileddescription>
    <location file="Partition_2.txt"/>
  </compounddef>
</doxygen>
