<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_2D_Periodic_Hyperbolic_Triangulations"/><anchor id="index_1chapterP4HTriangulation2"/> <htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="author"><para>Iordan Iordanov and Monique Teillaud</para>
</simplesect>
<center> <image type="html" name="new-triangulation-350px.png" inline="yes"></image>
 </center></para>
<para>This package enables the computation of Delaunay triangulations of the Bolza surface, which is the most symmetric surface of genus 2. The Bolza surface is a hyperbolic closed compact orientable surface.</para>
<para>A triangulation of the Bolza surface can be seen as a periodic triangulation of the hyperbolic plane.</para>
<sect1 id="index_1P4HT2_thespace">
<title>The Bolza Surface</title>
<para>Let <formula id="31">$\mathbb{H}^2$</formula> denote the hyperbolic plane, represented in the Poincaré disk model (see Chapter <ref refid="index_1ChapterHTriangulation2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Hyperbolic_triangulation_2.tag">2D Hyperbolic Delaunay Triangulations</ref>). The Bolza surface <formula id="32">$\mathcal{M}$</formula> is defined as the quotient of <formula id="3">$\mathbb H^2$</formula> under the action of a group <formula id="2">$\mathcal G$</formula> that we will introduce now.</para>
<para>Consider the regular hyperbolic octagon <formula id="33">$ \mathcal D_O $</formula> centered at the origin with all angles equal to <formula id="34">$ \pi/4$</formula>, as shown in <ref refid="index_1fig__P4HTriangulationOctagonId" kindref="member">fig__P4HTriangulationOctagonId</ref>. Note that <formula id="14">$\mathcal D_O$</formula> is unique up to rotation and cannot be scaled since this operation would change its angles. Consider the four hyperbolic translations <formula id="35">$ a,b,c,d$</formula> with their respective inverses <formula id="36">$\overline{a},
\overline{b}, \overline{c}, \overline{d}$</formula> that identify the opposite sides of <formula id="33">$ \mathcal D_O $</formula>. The axes of these translations, shown in <ref refid="index_1fig__P4HTriangulationOctagonId" kindref="member">fig__P4HTriangulationOctagonId</ref> - Left, are diameters of the Poincaré disk. The four translations <formula id="37">$a, b, c, d$</formula> generate a (non-commutative) discrete group of orientation-preserving isometries, with finite presentation  <formula id="38">\[ \mathcal{G} = \left&lt; a,b,c,d \; \bigg| \;
    abcd\overline{a}\overline{b}\overline{c}\overline{d} \right&gt;. \]</formula> Note that equivalent translations of the group <formula id="2">$\mathcal G$</formula> can be reduced to a unique minimal representative.</para>
<para>The group <formula id="2">$\mathcal G$</formula> is acting on <formula id="3">$\mathbb H^2$</formula>: two points <formula id="39">$p$</formula> and <formula id="40">$q$</formula> in <formula id="3">$\mathbb H^2$</formula> are in the same orbit under the action of <formula id="2">$\mathcal G$</formula> if there exists an element <formula id="41">$g \in \mathcal G$</formula> such that <formula id="42">$g(p) = q$</formula>, as shown in <ref refid="index_1fig__P4HTriangulationOctagonId" kindref="member">fig__P4HTriangulationOctagonId</ref> - Center. The Bolza surface <formula id="32">$\mathcal{M}$</formula> is defined as the quotient of <formula id="3">$\mathbb H^2$</formula> under the action of <formula id="2">$\mathcal G$</formula>, named the fundamental group of <formula id="0">$\mathcal M$</formula>: <formula id="43">\[ \mathcal{M} = \mathbb H^2 / \mathcal{G}. \]</formula> The natural projection map from <formula id="3">$\mathbb H^2$</formula> onto <formula id="0">$\mathcal M$</formula> is denoted with <formula id="44">$\pi$</formula>. By definition, all points of <formula id="3">$\mathbb H^2$</formula> that belong to the same orbit under the action of <formula id="2">$\mathcal G$</formula> project by <formula id="44">$\pi$</formula> onto the same point of the surface <formula id="0">$\mathcal M$</formula>.</para>
<para><anchor id="index_1fig__P4HTriangulationOctagonId"/><center> <image type="html" name="octagon_identification.svg" inline="yes"></image>
 <image type="html" name="periodicity.png" inline="yes"></image>
 <image type="html" name="original_domain.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HTriangulationOctagonId" kindref="member">fig__P4HTriangulationOctagonId</ref> <bold>Left:</bold> The hyperbolic translations <formula id="45">$a,b,c,d$</formula> and their inverses identify opposite sides of the octagon <formula id="14">$\mathcal D_O$</formula>. <bold>Center:</bold> Illustration of periodicity in the hyperbolic plane. The figure shows a few periodic copies of the points in the central octagon. <bold>Right:</bold> The half-open octagon <formula id="46">$\mathcal D$</formula> is an original domain for <formula id="32">$\mathcal{M}$</formula>. Note that only one vertex of the octagon is contained in the original domain. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The half-open octagon <formula id="46">$\mathcal D$</formula> shown in <ref refid="index_1fig__P4HTriangulationOctagonId" kindref="member">fig__P4HTriangulationOctagonId</ref> - Right contains exactly one <emphasis>representative</emphasis> of each point of <formula id="32">$\mathcal{M}$</formula>; <formula id="46">$\mathcal D$</formula> is called the <emphasis>original domain</emphasis> of <formula id="32">$\mathcal{M}$</formula>. A point outside <formula id="46">$\mathcal D$</formula> is the image of a point in <formula id="46">$\mathcal D$</formula>, its representative, under the action of a uniquely defined translation in the group <formula id="47">$\mathcal{G}$</formula>.</para>
<para><ref refid="index_1fig__P4HTDoubleTorusConstruction" kindref="member">fig__P4HTDoubleTorusConstruction</ref> illustrates how a genus-2 surface can be obtained by identifying opposite sides of <formula id="48">$\mathcal
D$</formula> under the action of <formula id="2">$\mathcal G$</formula>.</para>
<para><anchor id="index_1fig__P4HTDoubleTorusConstruction"/><center> <image type="html" name="dt-construction.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HTDoubleTorusConstruction" kindref="member">fig__P4HTDoubleTorusConstruction</ref> Topological construction of a genus-2 surface from the original domain <formula id="46">$\mathcal D$</formula> of the Bolza surface. Each open side is paired with the opposite closed side. Note that all vertices of the octagon project to the same point on the surface, which is represented uniquely by the only vertex of <formula id="46">$\mathcal D$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1P4HT2_representation">
<title>Representation</title>
<para>In the following, and when there is no risk of confusion, the same notation will be used for a point on the surface <formula id="0">$\mathcal M$</formula> and its representative in <formula id="48">$\mathcal
D$</formula>. Similarly, <formula id="49">$\mathcal{P}$</formula> will denote both a set of points on the surface and the set of their representatives in <formula id="46">$\mathcal D$</formula>.</para>
<para>We require that all input points lie inside <formula id="46">$\mathcal D$</formula>.</para>
<sect2 id="index_1P4HT2_Data_structure">
<title>Data Structure</title>
<para>The Delaunay triangulation of <formula id="32">$\mathcal{M}$</formula> defined by a point set <formula id="49">$\mathcal{P}$</formula> is the projection by <formula id="44">$\pi$</formula> of the Delaunay triangulation in the plane <formula id="3">$\mathbb H^2$</formula> of the (infinite) set of points <formula id="50">$\mathcal{G P}$</formula> onto <formula id="32">$\mathcal{M}$</formula>, provided that some <emphasis>condition</emphasis> (detailed in Section <ref refid="index_1P4HT2_Embedding_condition" kindref="member">Simplicial Embedding Condition</ref> below) holds. More details can be found in <ref refid="citelist_1CITEREF_cgal:btv-dtosl-16" kindref="member">[1]</ref>.</para>
<para>As for orbits of points, all faces of the Delaunay triangulation of <formula id="50">$\mathcal{G P}$</formula> that are in the same orbit under the action of <formula id="47">$\mathcal{G}$</formula> project by <formula id="44">$\pi$</formula> onto the same face on the surface <formula id="32">$\mathcal{M}$</formula>. We can define a unique <emphasis>canonical</emphasis> representative for each orbit, which has at least one vertex in <formula id="46">$\mathcal D$</formula>. Some canonical faces have vertices both inside and outside <formula id="46">$\mathcal D$</formula>; such faces can be uniquely specified by three pairs of points in <formula id="46">$\mathcal D$</formula> and reduced translations of <formula id="47">$\mathcal{G}$</formula> (points in the original domain are paired with the identity translation <formula id="51">$\mathbb 1)$</formula>. The underlying combinatorial triangulation is a <ref refid="packages_1PkgTDS2" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">2D Triangulation Data Structure</ref> enriched in each face by the three translations that are paired with the point in each vertex of the canonical representative (see<nonbreakablespace/><ref refid="index_1fig__P4HTriangulationOrientationDS" kindref="member">fig__P4HTriangulationOrientationDS</ref>).</para>
<para><anchor id="index_1fig__P4HTriangulationOrientationDS"/><center> <image type="html" name="ds_cgal.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HTriangulationOrientationDS" kindref="member">fig__P4HTriangulationOrientationDS</ref> Representation of a face <formula id="52">$f$</formula> stored in the triangulation data structure. Each vertex <formula id="53">$v_i$</formula> stores a point <formula id="54">$p_i$</formula> paired with a translation <formula id="55">$\tau_i$</formula>. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>More precisely, the translations are elements of the subset <formula id="56">$\mathcal N$</formula> of <formula id="2">$\mathcal G$</formula> for which the image of <formula id="14">$\mathcal D_O$</formula> has at least one vertex in common with <formula id="14">$\mathcal D_O$</formula>. These images of <formula id="14">$\mathcal D_O$</formula> by translations in <formula id="56">$\mathcal N$</formula> are shaded in <ref refid="index_1fig__P4HTriangulationCanonicalRepExample" kindref="member">fig__P4HTriangulationCanonicalRepExample</ref>; we consider them to be ordered counterclockwise around <formula id="14">$\mathcal D_O$</formula>, arbitrarily starting with the one corresponding to translation <formula id="17">$abcd$</formula>. The canonical representative in <formula id="3">$\mathbb H^2$</formula> of a face on <formula id="0">$\mathcal M$</formula> is such that <itemizedlist>
<listitem>
<para>either all vertices of the representative lie in <formula id="46">$\mathcal D$</formula>, or </para>
</listitem>
<listitem>
<para>at least one of the vertices of the representative lies in <formula id="46">$\mathcal D$</formula> and is as close as possible to <formula id="17">$abcd$</formula> in the ordering defined above. </para>
</listitem>
</itemizedlist>
</para>
<para><anchor id="index_1fig__P4HTriangulationCanonicalRepExample"/><center> <image type="html" name="periodic_face.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HTriangulationCanonicalRepExample" kindref="member">fig__P4HTriangulationCanonicalRepExample</ref> Among the three faces in the orbit that have at least one vertex in <formula id="46">$\mathcal D$</formula>, the canonical representative is the green one: it is closest, in the counterclockwise order, to the region labeled <formula id="17">$abcd$</formula>. The translations <formula id="57">$\mathbb 1, a,$</formula> and <formula id="18">$\overline{b}$</formula>, corresponding to the points <formula id="58">$p, q$</formula>, and <formula id="59">$r$</formula> are stored in the face in the data structure. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
<sect2 id="index_1P4HT2_Embedding_condition">
<title>Simplicial Embedding Condition</title>
<para>Let us now give details on the <emphasis>condition</emphasis> mentioned above. The projection by <formula id="44">$\pi$</formula> of the Delaunay triangulation in <formula id="3">$\mathbb H^2$</formula> of <formula id="50">$\mathcal{G P}$</formula> is a <emphasis>triangulation</emphasis> of <formula id="32">$\mathcal{M}$</formula> if and only if its combinatorial graph does not contain loops (i.e., edges having two identical vertices) or double edges (i.e., two edges sharing the same two vertices), or, equivalently, if the projection is a simplicial complex: <itemizedlist>
<listitem>
<para>any face of a simplex is a simplex, and </para>
</listitem>
<listitem>
<para>two simplices either do not intersect or share one common face.  </para>
</listitem>
</itemizedlist>
</para>
<para>Some point sets do not define a triangulation of <formula id="0">$\mathcal M$</formula>. For instance, a single point does not define a triangulation of <formula id="0">$\mathcal M$</formula>, as all edges of the induced subdivision would be loops. Another example is shown in <ref refid="index_1fig__P4HNonSimplicialExample" kindref="member">fig__P4HNonSimplicialExample</ref>.</para>
<para><anchor id="index_1fig__P4HNonSimplicialExample"/><center> <image type="html" name="non-triangulation.svg" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HNonSimplicialExample" kindref="member">fig__P4HNonSimplicialExample</ref> The three points in the central octagon define a non-simplicial subdivision of the Bolza surface. The pink edge between the two blue vertices corresponds to a loop on the surface. The two blue edges correspond to a double edge on the surface; the two green edges, too. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>We initialize a triangulation of <formula id="0">$\mathcal M$</formula> with a predetermined set <formula id="60">$\mathcal Q$</formula> of 14 points, called <emphasis>dummy points</emphasis> (see <ref refid="index_1fig__P4HTriangulationDummyPoints" kindref="member">fig__P4HTriangulationDummyPoints</ref>), which ensures that the projection by <formula id="44">$\pi$</formula> of the Delaunay triangulation of <formula id="61">$\mathcal{G}
(\mathcal{P}\cup\mathcal{Q})$</formula> onto <formula id="0">$\mathcal M$</formula> is a simplicial complex for any set of input points <formula id="49">$\mathcal{P}$</formula> <ref refid="citelist_1CITEREF_cgal:btv-dtosl-16" kindref="member">[1]</ref>.</para>
<para><anchor id="index_1fig__P4HTriangulationDummyPoints"/><center> <image type="html" name="dummy-points.png" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HTriangulationDummyPoints" kindref="member">fig__P4HTriangulationDummyPoints</ref> Delaunay triangulation of <formula id="0">$\mathcal M$</formula> defined by the 14 dummy points. The set <formula id="60">$\mathcal Q$</formula> of dummy points contains the origin, the vertex of <formula id="46">$\mathcal D$</formula>, the midpoints of the closed sides of <formula id="46">$\mathcal D$</formula>, and the (hyperbolic) midpoints of the segments between the origin and the vertices of the octagon. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>If sufficiently many well-distributed points are inserted, the dummy points become unnecessary, i.e., the subdivision remains a simplicial complex even if we remove them. Otherwise some dummy points are left to ensure that the final subdivision is a simplicial complex.</para>
</sect2>
</sect1>
<sect1 id="index_1P4HT2_design">
<title>Software Design</title>
<para>The main class of this package is <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__2" kindref="compound">Periodic_4_hyperbolic_Delaunay_triangulation_2</ref></computeroutput>, which implements Delaunay triangulations of the Bolza surface <formula id="0">$\mathcal M$</formula>. The prefix &quot;Periodic_4&quot; emphasizes that the triangulation in the universal covering <formula id="3">$\mathbb H^2$</formula> is periodic in the four directions defined by the hyperbolic translations <formula id="62">$ a,b,c$</formula>, and <formula id="24">$d$</formula>.</para>
<para>The implementation is fully dynamic, supporting both point insertion and vertex removal. However, a vertex can be removed only if the subdivision remains a simplicial complex.</para>
<para>The class <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__2" kindref="compound">Periodic_4_hyperbolic_Delaunay_triangulation_2</ref></computeroutput> provides high-level geometric functionality specific to Delaunay triangulations, such as point insertion and vertex removal, the side-of-circle test, finding the conflicting region of a given point, and dual functions. It inherits from a base class, <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__triangulation__2" kindref="compound">Periodic_4_hyperbolic_triangulation_2</ref></computeroutput>, which provides functionality common to triangulations in general, such as point location <ref refid="citelist_1CITEREF_cgal:dpt-wt-02" kindref="member">[2]</ref>, and access functions, but supports neither point insertion nor vertex removal.</para>
<para>Both classes <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__triangulation__2" kindref="compound">Periodic_4_hyperbolic_triangulation_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__2" kindref="compound">Periodic_4_hyperbolic_Delaunay_triangulation_2</ref></computeroutput> have two template parameters that reflect the separation between the geometric and combinatorial structures of the triangulation:</para>
<para><itemizedlist>
<listitem><para>a <bold>geometric traits</bold> class, which provides all objects, predicates, and constructions that are necessary for the computation of Delaunay triangulations of the Bolza surface (see Section <ref refid="index_1P4HT2_traits" kindref="member">The Geometric Traits Parameter</ref>).</para>
</listitem><listitem><para>a <bold>triangulation data structure</bold> class, which encodes the combinatorial structure of the triangulation (see Section <ref refid="index_1P4HT2_datastructure" kindref="member">The Triangulation Data Structure Parameter</ref>).</para>
</listitem></itemizedlist>
</para>
<sect2 id="index_1P4HT2_traits">
<title>The Geometric Traits Parameter</title>
<para>The geometric traits class must fulfill the requirements described in the concept <computeroutput><ref refid="classPeriodic__4HyperbolicDelaunayTriangulationTraits__2" kindref="compound">Periodic_4HyperbolicDelaunayTriangulationTraits_2</ref></computeroutput>. Moreover, the traits class must represent hyperbolic translations of the group <formula id="2">$\mathcal G$</formula> via the class <computeroutput><ref refid="classCGAL_1_1Hyperbolic__octagon__translation" kindref="compound">Hyperbolic_octagon_translation</ref></computeroutput>.</para>
<para>A model for the concept <computeroutput><ref refid="classPeriodic__4HyperbolicDelaunayTriangulationTraits__2" kindref="compound">Periodic_4HyperbolicDelaunayTriangulationTraits_2</ref></computeroutput> offered by this package is the class <computeroutput><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">Periodic_4_hyperbolic_Delaunay_triangulation_traits_2</ref></computeroutput>. The class has one template parameter: <itemizedlist>
<listitem>
<para>A <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput> with a field number type <computeroutput>FT</computeroutput> that guarantees exact computations on algebraic numbers with nested square roots. The default value for this parameter is <computeroutput><ref refid="classCGAL_1_1Exact__predicates__exact__constructions__kernel__with__sqrt" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt</ref></computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
</sect2>
<sect2 id="index_1P4HT2_datastructure">
<title>The Triangulation Data Structure Parameter</title>
<para>The triangulation data structure is a container for the faces and vertices and maintains incidence and adjacency relations. This parameter must meet the requirements described in the concept <computeroutput><ref refid="classTriangulationDataStructure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">TriangulationDataStructure_2</ref></computeroutput>, for which CGAL offers the model <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref></computeroutput>. To represent periodic hyperbolic triangulations, the face and vertex of the triangulation data structure must be models of the concepts <computeroutput><ref refid="classPeriodic__4HyperbolicTriangulationFaceBase__2" kindref="compound">Periodic_4HyperbolicTriangulationFaceBase_2</ref></computeroutput> and <computeroutput><ref refid="classPeriodic__4HyperbolicTriangulationVertexBase__2" kindref="compound">Periodic_4HyperbolicTriangulationVertexBase_2</ref></computeroutput>, respectively. The model <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">CGAL::Triangulation_data_structure_2</ref></computeroutput> is parameterized by a vertex base class and a face base class, which gives the possibility to customize the vertices and faces used by the triangulation data structure.</para>
<para>The default value for the triangulation data structure parameter is <computeroutput><ref refid="classCGAL_1_1Triangulation__data__structure__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/TDS_2.tag">Triangulation_data_structure_2</ref>&lt; <ref refid="classCGAL_1_1Periodic__4__hyperbolic__triangulation__vertex__base__2" kindref="compound">Periodic_4_hyperbolic_triangulation_vertex_base_2</ref>&lt;Traits&gt;, <ref refid="classCGAL_1_1Periodic__4__hyperbolic__triangulation__face__base__2" kindref="compound">Periodic_4_hyperbolic_triangulation_face_base_2</ref>&lt;Traits&gt; &gt;</computeroutput>, where <computeroutput>Traits</computeroutput> is a model of <computeroutput><ref refid="classPeriodic__4HyperbolicDelaunayTriangulationTraits__2" kindref="compound">Periodic_4HyperbolicDelaunayTriangulationTraits_2</ref></computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="index_1P4HT2_examples">
<title>Example</title>
<para>Most functionalities of periodic hyperbolic triangulations are similar to those of Euclidean 2D triangulations. We refer the reader to the following two examples of the <ref refid="index_1Chapter_2D_Triangulations" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">2D Triangulation</ref> package: <itemizedlist>
<listitem>
<para><ref refid="index_1Subsection_2D_Triangulations_Voronoi" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">Voronoi Diagram</ref> </para>
</listitem>
<listitem>
<para><ref refid="index_1Triangulation_2AddingColors" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation_2.tag">Adding Colors</ref> </para>
</listitem>
</itemizedlist>
</para>
<para>The example below shows the initialization of a periodic hyperbolic 2D Delaunay triangulation, the insertion of random points uniformly distributed in the unit disk for the Euclidean metric, and the properties of the triangulation after the insertion. It uses the default triangulation data structure.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Periodic_4_hyperbolic_triangulation_2_2p4ht2_example_insertion_8cpp-example" kindref="compound">Periodic_4_hyperbolic_triangulation_2/p4ht2_example_insertion.cpp</ref> <programlisting filename="Periodic_4_hyperbolic_triangulation_2/p4ht2_example_insertion.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Hyperbolic_octagon_translation.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_4_hyperbolic_Delaunay_triangulation_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Periodic_4_hyperbolic_Delaunay_triangulation_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__traits__2" kindref="compound">CGAL::Periodic_4_hyperbolic_Delaunay_triangulation_traits_2&lt;&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Periodic__4__hyperbolic__Delaunay__triangulation__2" kindref="compound">CGAL::Periodic_4_hyperbolic_Delaunay_triangulation_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Triangulation" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation.tag">Triangulation</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation_1a9cce545266f97305c03009e19a9574b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation.tag">Triangulation::Vertex_handle</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vertex_handle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation_1a1b422d984178df24b1802d9ea89a3731" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation.tag">Triangulation::Point</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Triangulation_1ae83c49f5f2f90371376ee0faf469e760" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Triangulation.tag">Triangulation::size_type</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Creator__uniform__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::Creator_uniform_2&lt;NT,Point&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(argc<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;usage:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>argv[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>[number_of_points_to_insert]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Defaulting<sp/>to<sp/>100k<sp/>points...&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>100000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>N<sp/>=<sp/>atoi(argv[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N1<sp/>=<sp/>N/2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N2<sp/>=<sp/>N<sp/>-<sp/>N1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Generate<sp/>N<sp/>random<sp/>points<sp/>uniformly<sp/>distributed<sp/>with<sp/>respect<sp/>to<sp/>the<sp/>Euclidean</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>metric<sp/>in<sp/>the<sp/>disk<sp/>with<sp/>radius<sp/>0.85,<sp/>which<sp/>contains<sp/>the<sp/>fundamental<sp/>domain.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Some<sp/>of<sp/>the<sp/>points<sp/>will<sp/>be<sp/>outside<sp/>the<sp/>octagon,<sp/>so<sp/>they<sp/>will<sp/>not<sp/>be<sp/>inserted.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point&gt;<sp/>pts;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random_points_in_disc_2&lt;Point,Creator&gt;<sp/>g(0.85);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy_n(g,<sp/>N1,<sp/>std::back_inserter(pts));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>triangulation<sp/>is<sp/>automatically<sp/>initialized<sp/>with<sp/>the<sp/>dummy<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Triangulation<sp/>tr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Batch-insert<sp/>new<sp/>points<sp/>in<sp/>the<sp/>triangulation.<sp/>Note<sp/>that<sp/>by<sp/>default,<sp/>after</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>insertion<sp/>of<sp/>a<sp/>set<sp/>of<sp/>points,<sp/>an<sp/>attempt<sp/>is<sp/>made<sp/>to<sp/>remove<sp/>all<sp/>dummy<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>from<sp/>the<sp/>triangulation.<sp/>Note<sp/>the<sp/>third<sp/>boolean<sp/>parameter<sp/>in<sp/>the<sp/>call<sp/>of<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>`insert()`<sp/>function<sp/>which<sp/>suppresses<sp/>the<sp/>automatic<sp/>removal<sp/>of<sp/>dummy<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Batch-inserting<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>random<sp/>points<sp/>in<sp/>the<sp/>triangulation...<sp/>&quot;</highlight><highlight class="normal">;<sp/>std::cout.flush();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_type<sp/>N_batch_inserted<sp/>=<sp/>tr.insert(pts.begin(),<sp/>pts.end(),<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;DONE!<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Insert<sp/>new<sp/>points<sp/>in<sp/>the<sp/>triangulation<sp/>one<sp/>by<sp/>one.<sp/>When<sp/>points<sp/>are<sp/>inserted</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>one<sp/>by<sp/>one,<sp/>dummy<sp/>points<sp/>are<sp/>not<sp/>automatically<sp/>removed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Single-inserting<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N2<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>random<sp/>points<sp/>in<sp/>the<sp/>triangulation...<sp/>&quot;</highlight><highlight class="normal">;<sp/>std::cout.flush();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N_single_inserted<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;N2;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vertex_handle<sp/>vh<sp/>=<sp/>tr.insert(*(++g));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(vh<sp/>!=<sp/>Vertex_handle())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>N_single_inserted++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;DONE!<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Total<sp/>number<sp/>of<sp/>inserted<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>N_inserted<sp/>=<sp/>N_batch_inserted<sp/>+<sp/>N_single_inserted;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Finally,<sp/>we<sp/>try<sp/>to<sp/>manually<sp/>remove<sp/>all<sp/>dummy<sp/>points<sp/>from<sp/>the<sp/>triangulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Cleaning<sp/>dummy<sp/>points<sp/>from<sp/>the<sp/>triangulation...<sp/>&quot;</highlight><highlight class="normal">;<sp/>std::cout.flush();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tr.try_to_remove_dummy_vertices();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;DONE!<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>sure<sp/>that<sp/>the<sp/>triangulation<sp/>is<sp/>valid.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(tr.is_valid());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>NV<sp/>=<sp/>tr.number_of_vertices();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>NF<sp/>=<sp/>tr.number_of_faces();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>NE<sp/>=<sp/>tr.number_of_edges();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>`tr.number_of_dummy_points()`<sp/>returns<sp/>the<sp/>number<sp/>of<sp/>dummy<sp/>points<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>are<sp/>currently<sp/>in<sp/>the<sp/>triangulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NDP<sp/>=<sp/>tr.number_of_dummy_points();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;--------------<sp/>STATS<sp/>--------------&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Random<sp/>points<sp/>generated:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Vertices<sp/>in<sp/>the<sp/>triangulation:<sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>NV<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Dummy<sp/>points<sp/>in<sp/>the<sp/>triangulation:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>NDP<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Random<sp/>points<sp/>inserted:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>N_inserted<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Random<sp/>points<sp/>outside/duplicates:<sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(N<sp/>-<sp/>N_inserted)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;----------<sp/>COMBINATORICS<sp/>----------&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices<sp/>NV:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>NV<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>faces<sp/>NF:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>NF<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>edges<sp/>NE:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>NE<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>number<sp/>of<sp/>vertices<sp/>in<sp/>the<sp/>triangulation<sp/>must<sp/>equal<sp/>the<sp/>number<sp/>of<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>inserted,<sp/>plus<sp/>the<sp/>dummy<sp/>points<sp/>in<sp/>the<sp/>triangulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(N_inserted<sp/>+<sp/>NDP<sp/>==<sp/>NV);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Number<sp/>of<sp/>vertices<sp/>is<sp/>correct!<sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>the<sp/>Euler<sp/>relation<sp/>is<sp/>already<sp/>verified<sp/>by<sp/>the<sp/>function<sp/>`is_valid()`.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert((2<sp/>+<sp/>NE<sp/>-<sp/>NV<sp/>-<sp/>NF)<sp/>/<sp/>2<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Euler<sp/>relation<sp/>verified!<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1P4HT2_Performance">
<title>Performance</title>
<para>We have measured the insertion execution time of our implementation against other CGAL triangulations. Random points, uniformly distributed in the unit disk with respect to the Euclidean metric, are generated. From these generated points, we select 1 million points that lie in the original octagon <formula id="14">$\mathcal D_O$</formula>. We insert the same set of points in three triangulations: <itemizedlist>
<listitem>
<para>a periodic hyperbolic Delaunay triangulation with <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput> as <computeroutput>number type</computeroutput>; </para>
</listitem>
<listitem>
<para>a (non-periodic) Euclidean Delaunay triangulation with <computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput> as <computeroutput>number type</computeroutput>; </para>
</listitem>
<listitem>
<para>a (non-periodic) Euclidean Delaunay triangulation with <computeroutput>double</computeroutput> as <computeroutput>number type</computeroutput>. </para>
</listitem>
</itemizedlist>
We report results averaged over 10 executions of this experiment in <ref refid="index_1Table_1" kindref="member">Table 1</ref> below. The experiments have been executed on two machines: <itemizedlist>
<listitem>
<para><bold>Machine 1:</bold> MacBook Pro (2015), CPU: Intel Core i5 @ 2.9 GHz, RAM: 16 GB @ 1867 MHz, OS: Mac OS X (10.10.5), Compiler: clang-700.1.81; </para>
</listitem>
<listitem>
<para><bold>Machine 2:</bold> Dell Vostro 5471 (2018), CPU: Intel Core i5 @ 1.6 GHZ (up to 3.4 GHz in TurboMode), RAM: 8GB @ 2400 MHz, OS: Linux Mint 19 (kernel 4.15.0), Compiler: gcc version 7.3.0. </para>
</listitem>
</itemizedlist>
</para>
<para><center> <anchor id="index_1Table_1"/><table rows="4" cols="3"><caption>Table 1: Comparison of insertion times of 1 million random points</caption>
<row>
<entry thead="yes"><para>Triangulation type </para>
</entry><entry thead="yes"><para>Machine 1 </para>
</entry><entry thead="yes"><para>Machine 2 </para>
</entry></row>
<row>
<entry thead="no"><para>Periodic hyperbolic (<computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput>)  </para>
</entry><entry thead="no"><para>55 sec. </para>
</entry><entry thead="no"><para>40 sec. </para>
</entry></row>
<row>
<entry thead="no"><para>Non-periodic Euclidean (<computeroutput><ref refid="classCORE_1_1Expr" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">CORE::Expr</ref></computeroutput>) </para>
</entry><entry thead="no"><para>24 sec. </para>
</entry><entry thead="no"><para>20 sec. </para>
</entry></row>
<row>
<entry thead="no"><para>Non-periodic Euclidean (<computeroutput>double</computeroutput>) </para>
</entry><entry thead="no"><para>1 sec. </para>
</entry><entry thead="no"><para>1 sec. </para>
</entry></row>
</table>
</center></para>
<para>Another experiment shows that, on average, all dummy points are removed from the triangulation with the insertion of fewer than 200 random points uniformly distributed in the unit disk with respect to the Euclidean metric. We start with an empty triangulation of the Bolza surface (i.e., initialized with only the dummy points), and we insert random points one by one. After each insertion, the unnecessary dummy points (if any) are removed from the triangulation. As soon as the last dummy point has been removed, we stop the process and record the number of random points inserted. Results are shown in <ref refid="index_1fig__P4HDummyPointsHistogram" kindref="member">fig__P4HDummyPointsHistogram</ref>.</para>
<para><anchor id="index_1fig__P4HDummyPointsHistogram"/><center> <image type="html" name="histogram-dummy-points.png" inline="yes"></image>
 </center> <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly> <ref refid="index_1fig__P4HDummyPointsHistogram" kindref="member">fig__P4HDummyPointsHistogram</ref> Histogram of the number of random input points needed to remove all dummy points in a triangulation of the Bolza surface. The histogram shows results acquired from 1000 executions of the experiment described above. In these 1000 executions, the minimum number of random points needed to remove all dummy points was 23, the maximum 188, and on average 64 random points were needed. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1P4HT2_Design">
<title>Design and Implementation History</title>
<para>This package implements the algorithm for the computation of Delaunay triangulation of the Bolza surface proposed by Mikhail Bogdanov, Monique Teillaud, and Gert Vegter <ref refid="citelist_1CITEREF_cgal:btv-dtosl-16" kindref="member">[1]</ref>. The implementation itself is described by Iordan Iordanov and Monique Teillaud <ref refid="citelist_1CITEREF_cgal:it-idtbs-17" kindref="member">[3]</ref>.</para>
<para>In 2016, Iordanov started working on the 2D Periodic Hyperbolic Triangulations package.</para>
<para>The authors would like to thank their partners from the <ulink url="https://members.loria.fr/Monique.Teillaud/collab/Astonishing/">Astonishing</ulink> and <ulink url="https://members.loria.fr/Monique.Teillaud/collab/SoS/">SoS</ulink> projects for very helpful discussions. </para>
</sect1>
    </detaileddescription>
    <location file="Periodic_4_hyperbolic_triangulation_2.txt"/>
  </compounddef>
</doxygen>
