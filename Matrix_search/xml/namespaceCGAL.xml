<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="classCGAL_1_1Dynamic__matrix" prot="public">CGAL::Dynamic_matrix</innerclass>
    <innerclass refid="classCGAL_1_1Sorted__matrix__search__traits__adaptor" prot="public">CGAL::Sorted_matrix_search_traits_adaptor</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgMatrixSearchRef_1ga46628c80ee99c78f04f1a10c83e71336" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Matrix</type>
          </param>
          <param>
            <type>class RandomAccessIC</type>
          </param>
          <param>
            <type>class Compare_strictly</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void CGAL::monotone_matrix_search</definition>
        <argsstring>(const Matrix &amp;m, RandomAccessIC t, const Compare_strictly &amp;compare_strictly=less&lt; Matrix::Value &gt;())</argsstring>
        <name>monotone_matrix_search</name>
        <qualifiedname>CGAL::monotone_matrix_search</qualifiedname>
        <param>
          <type>const Matrix &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>RandomAccessIC</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const Compare_strictly &amp;</type>
          <declname>compare_strictly</declname>
          <defval>less&lt; Matrix::Value &gt;()</defval>
        </param>
        <briefdescription>
<para>computes the maximum (as specified by <computeroutput>compare_strictly</computeroutput>) entry for each row of <computeroutput>m</computeroutput> and writes the corresponding column to <computeroutput>t</computeroutput>, i.e., <computeroutput>t[i]</computeroutput> is set to the index of the column containing the maximum element in row <computeroutput>i</computeroutput>. The maximum <formula id="7">$ m_r$</formula> of a row <formula id="8">$ r$</formula> is the leftmost element for which <computeroutput>compare_strictly</computeroutput> <formula id="9">$ (m_r,\,x)$</formula> is false for all elements <formula id="10">$ x$</formula> in <formula id="8">$ r$</formula>. </para>
        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgMatrixSearchRef_1ga46628c80ee99c78f04f1a10c83e71336" kindref="member">monotone_matrix_search()</ref></computeroutput> computes the maxima for all rows of a totally monotone matrix.</para>
<para>More precisely, monotony for matrices is defined as follows.</para>
<para>Let <formula id="11">$ K$</formula> be a totally ordered set, <formula id="12">$ M \in K^{(n,\, m)}$</formula> a matrix over <formula id="11">$ K$</formula> and for <formula id="13">$ 0 \le i &lt; n$</formula>:  <formula id="14">\[
rmax_M(i) :\in \left\{ \min_{0 \le j &lt; m} j \: \left|\:
M[i,\, j] = \max_{0 \le k &lt; m} M[i,\, k] \right.\right\}
\]</formula> the (leftmost) column containing the maximum entry in row <formula id="15">$ i$</formula>. <formula id="16">$ M$</formula> is called monotone, iff  <formula id="17">\[
\forall\, 0 \le i_1 &lt; i_2 &lt; n\: :\: rmax_M(i_1) \le
rmax_M(i_2)\; .
\]</formula> <formula id="16">$ M$</formula> is totally monotone, iff all of its submatrices are monotone (or equivalently: iff all <formula id="18">$ 2 \times 2$</formula> submatrices are monotone).</para>
<para><simplesect kind="pre"><para><computeroutput>t</computeroutput> points to a structure of size at least <computeroutput>m.number_of_rows()</computeroutput></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>is a model of <computeroutput><ref refid="classMonotoneMatrixSearchTraits" kindref="compound">MonotoneMatrixSearchTraits</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandomAccessIC</parametername>
</parameternamelist>
<parameterdescription>
<para>is a model of <computeroutput>RandomAccessIterator</computeroutput> with <computeroutput>int</computeroutput> as value type. If <computeroutput>compare_strictly</computeroutput> is defined, it is an adaptable binary function: <computeroutput>Matrix::Value</computeroutput> <formula id="19">$ \times$</formula> <computeroutput>Matrix::Value</computeroutput> <formula id="20">$ \rightarrow$</formula> <computeroutput>bool</computeroutput> describing a strict (non-reflexive) total ordering on <computeroutput>Matrix::Value</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><computeroutput><ref refid="classMonotoneMatrixSearchTraits" kindref="compound">MonotoneMatrixSearchTraits</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput>all_furthest_neighbors_2()</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput>maximum_area_inscribed_k_gon_2()</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput>maximum_perimeter_inscribed_k_gon_2()</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput>extremal_polygon_2()</computeroutput></para>
</simplesect>
<bold>Implementation</bold><linebreak/>
</para>
<para>The implementation uses an algorithm by Aggarwal et al.<ref refid="citelist_1CITEREF_akmsw-gamsa-87" kindref="member">[1]</ref>. The runtime is linear in the number of rows and columns of the matrix. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/monotone_matrix_search.h" line="60" column="9" declfile="CGAL/monotone_matrix_search.h" declline="60" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgMatrixSearchRef_1gad0255af00b2e5737196b91d489ba1c97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RandomAccessIterator</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>Traits::Value</type>
        <definition>Traits::Value CGAL::sorted_matrix_search</definition>
        <argsstring>(RandomAccessIterator f, RandomAccessIterator l, const Traits &amp;t)</argsstring>
        <name>sorted_matrix_search</name>
        <qualifiedname>CGAL::sorted_matrix_search</qualifiedname>
        <param>
          <type>RandomAccessIterator</type>
          <declname>f</declname>
        </param>
        <param>
          <type>RandomAccessIterator</type>
          <declname>l</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>returns the element <computeroutput>x</computeroutput> in one of the sorted matrices from the range <computeroutput>[f, l)</computeroutput>, for which <computeroutput>t.is_feasible(x)</computeroutput> is true and <computeroutput>t.compare(x, y)</computeroutput> is true for all other <computeroutput>y</computeroutput> values from any matrix for which <computeroutput>t.is_feasible(y)</computeroutput> is true. </para>
        </briefdescription>
        <detaileddescription>
<para>The function <computeroutput><ref refid="group__PkgMatrixSearchRef_1gad0255af00b2e5737196b91d489ba1c97" kindref="member">sorted_matrix_search()</ref></computeroutput> selects the smallest entry in a set of sorted matrices that fulfills a certain feasibility criterion.</para>
<para>More exactly, a matrix <formula id="21">$ M = (m_{i j}) \in S^{r \times l}$</formula> (over a totally ordered set <formula id="22">$ S$</formula>) is sorted, iff  <formula id="23">\begin{eqnarray*}
\forall \, 1 \le i \le r,\; 1 \le j &lt; l\; :\; m_{i j} \le m_{i (j+1)}
\;\; {\it and}\\
\forall \, 1 \le i &lt; r,\; 1 \le j \le l\; :\; m_{i j} \le m_{(i+1) j}
\;\;.
\end{eqnarray*}</formula></para>
<para>Now let <formula id="24">$ \mathcal{M}$</formula> be a set of <formula id="25">$ n$</formula> sorted matrices over <formula id="22">$ S$</formula> and <formula id="26">$ f$</formula> be a monotone predicate on <formula id="22">$ S$</formula>, i.e.\  <formula id="27">\[
f\: :\: S \longrightarrow\, \textit{bool} \quad{\rm with}\quad f(r)
\;\Longrightarrow\; \forall\, t \in S\,,\: t &gt; r \; :\; f(t)\;.
\]</formula></para>
<para>If we assume there is any feasible element in one of the matrices in <formula id="24">$ \mathcal{M}$</formula>, there certainly is a smallest such element. This is the one we are searching for.</para>
<para>The feasibility test as well as some other parameters can (and have to) be customized through a traits class.</para>
<para><simplesect kind="pre"><para><orderedlist>
<listitem>
<para>All matrices in <formula id="28">$ \left[f,\, l\right)$</formula> are sorted according to <computeroutput>Traits::compare_non_strictly</computeroutput>. </para>
</listitem>
<listitem>
<para>There is at least one entry <formula id="10">$ x$</formula> in a matrix <formula id="29">$ M \in
\left[f,\, l\right)$</formula> for which <computeroutput>Traits::is_feasible(x)</computeroutput> is true. </para>
</listitem>
</orderedlist>
</para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Traits</parametername>
</parameternamelist>
<parameterdescription>
<para>is a model for <computeroutput><ref refid="classSortedMatrixSearchTraits" kindref="compound">SortedMatrixSearchTraits</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandomAccessIterator</parametername>
</parameternamelist>
<parameterdescription>
<para>has <computeroutput>Traits::Matrix</computeroutput> as value type.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<bold>Implementation</bold><linebreak/>
</para>
<para>The implementation uses an algorithm by Frederickson and Johnson<ref refid="citelist_1CITEREF_fj-fkppc-83" kindref="member">[2]</ref>, <ref refid="citelist_1CITEREF_fj-gsrsm-84" kindref="member">[3]</ref> and runs in <formula id="30">$O(n \cdot k + f \cdot \log (n \cdot k))$</formula>, where <formula id="25">$ n$</formula> is the number of input matrices, <formula id="31">$ k$</formula> denotes the maximal dimension of any input matrix and <formula id="26">$ f$</formula> the time needed for one feasibility test.</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="classSortedMatrixSearchTraits" kindref="compound">SortedMatrixSearchTraits</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/sorted_matrix_search.h" line="63" column="17" declfile="CGAL/sorted_matrix_search.h" declline="63" declcolumn="17"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="CGAL/Dynamic_matrix.h" line="2" column="1"/>
  </compounddef>
</doxygen>
