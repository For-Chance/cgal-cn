<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_Bounding_Volumes"/><anchor id="index_1chapBoundingVolumes"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="authors"><para>Kaspar Fischer, Bernd G<aumlaut/>rtner, Thomas Herrmann, Michael Hoffmann, and Sven Sch<oumlaut/>nherr</para>
</simplesect>
<image type="html" name="ball.png"></image>
</para>
<para>This chapter describes algorithms which for a given point set compute the <emphasis>best</emphasis> circumscribing object from a specific class. If the class consists of all spheres in <formula id="0">$ d$</formula>-dimensional Euclidean space and <emphasis>best</emphasis> is defined as having smallest radius, then we obtain the smallest enclosing sphere.</para>
<sect1 id="index_1SectBoundingIntroduction">
<title>Introduction</title>
<para>Bounding volumes can be used to obtain simple approximations of complicated objects. For example, consider the problem of deciding whether two moving polygons currently intersect. An obvious solution is to discretize time and perform a full intersection test for any time step. If the polygons are far apart most of the time, this is unnecessary. Instead, simple bounding volumes (for examples, circles) are computed for both polygons at their initial positions. At subsequent time steps, an intersection test between the moving bounding circles replaces the actual intersection test; only if the circles do intersect, the expensive intersection test between the polygons is performed. In practice, bounding volume hierarchies are often used on top of simple bounding volumes to approximate complicated objects more accurately.</para>
<para>Bounding volumes are also frequently applied to extract geometric properties of objects. For example, the smallest enclosing annulus of a point set can be used to test whether a set of points is approximately cospherical. Here, the width of the annulus (or its area, or still another criterion that we use) is a good measure for this property.</para>
</sect1>
<sect1 id="index_1SectBoundingSphere">
<title>Bounding Spheres in dD</title>
<para>We provide the class <computeroutput><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">Min_sphere_of_spheres_d</ref>&lt;Traits&gt;</computeroutput> for arbitrary dimensions to compute the smallest enclosing spheres for points as well as for spheres. The dimension as well as the input type depend on the chosen traits class.</para>
<para>The following example is for 2D points</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_circle_2_2min_circle_2_8cpp-example" kindref="compound">Min_circle_2/min_circle_2.cpp</ref> <programlisting filename="Min_circle_2/min_circle_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_sphere_of_spheres_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_sphere_of_points_d_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__sphere__of__points__d__traits__2" kindref="compound">CGAL::Min_sphere_of_points_d_traits_2&lt;K,double&gt;</ref><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">CGAL::Min_sphere_of_spheres_d&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Min_circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>P[n];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::Random<sp/><sp/>r;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>random<sp/>number<sp/>generator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>P[<sp/>i]<sp/>=<sp/>Point(r.get_double(),<sp/>r.get_double());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Min_circle<sp/><sp/>mc(<sp/>P,<sp/>P+n);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Min_circle::Cartesian_const_iterator<sp/>ccib<sp/>=<sp/>mc.center_cartesian_begin(),<sp/>ccie<sp/>=<sp/>mc.center_cartesian_end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;center:&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/>;<sp/>ccib<sp/>!=<sp/>ccie;<sp/>++ccib){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>*ccib;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;radius:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>mc.radius()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The example for 2D circles as input looks rather similar.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_sphere_of_spheres_d_2min_sphere_of_spheres_d_2_8cpp-example" kindref="compound">Min_sphere_of_spheres_d/min_sphere_of_spheres_d_2.cpp</ref> <programlisting filename="Min_sphere_of_spheres_d/min_sphere_of_spheres_d_2.cpp"><codeline><highlight class="comment">//<sp/>Computes<sp/>the<sp/>minsphere<sp/>of<sp/>some<sp/>random<sp/>spheres.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Random.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_rational.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_sphere_of_spheres_d.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>spheres</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>LOW<sp/>=<sp/>0,<sp/>HIGH<sp/>=<sp/>10000;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>range<sp/>of<sp/>coordinates<sp/>and<sp/>radii</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Exact_rational<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//typedef<sp/>double<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;FT&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Min__sphere__of__spheres__d__traits__2" kindref="compound">CGAL::Min_sphere_of_spheres_d_traits_2&lt;K,FT&gt;</ref><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">CGAL::Min_sphere_of_spheres_d&lt;Traits&gt;</ref><sp/>Min_sphere;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Traits::Sphere<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sphere;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Sphere&gt;<sp/>S;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>n<sp/>spheres</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>r;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>random<sp/>number<sp/>generator</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;N;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>x<sp/>=<sp/>r.get_int(LOW,HIGH),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>y<sp/>=<sp/>r.get_int(LOW,HIGH);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Point<sp/>p(x,y);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>random<sp/>center...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S.push_back(Sphere(p,r.get_int(LOW,HIGH)));<sp/></highlight><highlight class="comment">//<sp/>...and<sp/>random<sp/>radius</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Min_sphere<sp/>ms(S.begin(),S.end());<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>in<sp/>the<sp/>spheres</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(ms.is_valid());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<sect2 id="index_1SectBoundingSphereHomogeneous">
<title>Bounding Spheres for the Homogeneous Kernel</title>
<para>In the previous section we saw that we used <computeroutput><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">Min_sphere_of_spheres_d</ref></computeroutput> to compute the smallest circle for points. This package also provides the classes <computeroutput><ref refid="classCGAL_1_1Min__circle__2" kindref="compound">Min_circle_2</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Min__sphere__d" kindref="compound">Min_sphere_d</ref></computeroutput>, but they are slower, and they should only be used in case of homogeneous coordinates which are not supported by <computeroutput><ref refid="classCGAL_1_1Min__sphere__of__spheres__d" kindref="compound">Min_sphere_of_spheres_d</ref></computeroutput>.</para>
<para>In the following example a smallest enclosing circle (<computeroutput><ref refid="classCGAL_1_1Min__circle__2" kindref="compound">Min_circle_2</ref>&lt;Traits&gt;</computeroutput>) is constructed from points on a line and written to standard output. The example shows that it is advisable to switch on random shuffling in order to deal with a <emphasis>bad</emphasis> order of the input points.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_circle_2_2min_circle_homogeneous_2_8cpp-example" kindref="compound">Min_circle_2/min_circle_homogeneous_2.cpp</ref> <programlisting filename="Min_circle_2/min_circle_homogeneous_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_integer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_homogeneous.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_circle_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Min_circle_2_traits_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>typedefs</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/>CGAL::Exact_integer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Simple__homogeneous" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_homogeneous&lt;RT&gt;</ref><sp/><sp/><sp/><sp/>K;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__circle__2__traits__2" kindref="compound">CGAL::Min_circle_2_traits_2&lt;K&gt;</ref><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Min__circle__2" kindref="compound">CGAL::Min_circle_2&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/>Min_circle;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><sp/>K::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">main(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/>P[n];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>P[i]<sp/>=<sp/>Point(<sp/>(i%2<sp/>==<sp/>0<sp/>?<sp/>i<sp/>:<sp/>-i),<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(0,0),<sp/>(-1,0),<sp/>(2,0),<sp/>(-3,0),<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Min_circle<sp/><sp/>mc1(<sp/>P,<sp/>P+n,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>very<sp/>slow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Min_circle<sp/><sp/>mc2(<sp/>P,<sp/>P+n,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>fast</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga2cbb865dd83eedd780f4a452635b1d28" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_pretty_mode</ref>(<sp/>std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>mc2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1SectBoundingAnnulus">
<title>Bounding Annulus in dD</title>
<para>We provide the class <computeroutput><ref refid="classCGAL_1_1Min__annulus__d" kindref="compound">Min_annulus_d</ref>&lt;Traits&gt;</computeroutput> for arbitrary dimensions to compute the smallest enclosing annulus for a set of points. In 2D the annulus consists of two concentric circles, in 3D of two concentric spheres.</para>
<para><image type="html" name="annulus.png"></image>
</para>
</sect1>
<sect1 id="index_1SectBounding2D">
<title>Various Bounding Areas in 2D</title>
<para>Other classes for which we provide solutions are ellipses (<computeroutput><ref refid="classCGAL_1_1Min__ellipse__2" kindref="compound">Min_ellipse_2</ref>&lt;Traits&gt;</computeroutput>), rectangles (<computeroutput><ref refid="group__PkgBoundingVolumesRef_1gadcf412afbf5ae512fc88d25d286fa3fa" kindref="member">min_rectangle_2()</ref></computeroutput>), parallelograms (<computeroutput><ref refid="group__PkgBoundingVolumesRef_1ga15d5706ceec6fc6fcae0b1625b6da2ac" kindref="member">min_parallelogram_2()</ref></computeroutput>) and strips (<computeroutput><ref refid="group__PkgBoundingVolumesRef_1gafc685ec39e42e18195ca101631c61cd0" kindref="member">min_strip_2()</ref></computeroutput>) in the plane, with appropriate optimality criteria.</para>
</sect1>
<sect1 id="index_1SectBoundingEllipsoid">
<title>Approximate Bounding Ellipsoid in dD</title>
<para>While this package provides an exact smallest 2D ellipse, it also provides the class <computeroutput><ref refid="classCGAL_1_1Approximate__min__ellipsoid__d" kindref="compound">Approximate_min_ellipsoid_d</ref>&lt;Traits&gt;</computeroutput> to compute an approximate minimum-volume enclosing ellipsoid with user-specified approximation ratio.</para>
</sect1>
<sect1 id="index_1SectBoundingPcenter">
<title>Rectangular P-Center</title>
<para>Bounding volumes also define geometric &quot;center points&quot; of objects. For example, if two objects are to be matched (approximately), one approach is to first apply the translation that maps the centers of their smallest enclosing spheres onto each other. Simpler centers are possible, of course (center of gravity, center of bounding box), but more advanced bounding volumes might give better results in some cases. It can also make sense to consider several center points instead of just one. For example, we provide algorithms to cover a planar point set with between two and four minimal boxes (<computeroutput><ref refid="group__PkgBoundingVolumesRef_1ga37fae6bf8313f85322987d3f230eca53" kindref="member">rectangular_p_center_2()</ref></computeroutput>). Below is an example covering with three boxes; the center points are shown in red.</para>
<para><image type="html" name="pcenter.png"></image>
 </para>
</sect1>
    </detaileddescription>
    <location file="Bounding_volumes.txt"/>
  </compounddef>
</doxygen>
