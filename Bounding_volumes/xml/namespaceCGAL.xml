<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="namespaceCGAL" kind="namespace" language="C++">
    <compoundname>CGAL</compoundname>
    <innerclass refid="classCGAL_1_1Approximate__min__ellipsoid__d" prot="public">CGAL::Approximate_min_ellipsoid_d</innerclass>
    <innerclass refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__2" prot="public">CGAL::Approximate_min_ellipsoid_d_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__3" prot="public">CGAL::Approximate_min_ellipsoid_d_traits_3</innerclass>
    <innerclass refid="structCGAL_1_1Approximate__min__ellipsoid__d__traits__d" prot="public">CGAL::Approximate_min_ellipsoid_d_traits_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__annulus__d" prot="public">CGAL::Min_annulus_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__circle__2" prot="public">CGAL::Min_circle_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__circle__2__traits__2" prot="public">CGAL::Min_circle_2_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__ellipse__2" prot="public">CGAL::Min_ellipse_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__ellipse__2__traits__2" prot="public">CGAL::Min_ellipse_2_traits_2</innerclass>
    <innerclass refid="structCGAL_1_1Min__quadrilateral__default__traits__2" prot="public">CGAL::Min_quadrilateral_default_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__annulus__d__traits__2" prot="public">CGAL::Min_sphere_annulus_d_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__annulus__d__traits__3" prot="public">CGAL::Min_sphere_annulus_d_traits_3</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__annulus__d__traits__d" prot="public">CGAL::Min_sphere_annulus_d_traits_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__d" prot="public">CGAL::Min_sphere_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__points__d__traits__2" prot="public">CGAL::Min_sphere_of_points_d_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__points__d__traits__3" prot="public">CGAL::Min_sphere_of_points_d_traits_3</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__points__d__traits__d" prot="public">CGAL::Min_sphere_of_points_d_traits_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__spheres__d" prot="public">CGAL::Min_sphere_of_spheres_d</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__spheres__d__traits__2" prot="public">CGAL::Min_sphere_of_spheres_d_traits_2</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__spheres__d__traits__3" prot="public">CGAL::Min_sphere_of_spheres_d_traits_3</innerclass>
    <innerclass refid="classCGAL_1_1Min__sphere__of__spheres__d__traits__d" prot="public">CGAL::Min_sphere_of_spheres_d_traits_d</innerclass>
    <innerclass refid="classCGAL_1_1Rectangular__p__center__default__traits__2" prot="public">CGAL::Rectangular_p_center_default_traits_2</innerclass>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__PkgBoundingVolumesRef_1ga15d5706ceec6fc6fcae0b1625b6da2ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::min_parallelogram_2</definition>
        <argsstring>(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</argsstring>
        <name>min_parallelogram_2</name>
        <qualifiedname>CGAL::min_parallelogram_2</qualifiedname>
        <param>
          <type>ForwardIterator</type>
          <declname>points_begin</declname>
        </param>
        <param>
          <type>ForwardIterator</type>
          <declname>points_end</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>o</declname>
        </param>
        <param>
          <type>Traits &amp;</type>
          <declname>t</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a minimum area enclosing parallelogram of the point set described by [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>), writes its vertices (counterclockwise) to <computeroutput>o</computeroutput> and returns the past-the-end iterator of this sequence. </para>
        </briefdescription>
        <detaileddescription>
<para>The function computes a minimum area enclosing parallelogram <formula id="111">$ A(P)$</formula> of a given convex point set <formula id="9">$ P$</formula>. Note that <formula id="112">$ R(P)$</formula> is not necessarily axis-parallel, and it is in general not unique. The focus on convex sets is no restriction, since any parallelogram enclosing <formula id="9">$ P$</formula> - as a convex set - contains the convex hull of <formula id="9">$ P$</formula>. For general point sets one has to compute the convex hull as a preprocessing step.</para>
<para>If the input range is empty, <computeroutput>o</computeroutput> remains unchanged.</para>
<para>If the input range consists of one element only, this point is written to <computeroutput>o</computeroutput> four times.</para>
<para><simplesect kind="pre"><para>The points denoted by the range [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>) form the boundary of a simple convex polygon <formula id="9">$ P$</formula> in counterclockwise orientation.</para>
</simplesect>
The geometric types and operations to be used for the computation are specified by the traits class parameter <computeroutput>t</computeroutput>. The parameter can be omitted, if <computeroutput>ForwardIterator</computeroutput> refers to a two-dimensional point type from one the CGAL kernels. In this case, a default traits class (<computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput>) is used.</para>
<para><orderedlist>
<listitem>
<para>If <computeroutput>Traits</computeroutput> is specified, it must be a model for <computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> and the value type <computeroutput>VT</computeroutput> of <computeroutput>ForwardIterator</computeroutput> is <computeroutput>Traits::Point_2</computeroutput>. Otherwise <computeroutput>VT</computeroutput> must be <computeroutput>CGAL::Point_2&lt;K&gt;</computeroutput> for some kernel <computeroutput>K</computeroutput>. </para>
</listitem>
<listitem>
<para><computeroutput>OutputIterator</computeroutput> must accept <computeroutput>VT</computeroutput> as value type. </para>
</listitem>
</orderedlist>
</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1gadcf412afbf5ae512fc88d25d286fa3fa" kindref="member">CGAL::min_rectangle_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1gafc685ec39e42e18195ca101631c61cd0" kindref="member">CGAL::min_strip_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">CGAL::Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput></para>
</simplesect>
<bold>Implementation</bold><linebreak/>
</para>
<para>We use a rotating caliper algorithm <ref refid="citelist_1CITEREF_stvwe-mepa-95" kindref="member">[12]</ref>, <ref refid="citelist_1CITEREF_v-fmep-90" kindref="member">[15]</ref> with worst case running time linear in the number of input points.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para>The following code generates a random convex polygon <computeroutput>P</computeroutput> with 20 vertices and computes the minimum enclosing parallelogram of <computeroutput>P</computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_quadrilateral_2_2minimum_enclosing_parallelogram_2_8cpp-example" kindref="compound">Min_quadrilateral_2/minimum_enclosing_parallelogram_2.cpp</ref> <programlisting filename="Min_quadrilateral_2/minimum_enclosing_parallelogram_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_convex_set_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/min_quadrilateral_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Simple_cartesian&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polygon_2&lt;Kernel&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2&gt;<sp/><sp/>Generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>build<sp/>a<sp/>random<sp/>convex<sp/>20-gon<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::random_convex_set_2(20,<sp/>std::back_inserter(p),<sp/>Generator(1.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>minimal<sp/>enclosing<sp/>parallelogram<sp/>p_m<sp/>of<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>p_m;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoundingVolumesRef_1ga15d5706ceec6fc6fcae0b1625b6da2ac" kindref="member">CGAL::min_parallelogram_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>p.vertices_begin(),<sp/>p.vertices_end(),<sp/>std::back_inserter(p_m));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p_m<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/min_quadrilateral_2.h" line="65" column="1" declfile="CGAL/min_quadrilateral_2.h" declline="65" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgBoundingVolumesRef_1gadcf412afbf5ae512fc88d25d286fa3fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::min_rectangle_2</definition>
        <argsstring>(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</argsstring>
        <name>min_rectangle_2</name>
        <qualifiedname>CGAL::min_rectangle_2</qualifiedname>
        <param>
          <type>ForwardIterator</type>
          <declname>points_begin</declname>
        </param>
        <param>
          <type>ForwardIterator</type>
          <declname>points_end</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>o</declname>
        </param>
        <param>
          <type>Traits &amp;</type>
          <declname>t</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a minimum area enclosing rectangle of the point set described by [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>), writes its vertices (counterclockwise) to <computeroutput>o</computeroutput>, and returns the past-the-end iterator of this sequence. </para>
        </briefdescription>
        <detaileddescription>
<para>The function computes a minimum area enclosing rectangle <formula id="112">$ R(P)$</formula> of a given convex point set <formula id="9">$ P$</formula>. Note that <formula id="112">$ R(P)$</formula> is not necessarily axis-parallel, and it is in general not unique. The focus on convex sets is no restriction, since any rectangle enclosing <formula id="9">$ P$</formula> - as a convex set - contains the convex hull of <formula id="9">$ P$</formula>. For general point sets one has to compute the convex hull as a preprocessing step.</para>
<para>If the input range is empty, <computeroutput>o</computeroutput> remains unchanged.</para>
<para>If the input range consists of one element only, this point is written to <computeroutput>o</computeroutput> four times.</para>
<para><simplesect kind="pre"><para>The points denoted by the range [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>) form the boundary of a simple convex polygon <formula id="9">$ P$</formula> in counterclockwise orientation.</para>
</simplesect>
The geometric types and operations to be used for the computation are specified by the traits class parameter <computeroutput>t</computeroutput>. The parameter can be omitted, if <computeroutput>ForwardIterator</computeroutput> refers to a two-dimensional point type from one the CGAL kernels. In this case, a default traits class (<computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput>) is used.</para>
<para><orderedlist>
<listitem>
<para>If <computeroutput>Traits</computeroutput> is specified, it must be a model for <computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> and the value type <computeroutput>VT</computeroutput> of <computeroutput>ForwardIterator</computeroutput> is <computeroutput>Traits::Point_2</computeroutput>. Otherwise <computeroutput>VT</computeroutput> must be <computeroutput>CGAL::Point_2&lt;K&gt;</computeroutput> for some kernel <computeroutput>K</computeroutput>. </para>
</listitem>
<listitem>
<para><computeroutput>OutputIterator</computeroutput> must accept <computeroutput>VT</computeroutput> as value type. </para>
</listitem>
</orderedlist>
</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1ga15d5706ceec6fc6fcae0b1625b6da2ac" kindref="member">CGAL::min_parallelogram_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1gafc685ec39e42e18195ca101631c61cd0" kindref="member">CGAL::min_strip_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">CGAL::Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput></para>
</simplesect>
<bold>Implementation</bold><linebreak/>
</para>
<para>We use a rotating caliper algorithm <ref refid="citelist_1CITEREF_t-sgprc-83" kindref="member">[14]</ref> with worst case running time linear in the number of input points.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para>The following code generates a random convex polygon <computeroutput>P</computeroutput> with 20 vertices and computes the minimum enclosing rectangle of <computeroutput>P</computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_quadrilateral_2_2minimum_enclosing_rectangle_2_8cpp-example" kindref="compound">Min_quadrilateral_2/minimum_enclosing_rectangle_2.cpp</ref> <programlisting filename="Min_quadrilateral_2/minimum_enclosing_rectangle_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_convex_set_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/min_quadrilateral_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Simple_cartesian&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polygon_2&lt;Kernel&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2&gt;<sp/><sp/>Generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>build<sp/>a<sp/>random<sp/>convex<sp/>20-gon<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::random_convex_set_2(20,<sp/>std::back_inserter(p),<sp/>Generator(1.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>minimal<sp/>enclosing<sp/>rectangle<sp/>p_m<sp/>of<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>p_m;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoundingVolumesRef_1gadcf412afbf5ae512fc88d25d286fa3fa" kindref="member">CGAL::min_rectangle_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>p.vertices_begin(),<sp/>p.vertices_end(),<sp/>std::back_inserter(p_m));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p_m<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/min_quadrilateral_2.h" line="135" column="1" declfile="CGAL/min_quadrilateral_2.h" declline="135" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgBoundingVolumesRef_1gafc685ec39e42e18195ca101631c61cd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::min_strip_2</definition>
        <argsstring>(ForwardIterator points_begin, ForwardIterator points_end, OutputIterator o, Traits &amp;t=Default_traits)</argsstring>
        <name>min_strip_2</name>
        <qualifiedname>CGAL::min_strip_2</qualifiedname>
        <param>
          <type>ForwardIterator</type>
          <declname>points_begin</declname>
        </param>
        <param>
          <type>ForwardIterator</type>
          <declname>points_end</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>o</declname>
        </param>
        <param>
          <type>Traits &amp;</type>
          <declname>t</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>computes a minimum enclosing strip of the point set described by [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>), writes its two bounding lines to <computeroutput>o</computeroutput> and returns the past-the-end iterator of this sequence. </para>
        </briefdescription>
        <detaileddescription>
<para>The function computes a minimum width enclosing strip <formula id="113">$ S(P)$</formula> of a given convex point set <formula id="9">$ P$</formula>. A strip is the closed region bounded by two parallel lines in the plane. Note that <formula id="113">$ S(P)$</formula> is not unique in general. The focus on convex sets is no restriction, since any parallelogram enclosing <formula id="9">$ P$</formula> - as a convex set - contains the convex hull of <formula id="9">$ P$</formula>. For general point sets one has to compute the convex hull as a preprocessing step.</para>
<para>If the input range is empty or consists of one element only, <computeroutput>o</computeroutput> remains unchanged.</para>
<para><simplesect kind="pre"><para>The points denoted by the range [<computeroutput>points_begin</computeroutput>, <computeroutput>points_end</computeroutput>) form the boundary of a simple convex polygon <formula id="9">$ P$</formula> in counterclockwise orientation.</para>
</simplesect>
The geometric types and operations to be used for the computation are specified by the traits class parameter <computeroutput>t</computeroutput>. The parameter can be omitted, if <computeroutput>ForwardIterator</computeroutput> refers to a two-dimensional point type from one the CGAL kernels. In this case, a default traits class (<computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput>) is used.</para>
<para><orderedlist>
<listitem>
<para>If <computeroutput>Traits</computeroutput> is specified, it must be a model for <computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> and the value type <computeroutput>VT</computeroutput> of <computeroutput>ForwardIterator</computeroutput> is <computeroutput>Traits::Point_2</computeroutput>. Otherwise <computeroutput>VT</computeroutput> must be <computeroutput>CGAL::Point_2&lt;K&gt;</computeroutput> for some kernel <computeroutput>K</computeroutput>. </para>
</listitem>
<listitem>
<para><computeroutput>OutputIterator</computeroutput> must accept <computeroutput>Traits::Line_2</computeroutput> as value type. </para>
</listitem>
</orderedlist>
</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1gadcf412afbf5ae512fc88d25d286fa3fa" kindref="member">CGAL::min_rectangle_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgBoundingVolumesRef_1ga15d5706ceec6fc6fcae0b1625b6da2ac" kindref="member">CGAL::min_parallelogram_2()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classMinQuadrilateralTraits__2" kindref="compound">MinQuadrilateralTraits_2</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Min__quadrilateral__default__traits__2" kindref="compound">CGAL::Min_quadrilateral_default_traits_2</ref>&lt;K&gt;</computeroutput></para>
</simplesect>
<bold>Implementation</bold><linebreak/>
</para>
<para>We use a rotating caliper algorithm <ref refid="citelist_1CITEREF_t-sgprc-83" kindref="member">[14]</ref> with worst case running time linear in the number of input points.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para>The following code generates a random convex polygon <computeroutput>P</computeroutput> with 20 vertices and computes the minimum enclosing strip of <computeroutput>P</computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Min_quadrilateral_2_2minimum_enclosing_strip_2_8cpp-example" kindref="compound">Min_quadrilateral_2/minimum_enclosing_strip_2.cpp</ref> <programlisting filename="Min_quadrilateral_2/minimum_enclosing_strip_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polygon_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/random_convex_set_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/min_quadrilateral_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Simple_cartesian&lt;double&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Line_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Line_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Polygon_2&lt;Kernel&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Polygon_2;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point_2&gt;<sp/><sp/>Generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>build<sp/>a<sp/>random<sp/>convex<sp/>20-gon<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_2<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::random_convex_set_2(20,<sp/>std::back_inserter(p),<sp/>Generator(1.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>minimal<sp/>enclosing<sp/>strip<sp/>p_m<sp/>of<sp/>p</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Line_2<sp/>p_m[2];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoundingVolumesRef_1gafc685ec39e42e18195ca101631c61cd0" kindref="member">CGAL::min_strip_2</ref>(p.vertices_begin(),<sp/>p.vertices_end(),<sp/>p_m);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>p_m[0]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p_m[1]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/min_quadrilateral_2.h" line="203" column="1" declfile="CGAL/min_quadrilateral_2.h" declline="203" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__PkgBoundingVolumesRef_1ga37fae6bf8313f85322987d3f230eca53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ForwardIterator</type>
          </param>
          <param>
            <type>class OutputIterator</type>
          </param>
          <param>
            <type>class FT</type>
          </param>
          <param>
            <type>class Traits</type>
          </param>
        </templateparamlist>
        <type>OutputIterator</type>
        <definition>OutputIterator CGAL::rectangular_p_center_2</definition>
        <argsstring>(ForwardIterator f, ForwardIterator l, OutputIterator o, FT &amp;r, int p, const Traits &amp;t=Default_traits)</argsstring>
        <name>rectangular_p_center_2</name>
        <qualifiedname>CGAL::rectangular_p_center_2</qualifiedname>
        <param>
          <type>ForwardIterator</type>
          <declname>f</declname>
        </param>
        <param>
          <type>ForwardIterator</type>
          <declname>l</declname>
        </param>
        <param>
          <type>OutputIterator</type>
          <declname>o</declname>
        </param>
        <param>
          <type>FT &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>int</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const Traits &amp;</type>
          <declname>t</declname>
          <defval>Default_traits</defval>
        </param>
        <briefdescription>
<para>Computes rectilinear <formula id="127">$ p$</formula>-centers of a planar point set, i.e. a set of <formula id="127">$ p$</formula> points such that the maximum minimal <formula id="150">$ L_{\infty}$</formula>-distance between both sets is minimized. </para>
        </briefdescription>
        <detaileddescription>
<para>More formally the problem can be defined as follows.</para>
<para>Given a finite set <formula id="151">$ \mathcal{P}$</formula> of points, compute a point set <formula id="152">$ \mathcal{C}$</formula> with <formula id="153">$ |\mathcal{C}| \le p$</formula> such that the <formula id="127">$ p$</formula>-radius of <formula id="151">$ \mathcal{P}$</formula>,  <formula id="154">\[
rad_p(\mathcal{P}) := \max_{P \in \mathcal{P}} \min_{Q \in
\mathcal{C}} || P - Q ||_\infty
\]</formula> is minimized. We can interpret <formula id="152">$ \mathcal{C}$</formula> as the best approximation (with respect to the given metric) for <formula id="151">$ \mathcal{P}$</formula> with at most <formula id="127">$ p$</formula> points.</para>
<para>computes rectilinear <computeroutput>p</computeroutput>-centers for the point set described by the range [<computeroutput>f</computeroutput>, <computeroutput>l</computeroutput>), sets <computeroutput>r</computeroutput> to the corresponding <formula id="127">$ p$</formula>-radius, writes the at most <computeroutput>p</computeroutput> center points to <computeroutput>o</computeroutput> and returns the past-the-end iterator of this sequence.</para>
<para><simplesect kind="pre"><para>2 <formula id="155">$ \le$</formula> <computeroutput>p</computeroutput> <formula id="155">$ \le$</formula> 4.</para>
</simplesect>
The geometric types and operations to be used for the computation are specified by the traits class parameter <computeroutput>t</computeroutput>. This parameter can be omitted if <computeroutput>ForwardIterator</computeroutput> refers to a point type from the 2D-Kernel. In this case, a default traits class (<computeroutput><ref refid="classCGAL_1_1Rectangular__p__center__default__traits__2" kindref="compound">Rectangular_p_center_default_traits_2</ref>&lt;K&gt;</computeroutput>) is used.</para>
<para><orderedlist>
<listitem>
<para><emphasis>Either: (if no traits parameter is given)</emphasis> Value type of <computeroutput>ForwardIterator</computeroutput> must be <computeroutput>CGAL::Point_2&lt;K&gt;</computeroutput> for some representation class <computeroutput>K</computeroutput> and <computeroutput>FT</computeroutput> must be equivalent to <computeroutput>K::FT</computeroutput>, </para>
</listitem>
<listitem>
<para><emphasis>Or: (if a traits parameter is specified)</emphasis> <computeroutput>Traits</computeroutput> must be a model for <computeroutput><ref refid="classRectangularPCenterTraits__2" kindref="compound">RectangularPCenterTraits_2</ref></computeroutput>. </para>
</listitem>
<listitem>
<para><computeroutput>OutputIterator</computeroutput> must accept the value type of <computeroutput>ForwardIterator</computeroutput> as value type. </para>
</listitem>
</orderedlist>
</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="classRectangularPCenterTraits__2" kindref="compound">RectangularPCenterTraits_2</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Rectangular__p__center__default__traits__2" kindref="compound">CGAL::Rectangular_p_center_default_traits_2</ref>&lt;K&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput>CGAL::sorted_matrix_search()</computeroutput></para>
</simplesect>
<bold>Implementation</bold><linebreak/>
</para>
<para>The runtime is linear for <formula id="156">$ p \in \{2,\,3\}$</formula> and <formula id="157">$O(n \cdot \log n)$</formula> for <formula id="158">$ p = 4$</formula> where <formula id="159">$ n$</formula> is the number of input points. These runtimes are worst case optimal. The <formula id="39">$ 3$</formula>-center algorithm uses a prune-and-search technique described in <ref refid="citelist_1CITEREF_cgal:h-slacr-99" kindref="member">[9]</ref>. The <formula id="160">$ 4$</formula>-center implementation uses sorted matrix search <ref refid="citelist_1CITEREF_fj-fkppc-83" kindref="member">[1]</ref>, <ref refid="citelist_1CITEREF_fj-gsrsm-84" kindref="member">[2]</ref> and fast algorithms for piercing rectangles <ref refid="citelist_1CITEREF_sw-rpppp-96" kindref="member">[13]</ref>.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para>The following code generates a random set of ten points and computes its two-centers.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Rectangular_p_center_2_2rectangular_p_center_2_8cpp-example" kindref="compound">Rectangular_p_center_2/rectangular_p_center_2.cpp</ref> <programlisting filename="Rectangular_p_center_2/rectangular_p_center_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/point_generators_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/rectangular_p_center_2.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/Ostream_iterator.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/algorithm.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Simple_cartesian&lt;FT&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kernel;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::Point_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cont;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Random_points_in_square_2&lt;Point&gt;<sp/><sp/><sp/><sp/><sp/><sp/>Generator;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>CGAL::Ostream_iterator&lt;Point,std::ostream&gt;<sp/><sp/>OIterator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p<sp/>=<sp/>3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OIterator<sp/>cout_ip(std::cout);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::IO::set_pretty_mode(std::cout);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Cont<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy_n(Generator(1),<sp/>n,<sp/>std::back_inserter(points));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Generated<sp/>Point<sp/>Set:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::copy(points.begin(),<sp/>points.end(),<sp/>cout_ip);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>p_radius;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-centers:\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgBoundingVolumesRef_1ga37fae6bf8313f85322987d3f230eca53" kindref="member">CGAL::rectangular_p_center_2</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>points.begin(),<sp/>points.end(),<sp/>cout_ip,<sp/>p_radius,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;-radius<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>p_radius<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/rectangular_p_center_2.h" line="265" column="1" declfile="CGAL/rectangular_p_center_2.h" declline="265" declcolumn="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="Bounding_volumes.txt" line="2" column="1"/>
  </compounddef>
</doxygen>
