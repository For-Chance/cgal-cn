<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classCGAL_1_1Quadratic__program__solution" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Quadratic_program_solution</compoundname>
    <includes local="no">CGAL/QP_solution.h</includes>
    <templateparamlist>
      <param>
        <type>typename <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Types</header>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::ET</definition>
        <argsstring></argsstring>
        <name>ET</name>
        <qualifiedname>CGAL::Quadratic_program_solution::ET</qualifiedname>
        <briefdescription>
<para>The exact number type that was used to solve the program. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="75" column="26" bodyfile="CGAL/QP_solution.h" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Variable_value_iterator</definition>
        <argsstring></argsstring>
        <name>Variable_value_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Variable_value_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput> to go over the values of the variables in the solution. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="81" column="26" bodyfile="CGAL/QP_solution.h" bodystart="81" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Variable_numerator_iterator</definition>
        <argsstring></argsstring>
        <name>Variable_numerator_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Variable_numerator_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over the numerators of the variable values with respect to a common denominator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="88" column="26" bodyfile="CGAL/QP_solution.h" bodystart="88" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Index_iterator</definition>
        <argsstring></argsstring>
        <name>Index_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Index_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput>int</computeroutput> to go over the indices of the basic variables and the basic constraints. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="94" column="26" bodyfile="CGAL/QP_solution.h" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Optimality_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Optimality_certificate_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Optimality_certificate_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput> to go over an <formula id="8">$ m$</formula>-vector <formula id="46">$ \qplambda$</formula> that proves optimality of the solution. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="101" column="26" bodyfile="CGAL/QP_solution.h" bodystart="101" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Optimality_certificate_numerator_iterator</definition>
        <argsstring></argsstring>
        <name>Optimality_certificate_numerator_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Optimality_certificate_numerator_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over the numerators of the vector <formula id="46">$ \qplambda$</formula> with respect to a common denominator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="108" column="26" bodyfile="CGAL/QP_solution.h" bodystart="108" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Infeasibility_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Infeasibility_certificate_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Infeasibility_certificate_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over an <formula id="8">$ m$</formula>-vector <formula id="46">$ \qplambda$</formula> that proves infeasibility of the solution. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="115" column="26" bodyfile="CGAL/QP_solution.h" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" prot="public" static="no">
        <type><ref refid="classunspecified__type" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">unspecified_type</ref></type>
        <definition>typedef unspecified_type CGAL::Quadratic_program_solution&lt; ET &gt;::Unboundedness_certificate_iterator</definition>
        <argsstring></argsstring>
        <name>Unboundedness_certificate_iterator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Unboundedness_certificate_iterator</qualifiedname>
        <briefdescription>
<para>An iterator type with value type <computeroutput>ET</computeroutput> to go over an <formula id="3">$ n$</formula>-vector <formula id="47">$ \qpw$</formula> that proves unboundedness of the solution. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="122" column="26" bodyfile="CGAL/QP_solution.h" bodystart="122" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <description><para>Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> can be copied and assigned.</para>
<para>Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> that are associated to an actual program are returned by any of the four functions <computeroutput>solve_quadratic_program</computeroutput>, <computeroutput>solve_linear_program</computeroutput>, <computeroutput>solve_nonnegative_quadratic_program</computeroutput>, and <computeroutput>solve_nonnegative_linear_program</computeroutput>. <bold>Example:</bold> <ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref> </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a49488f93f767d506f98975b85ace7b75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Quadratic_program_solution&lt; ET &gt;::Quadratic_program_solution</definition>
        <argsstring>()</argsstring>
        <name>Quadratic_program_solution</name>
        <qualifiedname>CGAL::Quadratic_program_solution::Quadratic_program_solution</qualifiedname>
        <briefdescription>
<para>constructs a void instance of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> that is associated to no program. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="140" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_void</definition>
        <argsstring>() const</argsstring>
        <name>is_void</name>
        <qualifiedname>CGAL::Quadratic_program_solution::is_void</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> is not associated to a program. </para>
        </briefdescription>
        <detaileddescription>
<para>The condition !<computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" kindref="member">is_void()</ref></computeroutput> is a precondition for all access methods below. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="152" column="6"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Solution status</header>
      <description><para>Here are the access methods for the status of the solution. </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_optimal</definition>
        <argsstring>() const</argsstring>
        <name>is_optimal</name>
        <qualifiedname>CGAL::Quadratic_program_solution::is_optimal</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> is an optimal solution of the associated program. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="163" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_infeasible</definition>
        <argsstring>() const</argsstring>
        <name>is_infeasible</name>
        <qualifiedname>CGAL::Quadratic_program_solution::is_infeasible</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff the associated program is infeasible. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="169" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_unbounded</definition>
        <argsstring>() const</argsstring>
        <name>is_unbounded</name>
        <qualifiedname>CGAL::Quadratic_program_solution::is_unbounded</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff the associated program is unbounded. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="175" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a70e43bc256ef17d80fae117005dd6d15" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__PkgQPSolverClasses_1gad1152456fa1f4b03083fea7a83772d63" kindref="member">Quadratic_program_status</ref></type>
        <definition>Quadratic_program_status CGAL::Quadratic_program_solution&lt; ET &gt;::status</definition>
        <argsstring>() const</argsstring>
        <name>status</name>
        <qualifiedname>CGAL::Quadratic_program_solution::status</qualifiedname>
        <briefdescription>
<para>returns the status of the solution; this is one of the values <computeroutput>QP_OPTIMAL</computeroutput>, <computeroutput>QP_INFEASIBLE</computeroutput>, and <computeroutput>QP_UNBOUNDED</computeroutput>, depending on whether the program associated to <computeroutput>sol</computeroutput> has an optimal solution, is infeasible, or is unbounded. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="183" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac75add50cfbfd9e7ec466c67691ad5c4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_iterations</definition>
        <argsstring>() const</argsstring>
        <name>number_of_iterations</name>
        <qualifiedname>CGAL::Quadratic_program_solution::number_of_iterations</qualifiedname>
        <briefdescription>
<para>returns the number of iterations that it took to solve the program associated to <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="189" column="5"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Solution values</header>
      <description><para>The actual solution (variable and objective function values) can be accessed as follows. </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a3abafb58aa7555220a1b4c6c834fbf33" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt; <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &gt;</type>
        <definition>Quotient&lt; ET &gt; CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value</definition>
        <argsstring>() const</argsstring>
        <name>objective_value</name>
        <qualifiedname>CGAL::Quadratic_program_solution::objective_value</qualifiedname>
        <briefdescription>
<para>returns the objective function value of <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="201" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a060d7132f675cfe385ab2d0b67e390c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
        <definition>ET CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value_numerator</definition>
        <argsstring>() const</argsstring>
        <name>objective_value_numerator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::objective_value_numerator</qualifiedname>
        <briefdescription>
<para>returns the numerator of the objective function value of <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="207" column="4"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ae333593bdda03cd6a8f40a65861d547d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
        <definition>ET CGAL::Quadratic_program_solution&lt; ET &gt;::objective_value_denominator</definition>
        <argsstring>() const</argsstring>
        <name>objective_value_denominator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::objective_value_denominator</qualifiedname>
        <briefdescription>
<para>returns the denominator of the objective function value of <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="213" column="4"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" kindref="member">Variable_value_iterator</ref></type>
        <definition>Variable_value_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_values_begin</definition>
        <argsstring>() const</argsstring>
        <name>variable_values_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::variable_values_begin</qualifiedname>
        <briefdescription>
<para>returns a random-access iterator over the values of the variables in <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput>, and the valid iterator range has length <formula id="3">$ n$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="221" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a518306002d12894e5cbb9c0902d7ddac" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" kindref="member">Variable_value_iterator</ref></type>
        <definition>Variable_value_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_values_end</definition>
        <argsstring>() const</argsstring>
        <name>variable_values_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::variable_values_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="227" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a473ee87dd5712a854d1883cd10c1b6a3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" kindref="member">Variable_numerator_iterator</ref></type>
        <definition>Variable_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_numerators_begin</definition>
        <argsstring>() const</argsstring>
        <name>variable_numerators_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::variable_numerators_begin</qualifiedname>
        <briefdescription>
<para>returns a random-access iterator <computeroutput>it</computeroutput> over the values of the variables in <computeroutput>sol</computeroutput>, with respect to a common denominator of all variables. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="3">$ n$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="235" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aa1e01c3b73d96fcadd8cd02f608aa396" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" kindref="member">Variable_numerator_iterator</ref></type>
        <definition>Variable_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::variable_numerators_end</definition>
        <argsstring>() const</argsstring>
        <name>variable_numerators_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::variable_numerators_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="240" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a2ffc54d2d772210f5efb04d8b9bab192" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &amp;</type>
        <definition>const ET &amp; CGAL::Quadratic_program_solution&lt; ET &gt;::variables_common_denominator</definition>
        <argsstring>() const</argsstring>
        <name>variables_common_denominator</name>
        <qualifiedname>CGAL::Quadratic_program_solution::variables_common_denominator</qualifiedname>
        <briefdescription>
<para>returns the common denominator of the variable values as referred to by the previous two methods. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="246" column="10"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Basic variables and constraints</header>
      <description><para>The solution of a linear or quadratic program distinguishes &apos;important&apos; variables (the ones not attaining one of their bounds), and &apos;important&apos; constraints (the ones being satisfied with equality).</para>
<para>The following methods grant access to them. <ref refid="QP_solver_2important_variables_8cpp-example" kindref="compound">QP_solver/important_variables.cpp</ref> <ref refid="QP_solver_2first_qp_basic_constraints_8cpp-example" kindref="compound">QP_solver/first_qp_basic_constraints.cpp</ref> </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a8c32bda4450f86d163e0dc2569d36c4a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_variable_indices_begin</definition>
        <argsstring>() const</argsstring>
        <name>basic_variable_indices_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::basic_variable_indices_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the indices of the basic variables. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>int</computeroutput>. It is guaranteed that any variable that is not basic in <computeroutput>sol</computeroutput> attains one of its bounds. In particular, if the bounds are of type <formula id="48">$ \qpx\geq0$</formula>, all non-basic variables have value <formula id="41">$ 0$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="265" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a3f5b9b569163384c48d0797ecc34f842" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_variable_indices_end</definition>
        <argsstring>() const</argsstring>
        <name>basic_variable_indices_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::basic_variable_indices_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="270" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a2809357e44c9b5b1a6b7272edfef80da" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_basic_variables</definition>
        <argsstring>() const</argsstring>
        <name>number_of_basic_variables</name>
        <qualifiedname>CGAL::Quadratic_program_solution::number_of_basic_variables</qualifiedname>
        <briefdescription>
<para>returns the number of basic variables, equivalently the length of the range determined by the previous two iterators. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="276" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a12bfffa787c05c37bc6d74c30d858e85" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_constraint_indices_begin</definition>
        <argsstring>() const</argsstring>
        <name>basic_constraint_indices_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::basic_constraint_indices_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the indices of the basic constraints in the system <formula id="49">$ A\qpx\qprel\qpb$</formula>. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>int</computeroutput>. It is guaranteed that any basic constraint is satisfied with equality. In particular, if the system is of type <formula id="50">$ A\qpx=\qpb$</formula>, all constraints are basic. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="285" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a5e4afea24148899eb269522aee688e27" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" kindref="member">Index_iterator</ref></type>
        <definition>Index_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::basic_constraint_indices_end</definition>
        <argsstring>() const</argsstring>
        <name>basic_constraint_indices_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::basic_constraint_indices_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="290" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aaa6f7440000b4c9346e60e2cbd24fb09" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int CGAL::Quadratic_program_solution&lt; ET &gt;::number_of_basic_constraints</definition>
        <argsstring>() const</argsstring>
        <name>number_of_basic_constraints</name>
        <qualifiedname>CGAL::Quadratic_program_solution::number_of_basic_constraints</qualifiedname>
        <briefdescription>
<para>returns the number of basic constraint, equivalently the length of the range determined by the previous two iterators. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="296" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a6a38f5b7d26a69fb1db3ed3d645b9442" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref></type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const Quadratic_program_solution&lt; ET &gt; &amp;sol)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>CGAL::Quadratic_program_solution::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref>&lt; <ref refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" kindref="member">ET</ref> &gt; &amp;</type>
          <declname>sol</declname>
        </param>
        <briefdescription>
<para>writes the status of <computeroutput>sol</computeroutput> to the stream <computeroutput>out</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>In case the status is <computeroutput>QP_OPTIMAL</computeroutput>, the optimal objective value and the values of the variables at the optimal solution are output as well. For more detailed information about the solution (like basic variables/constraints) please use the dedicated methods of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref>&lt;ET&gt;</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="307" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Validity</header>
      <description><para>The following four methods allow you to check whether <computeroutput>sol</computeroutput> indeed solves the program that you intended to solve.</para>
<para>The methods use the certificates described in the advanced section below and thus save you from validating the certificates yourself (if you believe in the correctness of these methods; otherwise, you can look at their implementation to convince yourself). By passing a suitable option to the solution function, you can make sure that this check is done automatically after the solution of the program, see <computeroutput><ref refid="classCGAL_1_1Quadratic__program__options" kindref="compound">Quadratic_program_options</ref></computeroutput>. If the check fails, a logfile is generated that contains the details, and an error message is written to <computeroutput>std::cerr</computeroutput> (see <ref refid="QP_solver_2cycling_8cpp-example" kindref="compound">QP_solver/cycling.cpp</ref> for an example that uses this option). <ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref> <ref refid="QP_solver_2first_lp_8cpp-example" kindref="compound">QP_solver/first_lp.cpp</ref> <ref refid="QP_solver_2first_nonnegative_qp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_qp.cpp</ref> <ref refid="QP_solver_2first_nonnegative_lp_8cpp-example" kindref="compound">QP_solver/first_nonnegative_lp.cpp</ref> </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a4beeb40be1247a5e5a17b0cfbe96ad06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_quadratic_program</definition>
        <argsstring>(const QuadraticProgram &amp;qp)</argsstring>
        <name>solves_quadratic_program</name>
        <qualifiedname>CGAL::Quadratic_program_solution::solves_quadratic_program</qualifiedname>
        <param>
          <type>const <ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the quadratic program <computeroutput>qp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" kindref="member">get_error()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="333" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a226f5715d84737e8a21902b376e627df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_linear_program</definition>
        <argsstring>(const LinearProgram &amp;lp)</argsstring>
        <name>solves_linear_program</name>
        <qualifiedname>CGAL::Quadratic_program_solution::solves_linear_program</qualifiedname>
        <param>
          <type>const <ref refid="classLinearProgram" kindref="compound">LinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the linear program <computeroutput>lp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" kindref="member">get_error()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="342" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab2dcda8127ae7a937e7caa60818e2d66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_nonnegative_quadratic_program</definition>
        <argsstring>(const NonnegativeQuadraticProgram &amp;qp)</argsstring>
        <name>solves_nonnegative_quadratic_program</name>
        <qualifiedname>CGAL::Quadratic_program_solution::solves_nonnegative_quadratic_program</qualifiedname>
        <param>
          <type>const <ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref> &amp;</type>
          <declname>qp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the nonnegative quadratic program <computeroutput>qp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" kindref="member">get_error()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="352" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac32fcbecc6865df856d7b5ca312fc51e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::solves_nonnegative_linear_program</definition>
        <argsstring>(const NonnegativeLinearProgram &amp;lp)</argsstring>
        <name>solves_nonnegative_linear_program</name>
        <qualifiedname>CGAL::Quadratic_program_solution::solves_nonnegative_linear_program</qualifiedname>
        <param>
          <type>const <ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref> &amp;</type>
          <declname>lp</declname>
        </param>
        <briefdescription>
<para>returns <computeroutput>true</computeroutput> iff <computeroutput>sol</computeroutput> solves the nonnegative linear program <computeroutput>lp</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the result is <computeroutput>false</computeroutput>, you can get a message that describes the problem, through the method <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" kindref="member">get_error()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="361" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aec7c82223eb4722b352ca34a512b0345" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool CGAL::Quadratic_program_solution&lt; ET &gt;::is_valid</definition>
        <argsstring>() const</argsstring>
        <name>is_valid</name>
        <qualifiedname>CGAL::Quadratic_program_solution::is_valid</qualifiedname>
        <briefdescription>
<para>returns <computeroutput>false</computeroutput> iff the validation through one of the previous four functions has failed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="368" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string &amp; CGAL::Quadratic_program_solution&lt; ET &gt;::get_error</definition>
        <argsstring>() const</argsstring>
        <name>get_error</name>
        <qualifiedname>CGAL::Quadratic_program_solution::get_error</qualifiedname>
        <briefdescription>
<para>returns an error message in case any of the previous four validation functions has returned <computeroutput>false</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="374" column="19"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Certificates</header>
      <description><para>A certificate is a vector that admits a simple proof for the correctness of the solution.</para>
<para>Any non-void object of <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> comes with such a certificate. </para>
</description>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" kindref="member">Optimality_certificate_iterator</ref></type>
        <definition>Optimality_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certifcate_begin</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certifcate_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::optimality_certifcate_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the optimality certificate <formula id="46">$ \qplambda$</formula> as given in Lemma 1, with respect to the solution <formula id="45">$ \qpx^*$</formula> obtained from <computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" kindref="member">variable_values_begin()</ref></computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput><ref refid="classCGAL_1_1Quotient" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Number_types.tag">Quotient</ref>&lt;ET&gt;</computeroutput>, and the valid iterator range has length <formula id="8">$ m$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" kindref="member">is_optimal()</ref></computeroutput>.</para>
</simplesect>
<bold>Lemma 1(optimality certificate):</bold> A feasible <formula id="3">$ n$</formula>-vector <formula id="51">$\qpx^*$</formula> is an optimal solution of (QP) if an <formula id="8">$ m$</formula>-vector <formula id="46">$ \qplambda$</formula> with the following properties exist. <orderedlist>
<listitem>
<para>if the <formula id="29">$ i$</formula>-th constraint is of type <formula id="52">$ \leq$</formula> ( <formula id="53">$ \geq$</formula>, respectively), then <formula id="54">$\lambda_i\geq 0$</formula> ( <formula id="55">$\lambda_i\leq 0$</formula>, respectively). </para>
</listitem>
<listitem>
<para><formula id="56">$\qplambda^T(A\qpx^*-\qpb) = 0$</formula> </para>
</listitem>
<listitem>
<para><formula id="57">\[
  \begin{array}{llll}
  &amp;&amp;\geq 0, &amp; \mbox{if $x^*_j = l_j &lt; u_j$} \\
  (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)_j&amp; \quad  &amp;= 0, &amp; \mbox{if $l_j &lt; x^*_j &lt; u_j$} \\
  &amp;&amp;\leq 0, &amp; \mbox{if $l_j &lt; u_j = x^*_j$.}
  \end{array}
  \]</formula> </para>
</listitem>
</orderedlist>
</para>
<para><bold>Proof:</bold> Let <formula id="58">$\qpx$</formula> be any feasible solution. We need to prove that <formula id="59">\[\qpc^T\qpx + \qpx^TD\qpx \geq \qpc^T\qpx^* + {\qpx^*}^TD\qpx^*.\]</formula></para>
<para>For this, we argue as follows.  <formula id="60">\[
\begin{array}{lcll}
\qpc^T\qpx + 2{\qpx^*}^TD\qpx &amp;\geq&amp; \qpc^T\qpx + 2{\qpx^*}^TD\qpx + \qplambda^T(A\qpx-\qpb) &amp;
\mbox{(by $A\qpx\qprel \qpb$ and 1.)} \\
                  &amp;=&amp; (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)\qpx - \qplambda^Tb \\
                  &amp;\geq&amp; (\qpc^T + \qplambda^T A + 2{\qpx^*}^TD)\qpx^* - \qplambda^Tb &amp;
\mbox{(by $\qpl\leq \qpx \leq \qpu$ and 3.)} \\
                  &amp;=&amp; \qpc^T\qpx^* + 2{\qpx^*}^TD\qpx^* &amp;
\mbox{(by 2.)}
\end{array}
\]</formula></para>
<para>After adding <formula id="61">$\qpx^TD\qpx - \qpx^TD\qpx - {\qpx^*}^TD\qpx^* = -{\qpx^*}^TD\qpx^*$</formula> to both sides of this inequality, we get  <formula id="62">\[
\qpc^T\qpx + \qpx^TD\qpx - (\qpx-\qpx^*)^TD(\qpx-\qpx^*) \geq \qpc^T\qpx^* + {\qpx^*}^TD\qpx^*,
\]</formula> and since <formula id="63">$D$</formula> is positive semidefinite, we have <formula id="64">$(\qpx-\qpx^*)^TD(\qpx-\qpx^*)\geq 0$</formula> and the lemma follows.</para>
<para><simplesect kind="see"><para><ref refid="QP_solver_2optimality_certificate_8cpp-example" kindref="compound">QP_solver/optimality_certificate.cpp</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="437" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a8211aaa107030deaa8b31595df42073f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" kindref="member">Optimality_certificate_iterator</ref></type>
        <definition>Optimality_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certificate_end</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certificate_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::optimality_certificate_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="445" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab2289b43805b57bbb103ec2ad790e74a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" kindref="member">Optimality_certificate_numerator_iterator</ref></type>
        <definition>Optimality_certificate_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certifcate_numerators_begin</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certifcate_numerators_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::optimality_certifcate_numerators_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the numerator values of the optimality certificate <formula id="46">$ \qplambda$</formula>, with respect to the common denominator returned by <computeroutput>sol</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1a2ffc54d2d772210f5efb04d8b9bab192" kindref="member">variables_common_denominator()</ref></computeroutput>. The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="8">$ m$</formula>.</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="456" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ab07a09054cfc94c21da5243416497fb0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" kindref="member">Optimality_certificate_numerator_iterator</ref></type>
        <definition>Optimality_certificate_numerator_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::optimality_certificate_numerators_end</definition>
        <argsstring>() const</argsstring>
        <name>optimality_certificate_numerators_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::optimality_certificate_numerators_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" kindref="member">optimality_certifcate_begin()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="464" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" kindref="member">Infeasibility_certificate_iterator</ref></type>
        <definition>Infeasibility_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::infeasibility_certificate_begin</definition>
        <argsstring>() const</argsstring>
        <name>infeasibility_certificate_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::infeasibility_certificate_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the infeasibility certificate <formula id="46">$ \qplambda$</formula> as given in Lemma 2. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="8">$ m$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" kindref="member">is_infeasible()</ref></computeroutput>.</para>
</simplesect>
<bold>Lemma 2 (infeasibility certificate):</bold> The program (QP) is infeasible if an <formula id="65">$m$</formula>-vector <formula id="66">$\qplambda$</formula> with the following properties exist.</para>
<para><orderedlist>
<listitem>
<para>if the <formula id="67">$i$</formula>-th constraint is of type <formula id="68">$\leq$</formula> ( <formula id="69">$\geq$</formula>, respectively), then <formula id="54">$\lambda_i\geq 0$</formula> ( <formula id="55">$\lambda_i\leq 0$</formula>, respectively). </para>
</listitem>
<listitem>
<para><formula id="70">\[
\begin{array}{llll}
&amp;&amp;\geq 0 &amp; \mbox{if $u_j=\infty$} \\
\qplambda^T A_j &amp;\quad  \\
&amp;&amp;\leq 0 &amp; \mbox{if $l_j=-\infty$}.
\end{array}
\]</formula> </para>
</listitem>
<listitem>
<para><formula id="71">\[\qplambda^T\qpb \quad&lt;\quad \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j u_j }
\quad+\quad  \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j l_j}.\]</formula> </para>
</listitem>
</orderedlist>
</para>
<para><bold>Proof:</bold> Let us assume for the purpose of obtaining a contradiction that there is a feasible solution <formula id="58">$\qpx$</formula>. Then we get  <formula id="72">\[
\begin{array}{lcll}
0 &amp;\geq&amp; \qplambda^T(A\qpx -\qpb) &amp;  \mbox{(by $A\qpx\qprel \qpb$ and 1.)} \\
  &amp;=&amp; \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j x_j }
\quad+\quad  \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j x_j} - \qplambda^T \qpb \\
  &amp;\geq&amp; \ccSum{j: \qplambda^TA_j &lt;0}{}{ \qplambda^TA_j u_j }
\quad+\quad  \ccSum{j: \qplambda^TA_j &gt;0}{}{ \qplambda^TA_j l_j} - \qplambda^T \qpb &amp;
\mbox{(by $\qpl\leq \qpx \leq \qpu$ and 2.)} \\
  &amp;&gt;&amp; 0 &amp; \mbox{(by 3.)},
\end{array}
\]</formula> and this is the desired contradiction <formula id="73">$0&gt;0$</formula>.</para>
<para><simplesect kind="see"><para><ref refid="QP_solver_2infeasibility_certificate_8cpp-example" kindref="compound">QP_solver/infeasibility_certificate.cpp</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="510" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1ae33cb591de6b236373954db46660b3c2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" kindref="member">Infeasibility_certificate_iterator</ref></type>
        <definition>Infeasibility_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::infeasibility_certificate_end</definition>
        <argsstring>() const</argsstring>
        <name>infeasibility_certificate_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::infeasibility_certificate_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" kindref="member">infeasibility_certificate_begin()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="518" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" kindref="member">Unboundedness_certificate_iterator</ref></type>
        <definition>Unboundedness_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::unboundedness_certificate_begin</definition>
        <argsstring>() const</argsstring>
        <name>unboundedness_certificate_begin</name>
        <qualifiedname>CGAL::Quadratic_program_solution::unboundedness_certificate_begin</qualifiedname>
        <briefdescription>
<para>returns a random access iterator over the unbounded direction <formula id="47">$ \qpw$</formula> as given in Lemma 3,with respect to the solution <formula id="45">$ \qpx^*$</formula> obtained from <computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" kindref="member">variable_values_begin()</ref></computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The value type is <computeroutput>ET</computeroutput>, and the valid iterator range has length <formula id="3">$ n$</formula>. <simplesect kind="pre"><para><computeroutput>sol</computeroutput><computeroutput>.<ref refid="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" kindref="member">is_unbounded()</ref></computeroutput>.</para>
</simplesect>
<bold>Lemma 3 (unboundedness certificate:)</bold> Let <formula id="51">$\qpx^*$</formula> be a feasible solution of (QP). The program (QP) is unbounded if an <formula id="74">$n$</formula>-vector <formula id="75">$\qpw$</formula> with the following properties exist. <orderedlist>
<listitem>
<para>if the <formula id="67">$i$</formula>-th constraint is of type <formula id="68">$\leq$</formula> ( <formula id="76">$\geq, =$</formula>, respectively), then <formula id="77">$(A\qpw)_i\leq 0$</formula> ( <formula id="78">$(A\qpw)_i\geq 0, (A\qpw)_i=0$</formula>, respectively). </para>
</listitem>
<listitem>
<para><formula id="79">\[
\begin{array}{llll}
&amp;&amp;\geq 0 &amp; \mbox{if $l_j$ is finite} \\
w_j &amp;\quad  \\
&amp;&amp;\leq 0 &amp; \mbox{if $u_j$ is finite.}
\end{array}
\]</formula> </para>
</listitem>
<listitem>
<para><formula id="80">$\qpw^TD\qpw=0$</formula> and <formula id="81">$(\qpc^T+2{\qpx^*}^TD)\qpw&lt;0$</formula>. </para>
</listitem>
</orderedlist>
</para>
<para>The vector <formula id="75">$\qpw$</formula> is called an <emphasis>unbounded direction</emphasis>.</para>
<para><bold>Proof:</bold> For a real number <formula id="82">$t$</formula>, consider the vector <formula id="83">$\qpx(t):=\qpx^*+t\qpw$</formula>. By 1. and 2., <formula id="84">$\qpx(t)$</formula> is feasible for all <formula id="85">$t\geq 0$</formula>. The objective function value of <formula id="84">$\qpx(t)$</formula> is  <formula id="86">\begin{eqnarray*}
\qpc^T \qpx(t) + \qpx(t)^TD \qpx(t) &amp;=&amp;
\qpc^T\qpx^* + t\qpc^T\qpw + {\qpx^*}^TD\qpx^* +  2t{\qpx^*}^TD\qpw + t^2 \qpw^TD\qpw  \\
&amp;=&amp; \qpc^T\qpx^* + {\qpx^*}^TD\qpx^* + t(\qpc^T + 2{\qpx^*}^TD)\qpw + t^2\qpw^TD\qpw.
\end{eqnarray*}</formula> By condition 3., this tends to <formula id="87">$-\infty$</formula> for <formula id="88">$t\rightarrow\infty$</formula>, so the problem is indeed unbounded. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="557" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Quadratic__program__solution_1a589566d104eb97133f0b243d34d4f010" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" kindref="member">Unboundedness_certificate_iterator</ref></type>
        <definition>Unboundedness_certificate_iterator CGAL::Quadratic_program_solution&lt; ET &gt;::unboundedness_certificate_end</definition>
        <argsstring>()</argsstring>
        <name>unboundedness_certificate_end</name>
        <qualifiedname>CGAL::Quadratic_program_solution::unboundedness_certificate_end</qualifiedname>
        <briefdescription>
<para>returns the corresponding past-the-end iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" kindref="member">unboundedness_certificate_begin()</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/QP_solution.h" line="565" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object of class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> represents the solution of a linear or convex quadratic program of the general form. </para>
    </briefdescription>
    <detaileddescription>
<para><formula id="25">\begin{eqnarray*}
\mbox{(QP)}&amp; \mbox{minimize}
&amp; \qpx^{T}D\qpx+\qpc^{T}\qpx+c_0 \\
&amp;\mbox{subject to} &amp; A\qpx\qprel \qpb, \\
&amp; &amp; \qpl \leq \qpx \leq \qpu
\end{eqnarray*}</formula> in <formula id="3">$ n$</formula> real variables <formula id="4">$ \qpx=(x_0,\ldots,x_{n-1})$</formula>.</para>
<para>If <formula id="26">$ D=0$</formula>, the program is a linear program; if the variable bounds are <formula id="44">$ \qpx\geq 0$</formula>, we have a nonnegative program. Objects of type <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> are returned by any of the four functions <computeroutput>solve_quadratic_program</computeroutput>, <computeroutput>solve_linear_program</computeroutput>, <computeroutput>solve_nonnegative_quadratic_program</computeroutput>, and <computeroutput>solve_nonnegative_linear_program</computeroutput>.</para>
<para><bold>Example</bold><linebreak/>
</para>
<para><ref refid="QP_solver_2first_qp_8cpp-example" kindref="compound">QP_solver/first_qp.cpp</ref></para>
<para><bold>Terminology</bold><linebreak/>
</para>
<para>If there is no <formula id="12">$ \qpx$</formula> that satisfies all the (in)equalities, the program is called <emphasis>infeasible</emphasis>, otherwise, it is <emphasis>feasible</emphasis>, and any <formula id="12">$ \qpx$</formula> that satisfies all (in)equalities is called a <emphasis>feasible solution</emphasis>.</para>
<para>If the objective function value becomes arbitrarily small over the <emphasis>feasible region</emphasis> (the set of feasible solutions), the program is called <emphasis>unbounded</emphasis>, and <emphasis>bounded</emphasis> otherwise.</para>
<para>Any program that is both feasible and bounded has at least one feasible solution <formula id="45">$ \qpx^*$</formula> whose objective function value is not larger than that of any other feasible solution. This is called an <emphasis>optimal solution</emphasis>.</para>
<para>Every convex quadratic program (even if it is infeasible or unbounded) has a &apos;solution&apos; in form of an object of the class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput>.</para>
<para>The program concepts <simplesect kind="see"><para><computeroutput><ref refid="classQuadraticProgram" kindref="compound">QuadraticProgram</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classLinearProgram" kindref="compound">LinearProgram</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classNonnegativeQuadraticProgram" kindref="compound">NonnegativeQuadraticProgram</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classNonnegativeLinearProgram" kindref="compound">NonnegativeLinearProgram</ref></computeroutput></para>
</simplesect>
and the functions that compute objects of class <computeroutput><ref refid="classCGAL_1_1Quadratic__program__solution" kindref="compound">Quadratic_program_solution</ref></computeroutput> from models of these concepts:</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gac28b937807a2f163f253b27a7ee85080" kindref="member">solve_quadratic_program</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga93ea2fa8b79cc9d530055debd4609e04" kindref="member">solve_linear_program</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1ga99e425baf9b58a9fc7b33d3170a0101c" kindref="member">solve_nonnegative_quadratic_program</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgQPSolverFunctions_1gaa87b832f774794e32464c180b3b29ebb" kindref="member">solve_nonnegative_linear_program</ref></computeroutput> </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="CGAL/QP_solution.h" line="65" column="1" bodyfile="CGAL/QP_solution.h" bodystart="65" bodyend="569"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a12bfffa787c05c37bc6d74c30d858e85" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_constraint_indices_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a5e4afea24148899eb269522aee688e27" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_constraint_indices_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a8c32bda4450f86d163e0dc2569d36c4a" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_variable_indices_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a3f5b9b569163384c48d0797ecc34f842" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>basic_variable_indices_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ace0a875aafe4b8f73095fbf669cc9403" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>ET</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a6e4362b2f812d5952de2e89570fe5b68" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>get_error</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a3af2c3cacc49b94c4af20bb067b83f5f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Index_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac8d0a811a809ce9f9ebae4931bc2de92" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>infeasibility_certificate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae33cb591de6b236373954db46660b3c2" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>infeasibility_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab68ab70cab7cc778611f144d8127028e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Infeasibility_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ad0c8cf7f23b0b8b934f38c38f9e51f64" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_infeasible</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a46e9204eb8ad6bcc917733ac46affd86" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_optimal</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a9910d81e17dc950f289d168f1b5f7b2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_unbounded</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aec7c82223eb4722b352ca34a512b0345" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_valid</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1adc7dd0ec763d1231621d69863fd2cacd" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>is_void</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aaa6f7440000b4c9346e60e2cbd24fb09" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_basic_constraints</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a2809357e44c9b5b1a6b7272edfef80da" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_basic_variables</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac75add50cfbfd9e7ec466c67691ad5c4" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>number_of_iterations</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a3abafb58aa7555220a1b4c6c834fbf33" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae333593bdda03cd6a8f40a65861d547d" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value_denominator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a060d7132f675cfe385ab2d0b67e390c0" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>objective_value_numerator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a6a38f5b7d26a69fb1db3ed3d645b9442" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>operator&lt;&lt;</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ad31c503dd7001857de9b1ec1ecd6403d" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certifcate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab2289b43805b57bbb103ec2ad790e74a" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certifcate_numerators_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a8211aaa107030deaa8b31595df42073f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ace8c70b2cc7dc3457aed8cb72e2ba8b8" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Optimality_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1acb96b76c78f9db3cd75d4a209723592b" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Optimality_certificate_numerator_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab07a09054cfc94c21da5243416497fb0" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>optimality_certificate_numerators_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a49488f93f767d506f98975b85ace7b75" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Quadratic_program_solution</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a226f5715d84737e8a21902b376e627df" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_linear_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac32fcbecc6865df856d7b5ca312fc51e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_nonnegative_linear_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab2dcda8127ae7a937e7caa60818e2d66" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_nonnegative_quadratic_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a4beeb40be1247a5e5a17b0cfbe96ad06" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>solves_quadratic_program</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a70e43bc256ef17d80fae117005dd6d15" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>status</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aa1e81c88d8023a974b5a1d17a8749a2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>unboundedness_certificate_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a589566d104eb97133f0b243d34d4f010" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>unboundedness_certificate_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ae853fea0d020ada3e7bd4ee51f671f89" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Unboundedness_certificate_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac2731f1622211a110847f7537788478e" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Variable_numerator_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a473ee87dd5712a854d1883cd10c1b6a3" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_numerators_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1aa1e01c3b73d96fcadd8cd02f608aa396" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_numerators_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ac068efd477e3899cc81f7b465b4cd6f4" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>Variable_value_iterator</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1ab27775fe308a64a52707a4c31d8eaa2f" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_values_begin</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a518306002d12894e5cbb9c0902d7ddac" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variable_values_end</name></member>
      <member refid="classCGAL_1_1Quadratic__program__solution_1a2ffc54d2d772210f5efb04d8b9bab192" prot="public" virt="non-virtual"><scope>CGAL::Quadratic_program_solution</scope><name>variables_common_denominator</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
