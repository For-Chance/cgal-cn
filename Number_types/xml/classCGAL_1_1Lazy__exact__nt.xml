<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classCGAL_1_1Lazy__exact__nt" kind="class" language="C++" prot="public">
    <compoundname>CGAL::Lazy_exact_nt</compoundname>
    <includes local="no">CGAL/Lazy_exact_nt.h</includes>
    <templateparamlist>
      <param>
        <type>typename NT</type>
      </param>
    </templateparamlist>
      <sectiondef kind="user-defined">
      <header>Creation</header>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a80ce2b0a50c9ce34822d2d62b48a9c5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Lazy_exact_nt&lt; NT &gt;::Lazy_exact_nt</definition>
        <argsstring>()</argsstring>
        <name>Lazy_exact_nt</name>
        <qualifiedname>CGAL::Lazy_exact_nt::Lazy_exact_nt</qualifiedname>
        <briefdescription>
<para>introduces an uninitialized variable <computeroutput>m</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a14bf3ceb6a967a2d0ab6ee0f9b91dfc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Lazy_exact_nt&lt; NT &gt;::Lazy_exact_nt</definition>
        <argsstring>(BuiltIn i)</argsstring>
        <name>Lazy_exact_nt</name>
        <qualifiedname>CGAL::Lazy_exact_nt::Lazy_exact_nt</qualifiedname>
        <param>
          <type>BuiltIn</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>introduces the value <emphasis>x</emphasis>, of any built-in arithmetic type (<computeroutput>int</computeroutput>, <computeroutput>double</computeroutput>, etc) (works only if <computeroutput>NT</computeroutput> has a constructor from this type too). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="60" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a87c2ac9c606ee86bf4953899dbd27829" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CGAL::Lazy_exact_nt&lt; NT &gt;::Lazy_exact_nt</definition>
        <argsstring>(NT n)</argsstring>
        <name>Lazy_exact_nt</name>
        <qualifiedname>CGAL::Lazy_exact_nt::Lazy_exact_nt</qualifiedname>
        <param>
          <type>NT</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>introduces the value <computeroutput>n</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="65" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1ab7cc85a6dc920c1caa9d78002c6e7c5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class NT1</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>CGAL::Lazy_exact_nt&lt; NT &gt;::Lazy_exact_nt</definition>
        <argsstring>(Lazy_exact_nt&lt; NT1 &gt; n)</argsstring>
        <name>Lazy_exact_nt</name>
        <qualifiedname>CGAL::Lazy_exact_nt::Lazy_exact_nt</qualifiedname>
        <param>
          <type><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt; NT1 &gt;</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>introduces the value <computeroutput>n</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>NT1</computeroutput> needs to be convertible to <computeroutput>NT</computeroutput> (and this conversion will only be done if necessary). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="71" column="13"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a1b1e71678b9cb5dcfbca923e6abb0959" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>NT</type>
        <definition>NT CGAL::Lazy_exact_nt&lt; NT &gt;::exact</definition>
        <argsstring>()</argsstring>
        <name>exact</name>
        <qualifiedname>CGAL::Lazy_exact_nt::exact</qualifiedname>
        <briefdescription>
<para>returns the corresponding NT value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="81" column="4"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a1034c6e18f2896195feaf5d46f05ce19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Interval__nt" kindref="compound">Interval_nt</ref>&lt; false &gt;</type>
        <definition>Interval_nt&lt; false &gt; CGAL::Lazy_exact_nt&lt; NT &gt;::approx</definition>
        <argsstring>()</argsstring>
        <name>approx</name>
        <qualifiedname>CGAL::Lazy_exact_nt::approx</qualifiedname>
        <briefdescription>
<para>returns an interval containing the exact value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="87" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a06a5e6820cac40cecbcc3fb1f9ef330a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classCGAL_1_1Interval__nt" kindref="compound">Interval_nt</ref>&lt; true &gt;</type>
        <definition>Interval_nt&lt; true &gt; CGAL::Lazy_exact_nt&lt; NT &gt;::interval</definition>
        <argsstring>()</argsstring>
        <name>interval</name>
        <qualifiedname>CGAL::Lazy_exact_nt::interval</qualifiedname>
        <briefdescription>
<para>returns an interval containing the exact value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="93" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1abeb7a9bad93323f98df862dbe3369566" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void CGAL::Lazy_exact_nt&lt; NT &gt;::set_relative_precision_of_to_double</definition>
        <argsstring>(double d)</argsstring>
        <name>set_relative_precision_of_to_double</name>
        <qualifiedname>CGAL::Lazy_exact_nt::set_relative_precision_of_to_double</qualifiedname>
        <param>
          <type>double</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>specifies the relative precision that <computeroutput><ref refid="group__PkgAlgebraicFoundationsRef_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">to_double()</ref></computeroutput> has to fulfill. </para>
        </briefdescription>
        <detaileddescription>
<para>The relative precision is thread local, and the default value is <formula id="50">$ 10^{-5}$</formula>.</para>
<para><simplesect kind="pre"><para><computeroutput>d&gt;0</computeroutput> and <computeroutput>d&lt;1</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="102" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1af1a0e1ce6840e223e671fb4c85a4fda9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>static double CGAL::Lazy_exact_nt&lt; NT &gt;::get_relative_precision_of_to_double</definition>
        <argsstring>()</argsstring>
        <name>get_relative_precision_of_to_double</name>
        <qualifiedname>CGAL::Lazy_exact_nt::get_relative_precision_of_to_double</qualifiedname>
        <briefdescription>
<para>returns the relative precision that <computeroutput><ref refid="group__PkgAlgebraicFoundationsRef_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">to_double()</ref></computeroutput> currently fulfills. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="107" column="15"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="related">
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a2341c2358a9c1f61ff433519f927f5b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const Lazy_exact_nt&lt; NT &gt; &amp;m)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>CGAL::Lazy_exact_nt::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt; NT &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>writes <computeroutput>m</computeroutput> to ostream <computeroutput>out</computeroutput> in an interval format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="117" column="1" declfile="CGAL/Lazy_exact_nt.h" declline="117" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="classCGAL_1_1Lazy__exact__nt_1a84c7e08fb0073f43782804d39aea3ca6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;in, Lazy_exact_nt&lt; NT &gt; &amp;m)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>CGAL::Lazy_exact_nt::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt; NT &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>reads a <computeroutput>NT</computeroutput> from <computeroutput>in</computeroutput>, then converts it to a <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt;NT&gt;</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/Lazy_exact_nt.h" line="123" column="14" declfile="CGAL/Lazy_exact_nt.h" declline="123" declcolumn="14"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>An object of the class <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt;NT&gt;</computeroutput> is able to represent any real embeddable number which <computeroutput>NT</computeroutput> is able to represent. </para>
    </briefdescription>
    <detaileddescription>
<para>The idea is that <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt;NT&gt;</computeroutput> works exactly like <computeroutput>NT</computeroutput>, except that it is expected to be faster because it tries to only compute an approximation of the value, and only refers to <computeroutput>NT</computeroutput> when needed. The goal is to speed up exact computations done by any exact but slow number type <computeroutput>NT</computeroutput>.</para>
<para>The function <computeroutput><ref refid="group__PkgAlgebraicFoundationsRef_1ga1f1bcd74fce34fd532445590bbda5cd5" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">to_double()</ref></computeroutput> can be used to get a double approximation of the represented number. Note that two subsequent calls to this function on the same number of type <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">Lazy_exact_nt</ref>&lt;NT&gt;</computeroutput> might not return the same value as the exact representation might have been computed between the two calls, thus refining the double approximation. If you want to avoid this behavior, you need to first call <computeroutput><ref refid="classCGAL_1_1Lazy__exact__nt_1a1b1e71678b9cb5dcfbca923e6abb0959" kindref="member">exact()</ref></computeroutput> (losing the benefit of the laziness if done systematically).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NT</parametername>
</parameternamelist>
<parameterdescription>
<para>must be a model of concept <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput>, and at least model of concept <computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomainWithoutDivision</ref></computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Note that some filtering mechanism is available at the predicate level using <computeroutput><ref refid="classCGAL_1_1Filtered__predicate" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Filtered_predicate</ref></computeroutput> and <computeroutput><ref refid="structCGAL_1_1Filtered__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Filtered_kernel</ref></computeroutput>.</para>
<para><variablelist>
<varlistentry><term>Is model of</term></varlistentry>
<listitem><para><computeroutput><ref refid="classIntegralDomainWithoutDivision" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomainWithoutDivision</ref></computeroutput> same as <computeroutput>NT</computeroutput></para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classFraction" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">Fraction</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput>if</computeroutput> <computeroutput>NT</computeroutput> is a <computeroutput><ref refid="classFraction" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">Fraction</ref></computeroutput></para>
</listitem>
</variablelist>
</para>
<para><bold>Example</bold><linebreak/>
</para>
<para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="MP__Float_8h" kindref="compound">CGAL/MP_Float.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Lazy__exact__nt_8h" kindref="compound">CGAL/Lazy_exact_nt.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Quotient_8h" kindref="compound">CGAL/Quotient.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Lazy__exact__nt" kindref="compound">CGAL::Lazy_exact_nt&lt;CGAL::Quotient&lt;CGAL::MP_Float&gt;</ref><sp/>&gt;<sp/>NT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Cartesian&lt;NT&gt;</ref><sp/>K;</highlight></codeline>
</programlisting> </para>
    </detaileddescription>
    <location file="CGAL/Lazy_exact_nt.h" line="46" column="1" bodyfile="CGAL/Lazy_exact_nt.h" bodystart="46" bodyend="111"/>
    <listofallmembers>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a1034c6e18f2896195feaf5d46f05ce19" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>approx</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a1b1e71678b9cb5dcfbca923e6abb0959" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>exact</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1af1a0e1ce6840e223e671fb4c85a4fda9" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>get_relative_precision_of_to_double</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a06a5e6820cac40cecbcc3fb1f9ef330a" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>interval</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a80ce2b0a50c9ce34822d2d62b48a9c5f" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>Lazy_exact_nt</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a14bf3ceb6a967a2d0ab6ee0f9b91dfc0" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>Lazy_exact_nt</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a87c2ac9c606ee86bf4953899dbd27829" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>Lazy_exact_nt</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1ab7cc85a6dc920c1caa9d78002c6e7c5e" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>Lazy_exact_nt</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a2341c2358a9c1f61ff433519f927f5b6" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>operator&lt;&lt;</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1a84c7e08fb0073f43782804d39aea3ca6" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>operator&gt;&gt;</name></member>
      <member refid="classCGAL_1_1Lazy__exact__nt_1abeb7a9bad93323f98df862dbe3369566" prot="public" virt="non-virtual"><scope>CGAL::Lazy_exact_nt</scope><name>set_relative_precision_of_to_double</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
