<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="classRootOf__2" kind="class" language="C++" prot="public">
    <compoundname>RootOf_2</compoundname>
    <includes local="no">Concepts/RootOf_2.h</includes>
      <sectiondef kind="user-defined">
      <header>Operations</header>
      <description><para>Same for operator <computeroutput>-,*,/,!=,&lt;=,&gt;,&gt;=</computeroutput> as well as mixed forms with <computeroutput>RT</computeroutput> and <computeroutput>FT</computeroutput>. </para>
</description>
      <memberdef kind="function" id="classRootOf__2_1a7286fb2b6c07154cb01662cec0e3d764" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
        <definition>RootOf_2 &amp; RootOf_2::operator+=</definition>
        <argsstring>(const RootOf_2 &amp;a)</argsstring>
        <name>operator+=</name>
        <qualifiedname>RootOf_2::operator+=</qualifiedname>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>*this</computeroutput> and <computeroutput>a</computeroutput> are defined in the same extension. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/RootOf_2.h" line="58" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classRootOf__2_1adbf85e2e866080e80663f7c696f5c19b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref></type>
        <definition>RootOf_2 RootOf_2::operator+</definition>
        <argsstring>(const RootOf_2 &amp;a, const RootOf_2 &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>RootOf_2::operator+</qualifiedname>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="pre"><para><computeroutput>a</computeroutput> and <computeroutput>b</computeroutput> are defined in the same extension. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/RootOf_2.h" line="63" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classRootOf__2_1a1e00c83a60d50506dff0884dfa826093" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool RootOf_2::operator==</definition>
        <argsstring>(const RootOf_2 &amp;a, const RootOf_2 &amp;b)</argsstring>
        <name>operator==</name>
        <qualifiedname>RootOf_2::operator==</qualifiedname>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/RootOf_2.h" line="68" column="6"/>
      </memberdef>
      <memberdef kind="function" id="classRootOf__2_1ac1afbae1bbbb521962fc6a0a6f2de073" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool RootOf_2::operator&lt;</definition>
        <argsstring>(const RootOf_2 &amp;a, const RootOf_2 &amp;b)</argsstring>
        <name>operator&lt;</name>
        <qualifiedname>RootOf_2::operator&lt;</qualifiedname>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classRootOf__2" kindref="compound">RootOf_2</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Concepts/RootOf_2.h" line="73" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Concept to represent algebraic numbers of degree up to 2 over a <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput> <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput> <computeroutput>RT</computeroutput>. </para>
    </briefdescription>
    <detaileddescription>
<para></para>
<para>A model of this concept is associated to this <computeroutput>RT</computeroutput> via <computeroutput><ref refid="structCGAL_1_1Root__of__traits" kindref="compound">CGAL::Root_of_traits</ref>&lt;RT&gt;</computeroutput>, which provides <computeroutput>Root_of_2</computeroutput> as a public type. Moreover, <computeroutput><ref refid="structCGAL_1_1Root__of__traits" kindref="compound">CGAL::Root_of_traits</ref>&lt;RT&gt;</computeroutput> provides the public type <computeroutput>Root_of_1</computeroutput>, which is the quotient field of <computeroutput>RT</computeroutput>. We refer to <computeroutput>Root_of_1</computeroutput> as FT (for field type).</para>
<para>The model of <computeroutput><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref></computeroutput> is a <computeroutput><ref refid="classRealEmbeddable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">RealEmbeddable</ref></computeroutput> <computeroutput><ref refid="classIntegralDomain" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">IntegralDomain</ref></computeroutput>, which is <computeroutput><ref refid="classImplicitInteroperable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">ImplicitInteroperable</ref></computeroutput> with <computeroutput>RT</computeroutput>, <computeroutput>FT</computeroutput>. In particular, it provides the comparison operators <computeroutput>==, !=, &lt;, &gt;, &lt;=, &gt;=</computeroutput> as well as the <computeroutput>sign</computeroutput> and <computeroutput>compare</computeroutput> functions needed to compare elements of types <computeroutput><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref>, RT</computeroutput> and <computeroutput>FT</computeroutput>. It also provides all arithmetic operators <computeroutput>+,-,*,/</computeroutput> among elements of type <computeroutput><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref></computeroutput> as well as mixed forms with <computeroutput>RT</computeroutput> and <computeroutput>FT</computeroutput>.</para>
<para>However, it is important to note that arithmetic operations among elements of <computeroutput><ref refid="classRootOf__2" kindref="compound">RootOf_2</ref></computeroutput> are only allowed in the special case when they have been constructed from equations having the same discriminant, that is, if they are defined in the same algebraic extension of degree 2.</para>
<para>Besides construction from <computeroutput>int, RT</computeroutput> and <computeroutput>FT</computeroutput> the following functions provide special construction for extensions of degree 2:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="group__nt__ralgebraic_1gacfb5bb32ca37f38d2d69d5d24bcebc26" kindref="member">CGAL::make_root_of_2()</ref></computeroutput></para>
</listitem><listitem><para><computeroutput><ref refid="group__nt__ralgebraic_1ga8c3dcfe273cd40cb49c537ac7274b267" kindref="member">CGAL::make_sqrt()</ref></computeroutput></para>
</listitem></itemizedlist>
</para>
<para><variablelist>
<varlistentry><term>Refines</term></varlistentry>
<listitem><para><computeroutput><ref refid="classDefaultConstructible" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">DefaultConstructible</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classCopyConstructible" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CopyConstructible</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classFromIntConstructible" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">FromIntConstructible</ref></computeroutput> </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classImplicitInteroperable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">ImplicitInteroperable</ref></computeroutput> with <computeroutput>RT</computeroutput></para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classImplicitInteroperable" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">ImplicitInteroperable</ref></computeroutput> with <computeroutput>FT</computeroutput></para>
</listitem>
</variablelist>
</para>
<para><variablelist>
<varlistentry><term>Has models</term></varlistentry>
<listitem><para></para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput>double</computeroutput> (not exact) </para>
</listitem>
<varlistentry><term></term></varlistentry>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Sqrt__extension" kindref="compound">CGAL::Sqrt_extension</ref></computeroutput> </para>
</listitem>
</variablelist>
</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__nt__ralgebraic_1gacfb5bb32ca37f38d2d69d5d24bcebc26" kindref="member">CGAL::make_root_of_2</ref>&lt;RT&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__nt__ralgebraic_1ga8c3dcfe273cd40cb49c537ac7274b267" kindref="member">CGAL::make_sqrt</ref>&lt;RT&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__nt__ralgebraic_1ga7b3b3eb35124b0c46373c88e324a7a95" kindref="member">CGAL::compute_roots_of_2</ref>&lt;RT,<ref refid="classOutputIterator" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OutputIterator</ref>&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Root__of__traits" kindref="compound">CGAL::Root_of_traits</ref>&lt;RT&gt;</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicKernelForCircles_1_1PolynomialForCircles__2__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Circular_kernel_2.tag">AlgebraicKernelForCircles::PolynomialForCircles_2_2</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classAlgebraicKernelForCircles" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Circular_kernel_2.tag">AlgebraicKernelForCircles</ref></computeroutput> </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="Concepts/RootOf_2.h" line="47" column="1" bodyfile="Concepts/RootOf_2.h" bodystart="47" bodyend="77"/>
    <listofallmembers>
      <member refid="classRootOf__2_1adbf85e2e866080e80663f7c696f5c19b" prot="public" virt="non-virtual"><scope>RootOf_2</scope><name>operator+</name></member>
      <member refid="classRootOf__2_1a7286fb2b6c07154cb01662cec0e3d764" prot="public" virt="non-virtual"><scope>RootOf_2</scope><name>operator+=</name></member>
      <member refid="classRootOf__2_1ac1afbae1bbbb521962fc6a0a6f2de073" prot="public" virt="non-virtual"><scope>RootOf_2</scope><name>operator&lt;</name></member>
      <member refid="classRootOf__2_1a1e00c83a60d50506dff0884dfa826093" prot="public" virt="non-virtual"><scope>RootOf_2</scope><name>operator==</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
