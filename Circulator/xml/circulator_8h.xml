<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="circulator_8h" kind="file" language="C++">
    <compoundname>circulator.h</compoundname>
    <innerclass refid="classCGAL_1_1Circulator__from__container" prot="public">CGAL::Circulator_from_container</innerclass>
    <innerclass refid="classCGAL_1_1Circulator__from__iterator" prot="public">CGAL::Circulator_from_iterator</innerclass>
    <innerclass refid="structCGAL_1_1Circulator__traits" prot="public">CGAL::Circulator_traits</innerclass>
    <innerclass refid="classCGAL_1_1Container__from__circulator" prot="public">CGAL::Container_from_circulator</innerclass>
    <innernamespace refid="namespaceCGAL">CGAL</innernamespace>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__PkgHandlesAndCirculatorsFunctions_1gae4f6b9dc3b933f01f2d0275a7bf8b308" prot="public" static="no">
        <name>CGAL_For_all</name>
        <param><defname>i</defname></param>
        <param><defname>j</defname></param>
        <briefdescription>
<para>In order to write algorithms that work with iterator ranges as well as with circulator ranges we have to consider the difference of representing an empty range. </para>
        </briefdescription>
        <detaileddescription>
<para>For iterators this is the range <computeroutput>[i,i)</computeroutput>, while for circulators it would be <computeroutput>c == nullptr</computeroutput>, the empty sequence test. The function <computeroutput>is_empty_range()</computeroutput> provides the necessary generic test which accepts an iterator range or a circulator range and says whether the range is empty or not.</para>
<para>A macro <computeroutput><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gae4f6b9dc3b933f01f2d0275a7bf8b308" kindref="member">CGAL_For_all( i, j)</ref></computeroutput> simplifies the writing of such simple loops as the one in the example of the function <computeroutput>is_empty_range()</computeroutput>. <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> can be either iterators or circulators. The macro loops through the range <computeroutput>[i, j)</computeroutput>. It increments <computeroutput>i</computeroutput> until it reaches <computeroutput>j</computeroutput>. The implementation looks like:</para>
<para><programlisting><codeline><highlight class="normal">for<sp/>(<sp/>bool<sp/>_circ_loop_flag<sp/>=<sp/>!<sp/>::CGAL::is_empty_range(i,j);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_circ_loop_flag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>_circ_loop_flag<sp/>=<sp/>((++i)<sp/>!=<sp/>(j))</highlight></codeline>
<codeline><highlight class="normal">)</highlight></codeline>
</programlisting></para>
<para>Note that the macro behaves like a <computeroutput>for</computeroutput>-loop. It can be used with a single statement or with a statement block. For bidirectional iterators or circulators, a backwards loop macro <computeroutput><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gace997aff7a7768aa76d2b2e19a7ef558" kindref="member">CGAL_For_all_backwards(i, j)</ref></computeroutput> exists that decrements <computeroutput>j</computeroutput> until it reaches <computeroutput>i</computeroutput>.</para>
<para><simplesect kind="see"><para><computeroutput><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gadaabb38d2411a4370d963a07c55ea3a8" kindref="member">CGAL::iterator_distance()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgHandlesAndCirculatorsFunctions_1gaf4e8c8285d91a1d8acd582191da0f255" kindref="member">CGAL::is_empty_range()</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Circulator__tag" kindref="compound">CGAL::Circulator_tag</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="structCGAL_1_1Circulator__traits" kindref="compound">CGAL::Circulator_traits</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="group__PkgHandlesAndCirculatorsAssert_1ga9bfcd5e48c98a1ccc7b74f8e8f302730" kindref="member">CGAL::Assert_circulator_or_iterator</ref></computeroutput> </para>
</simplesect>
<simplesect kind="see"><para><computeroutput><ref refid="classCirculator" kindref="compound">Circulator</ref></computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/circulator.h" line="676" column="9" bodyfile="CGAL/circulator.h" bodystart="676" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__PkgHandlesAndCirculatorsFunctions_1gace997aff7a7768aa76d2b2e19a7ef558" prot="public" static="no">
        <name>CGAL_For_all_backwards</name>
        <param><defname>i</defname></param>
        <param><defname>j</defname></param>
        <briefdescription>
<para>See <ref refid="group__PkgHandlesAndCirculatorsFunctions_1gae4f6b9dc3b933f01f2d0275a7bf8b308" kindref="member">CGAL_For_all</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="CGAL/circulator.h" line="680" column="9" bodyfile="CGAL/circulator.h" bodystart="680" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="CGAL/circulator.h"/>
  </compounddef>
</doxygen>
