<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_Shape_Detection"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly></para>
<para><simplesect kind="authors"><para>Sven Oesau, Yannick Verdie, Cl√©ment Jamin, Pierre Alliez, Florent Lafarge, Simon Giraudot, Thien Hoang, and Dmitry Anisimov</para>
</simplesect>
</para>
<sect1 id="index_1Shape_detection_Introduction">
<title>Introduction</title>
<para>This CGAL component implements two algorithms for shape detection:</para>
<para><itemizedlist>
<listitem><para>the <emphasis>Efficient RANSAC (RANdom SAmple Consensus)</emphasis> method, contributed by Schnabel et al. <ref refid="citelist_1CITEREF_schnabel2007efficient" kindref="member">[2]</ref>;</para>
</listitem><listitem><para>the <emphasis>Region Growing</emphasis> method, contributed by Lafarge and Mallet <ref refid="citelist_1CITEREF_cgal:lm-clscm-12" kindref="member">[1]</ref>.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1Shape_detection_RANSAC">
<title>Efficient RANSAC</title>
<para>From an unstructured point set with unoriented normals, this algorithm detects a set of shapes (see Figure <ref refid="index_1fig__Efficient_RANSAC_overview" kindref="member">fig__Efficient_RANSAC_overview</ref>). Five types of primitive shapes are provided by this package: plane, sphere, cylinder, cone, and torus. Other primitive shapes can be easily added by the user (see Section <ref refid="index_1Shape_detection_RANSACExample_with_custom_shapes" kindref="member">Custom Shapes</ref>).</para>
<para><anchor id="index_1fig__Efficient_RANSAC_overview"/> <image type="html" name="overview2.png"></image>
 <image type="latex" name="overview2.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Efficient_RANSAC_overview" kindref="member">fig__Efficient_RANSAC_overview</ref> Input and output of the Efficient RANSAC method. (a) Input point set. (b) Point set depicted with one color per detected shape. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>This method takes as input a point set with unoriented normals and provides as output a set of detected shapes with associated input points. The output of the algorithm is a set of detected shapes with assigned points and all remaining points not covered by these shapes. Each input point can be assigned to at most one detected shape.</para>
<para>The shapes are detected via a RANSAC-type approach, that is a random sample consensus. The basic RANSAC approach repeats the following steps:</para>
<para><orderedlist>
<listitem><para>Randomly select samples from the input points;</para>
</listitem><listitem><para>Fit a shape to the selected samples;</para>
</listitem><listitem><para>Count the number of inliers to the shape, inliers being within a user-specified error tolerance to the shape.</para>
</listitem></orderedlist>
</para>
<para>Steps 1-3 are repeated for a prescribed number of iterations and the shape with the highest number of inliers, referred to as the largest shape, is kept.</para>
<para>In our context, the error between a point and a shape is defined by its distance and normal deviation to the shape. A random subset corresponds to the minimum number of points (with normals) required to uniquely define a primitive.</para>
<para>For very large point sets, the basic RANSAC method is not practical when testing all possible shape candidates against the input data in order to find the largest shape. The main idea behind the Efficient RANSAC method is testing shape candidates against subsets of the input data. Shape candidates are constructed until the probability to miss the largest candidate is lower than a user-specified threshold. The largest shape is repeatedly extracted until no more shapes, restricted to cover a minimum number of points, can be extracted. An additional gain in efficiency is achieved through exploiting the normal attributes during initial shape construction and enumeration of inliers.</para>
<para>The <emphasis>support</emphasis> of a shape refers to the footprint of the points covered by the primitive. To avoid generating shapes with the fragmented support, we enforce a connectivity constraint by considering only one connected component, referred to as <emphasis>cluster</emphasis>, selected as the one covering the largest number of inliers (see Section <ref refid="index_1Shape_detection_RANSACParameters" kindref="member">Parameters</ref> for more details).</para>
<sect2 id="index_1Shape_detection_RANSACParameters">
<title>Parameters</title>
<para>The algorithm has five parameters:</para>
<para><itemizedlist>
<listitem><para><computeroutput>epsilon</computeroutput> and <computeroutput>normal_threshold</computeroutput>: The error between a point-with-normal <formula id="0">$p$</formula> and a shape <formula id="1">$S$</formula> is defined by its Euclidean distance and normal deviation to <formula id="1">$S$</formula>. The normal deviation is computed between the normal at <formula id="0">$p$</formula> and the normal of <formula id="1">$S$</formula> at the closest projection of <formula id="0">$p$</formula> onto <formula id="1">$S$</formula>. The parameter <computeroutput>epsilon</computeroutput> defines the absolute maximum tolerance Euclidean distance between a point and a shape. A high value of <computeroutput>epsilon</computeroutput> leads to the detection of fewer large shapes and hence a less detailed detection. A low value of <computeroutput>epsilon</computeroutput> yields a more detailed detection, but may lead to either lower coverage or over-segmentation. Over-segmentation translates into detection of fragmented shapes when <computeroutput>epsilon</computeroutput> is within or below the noise level. When the input point set is made of free-form parts, a higher tolerance <computeroutput>epsilon</computeroutput> enables to detect more primitive shapes that approximate some of the free-form surfaces. The impact of this parameter is depicted by Figure <ref refid="index_1fig__Efficient_RANSAC_parameter_epsilon_variation" kindref="member">fig__Efficient_RANSAC_parameter_epsilon_variation</ref>. Its impact on performance is evaluated in Section <ref refid="index_1Shape_detection_RANSACPerformance" kindref="member">Performance</ref>.</para>
</listitem></itemizedlist>
</para>
<para><anchor id="index_1fig__Efficient_RANSAC_parameter_epsilon_variation"/> <image type="html" name="epsilon_variation2.png"></image>
 <image type="latex" name="epsilon_variation2.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Efficient_RANSAC_parameter_epsilon_variation" kindref="member">fig__Efficient_RANSAC_parameter_epsilon_variation</ref> Impact of the epsilon parameter over the levels of detail of the detection. (a) Input point set. (b) Detection of planar shapes with <computeroutput>epsilon</computeroutput> set to 2.0 (one color per detected shape). Most details such as chimneys on the roof are not distinguished. (c) Detection with <computeroutput>epsilon</computeroutput> set to 0.5. The facades are correctly detected and some details of the roof are detected. (d) Setting <computeroutput>epsilon</computeroutput> to 0.25 yields a more detailed but slightly over-segmented detection. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><itemizedlist>
<listitem><para><computeroutput>cluster_epsilon</computeroutput>: The Efficient RANSAC uses this parameter to cluster the points into connected components covered by a detected shape. For developable shapes that admit a trivial planar parameterization (plane, cylinder, cone), the points covered by a shape are mapped to a 2D parameter space chosen to minimize distortion and best preserve arc-length distances. This 2D parameter space is discretized using a regular grid, and a connected component search is performed to identify the largest cluster. The parameter <computeroutput>cluster_epsilon</computeroutput> defines the spacing between two cells of the regular grid, so that two points separated by a distance of at most <formula id="2">$2\sqrt{2}$</formula> <computeroutput>cluster_epsilon</computeroutput> are considered adjacent. For non-developable shapes, the connected components are identified by computing a neighboring graph in 3D and walking in the graph. The impact of the parameter <computeroutput>cluster_epsilon</computeroutput> is depicted in Figure <ref refid="index_1fig__Efficient_RANSAC_parameter_connectivity" kindref="member">fig__Efficient_RANSAC_parameter_connectivity</ref>.</para>
</listitem></itemizedlist>
</para>
<para><anchor id="index_1fig__Efficient_RANSAC_parameter_connectivity"/> <image type="html" name="varying_connectivity.png"></image>
 <image type="latex" name="varying_connectivity.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Efficient_RANSAC_parameter_connectivity" kindref="member">fig__Efficient_RANSAC_parameter_connectivity</ref> The parameter <computeroutput>cluster_epsilon</computeroutput> controls the connectivity of the points covered by a detected shape. The input point set is sampled on four coplanar squares. (a) A large value of <computeroutput>cluster_epsilon</computeroutput> leads to detecting a single planar shape. (b) A moderate value of <computeroutput>cluster_epsilon</computeroutput> yields the detection of four squares. Notice that a few points within the squares are not detected as not connected. (c) A small value of <computeroutput>cluster_epsilon</computeroutput> leads to over-segmentation. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><itemizedlist>
<listitem><para><computeroutput>min_points</computeroutput>: The minimum number of points controls the termination of the algorithm. The shape search is iterated until no further shapes can be found with a higher support. Note that this parameter is not strict: depending on the chosen probability, shapes may be extracted with a number of points lower than the specified parameter.</para>
</listitem><listitem><para><computeroutput>probability</computeroutput>: This parameter defines the probability to miss the largest candidate shape. A lower probability provides a higher reliability and determinism at the cost of longer running time due to a higher search endurance.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="index_1Shape_detection_RANSACExamples">
<title>Examples</title>
<para>The main class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC" kindref="compound">Shape_detection::Efficient_RANSAC</ref></computeroutput> takes a template parameter <computeroutput><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">Shape_detection::Efficient_RANSAC_traits</ref></computeroutput> that defines the geometric types and input format. Property maps provide a means to interface with the user-specific data structures. The first parameter of the <computeroutput><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">Shape_detection::Efficient_RANSAC_traits</ref></computeroutput> class is the common <computeroutput><ref refid="classKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref></computeroutput>. In order to match the constraints of property maps, an iterator type and two maps that map an iterator to a point and a normal are specified in the <computeroutput><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">Shape_detection::Efficient_RANSAC_traits</ref></computeroutput> class. The concept behind property maps is detailed in Manual <ref refid="index_1chapterProperty_map" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL and Property Maps</ref>.</para>
<para>Typical usage consists of five steps:</para>
<para><orderedlist>
<listitem><para>Provide input data via a range iterator;</para>
</listitem><listitem><para>Register shape factories;</para>
</listitem><listitem><para>Choose parameters;</para>
</listitem><listitem><para>Detect;</para>
</listitem><listitem><para>Retrieve detected shapes.</para>
</listitem></orderedlist>
</para>
<sect3 id="index_1Shape_detection_RANSACExample_basic">
<title>Basic Plane Detection</title>
<para>The following example reads a point set from a file and detects only planar shapes. The default parameters are used for detection.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2efficient_RANSAC_basic_8cpp-example" kindref="compound">Shape_detection/efficient_RANSAC_basic.cpp</ref> <programlisting filename="Shape_detection/efficient_RANSAC_basic.cpp"><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/></highlight><highlight class="comment">//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_with_normal_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Efficient__RANSAC_8h" kindref="compound">CGAL/Shape_detection/Efficient_RANSAC.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>declarations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Kernel::Point_3,<sp/>Kernel::Vector_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwn_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC_traits</ref></highlight></codeline>
<codeline><highlight class="normal">&lt;<ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,<sp/>Pwn_vector,<sp/>Point_map,<sp/>Normal_map&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</ref><sp/>Efficient_ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Plane" kindref="compound">CGAL::Shape_detection::Plane&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Efficient<sp/>RANSAC&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/cube.pwn&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Points<sp/>with<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>point<sp/>set<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(Normal_map())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>cube.pwn!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>shape<sp/>detection<sp/>engine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac<sp/>ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Provide<sp/>input<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.set_input(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>planar<sp/>shapes<sp/>via<sp/>template<sp/>method.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Detect<sp/>registered<sp/>shapes<sp/>with<sp/>default<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.detect();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>number<sp/>of<sp/>detected<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>ransac.shapes().end()<sp/>-<sp/>ransac.shapes().begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>shapes<sp/>detected.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1Shape_detection_RANSACExample_with_callback">
<title>Plane Detection With Callback</title>
<para>The Efficient RANSAC class provides a callback mechanism that enables the user to track the progress of the algorithm. It can be used, for example, to terminate the algorithm based on a timeout. In the following example, the algorithm stops if it takes more than half a second and prints out the progress made.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2efficient_RANSAC_with_callback_8cpp-example" kindref="compound">Shape_detection/efficient_RANSAC_with_callback.cpp</ref> <programlisting filename="Shape_detection/efficient_RANSAC_with_callback.cpp"><codeline><highlight class="preprocessor">#if<sp/>defined<sp/>(_MSC_VER)<sp/>&amp;&amp;<sp/>!defined<sp/>(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>warning(disable:4244)<sp/></highlight><highlight class="comment">//<sp/>boost::number_distance::distance()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>converts<sp/>64<sp/>to<sp/>32<sp/>bits<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_with_normal_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Efficient__RANSAC_8h" kindref="compound">CGAL/Shape_detection/Efficient_RANSAC.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>declarations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Kernel::Point_3,<sp/>Kernel::Vector_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwn_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC_traits</ref></highlight></codeline>
<codeline><highlight class="normal">&lt;<ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,<sp/>Pwn_vector,<sp/>Point_map,<sp/>Normal_map&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</ref><sp/>Efficient_ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Plane" kindref="compound">CGAL::Shape_detection::Plane&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Timeout_callback<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/>CGAL::Timer<sp/>timer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>limit;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timeout_callback(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>limit)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nb(0),<sp/>limit(limit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>timer.start();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>advancement)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Avoid<sp/>calling<sp/>time()<sp/>at<sp/>every<sp/>single<sp/>iteration,<sp/>which<sp/>could</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>impact<sp/>performances<sp/>very<sp/>badly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++nb;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nb<sp/>%<sp/>1000<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>the<sp/>limit<sp/>is<sp/>reached,<sp/>interrupt<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(timer.time()<sp/>&gt;<sp/>limit)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Algorithm<sp/>takes<sp/>too<sp/>long,<sp/>exiting<sp/>(&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>100.0<sp/>*<sp/>advancement<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;%<sp/>done)&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Efficient<sp/>RANSAC&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>filename<sp/>=<sp/>(argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/cube.pwn&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>filename,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(Normal_map())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>cube.pwn!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac<sp/>ransac;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.set_input(points);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>callback<sp/>that<sp/>interrupts<sp/>the<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>it<sp/>takes<sp/>more<sp/>than<sp/>half<sp/>a<sp/>second.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timeout_callback<sp/>timeout_callback(0.5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Detect<sp/>registered<sp/>shapes<sp/>with<sp/>the<sp/>default<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.detect(Efficient_ransac::Parameters(),<sp/>timeout_callback);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1Shape_detection_RANSACExample_with_parameters">
<title>Setting Parameters And Using Different Shape Types</title>
<para>This example illustrates the user selection of parameters using the <computeroutput><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC_1_1Parameters" kindref="compound">Shape_detection::Efficient_RANSAC::Parameters</ref></computeroutput> class. Shape detection is performed on five shape types (plane, cylinder, sphere, cone, and torus). The input point set is sampled on a surface mostly composed of piecewise planar and cylindrical parts, in addition to free-form parts.</para>
<para>Basic information of the detected shapes is written to the standard output: if the shape is either a plane or a cylinder, specific parameters are recovered, otherwise the general method <computeroutput>info()</computeroutput> is used to get the shape parameters in a string object. Note that specific parameters can be recovered for any of the provided shapes.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2efficient_RANSAC_with_parameters_8cpp-example" kindref="compound">Shape_detection/efficient_RANSAC_with_parameters.cpp</ref> <programlisting filename="Shape_detection/efficient_RANSAC_with_parameters.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_with_normal_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Efficient__RANSAC_8h" kindref="compound">CGAL/Shape_detection/Efficient_RANSAC.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>declarations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Kernel::Point_3,<sp/>Kernel::Vector_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwn_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC_traits</ref></highlight></codeline>
<codeline><highlight class="normal">&lt;<ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,<sp/>Pwn_vector,<sp/>Point_map,<sp/>Normal_map&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</ref><sp/>Efficient_ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Cone" kindref="compound">CGAL::Shape_detection::Cone&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cone;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Cylinder" kindref="compound">CGAL::Shape_detection::Cylinder&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cylinder;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Plane" kindref="compound">CGAL::Shape_detection::Plane&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Sphere" kindref="compound">CGAL::Shape_detection::Sphere&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Sphere;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Torus" kindref="compound">CGAL::Shape_detection::Torus&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Torus;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Points<sp/>with<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>point<sp/>set<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/cube.pwn&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(Normal_map())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>cube.pwn!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>points.size()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>points&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>shape<sp/>detection<sp/>engine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac<sp/>ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Provide<sp/>input<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.set_input(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>shapes<sp/>for<sp/>detection.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Sphere&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Cylinder&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Cone&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Torus&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>parameters<sp/>for<sp/>shape<sp/>detection.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Parameters<sp/>parameters;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>probability<sp/>to<sp/>miss<sp/>the<sp/>largest<sp/>primitive<sp/>at<sp/>each<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.probability<sp/>=<sp/>0.05;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Detect<sp/>shapes<sp/>with<sp/>at<sp/>least<sp/>200<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.min_points<sp/>=<sp/>200;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>maximum<sp/>Euclidean<sp/>distance<sp/>between<sp/>a<sp/>point<sp/>and<sp/>a<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.epsilon<sp/>=<sp/>0.002;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>maximum<sp/>Euclidean<sp/>distance<sp/>between<sp/>points<sp/>to<sp/>be<sp/>clustered.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.cluster_epsilon<sp/>=<sp/>0.01;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>maximum<sp/>normal<sp/>deviation.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>0.9<sp/>&lt;<sp/>dot(surface_normal,<sp/>point_normal);</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>parameters.normal_threshold<sp/>=<sp/>0.9;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Detect<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.detect(parameters);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>number<sp/>of<sp/>detected<sp/>shapes<sp/>and<sp/>unassigned<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>ransac.shapes().end()<sp/>-<sp/>ransac.shapes().begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>detected<sp/>shapes,<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>ransac.number_of_unassigned_points()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>unassigned<sp/>points.&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Efficient_ransac::shapes()<sp/>provides</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>iterator<sp/>range<sp/>to<sp/>the<sp/>detected<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Shape_range<sp/>shapes<sp/>=<sp/>ransac.shapes();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Shape_range::iterator<sp/>it<sp/>=<sp/>shapes.begin();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>shapes.end())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>specific<sp/>parameters<sp/>depending<sp/>on<sp/>the<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Plane*<sp/>plane<sp/>=<sp/></highlight><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal">Plane*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(it-&gt;get()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref><sp/><ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref><sp/>=<sp/>plane-&gt;plane_normal();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Plane<sp/>with<sp/>normal<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Plane<sp/>shape<sp/>can<sp/>also<sp/>be<sp/>converted<sp/>to<sp/>the<sp/>Kernel::Plane_3.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Kernel::Plane_3:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><ref refid="classKernel_1_1Plane__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Plane_3</ref></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(*plane)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cylinder*<sp/>cyl<sp/>=<sp/></highlight><highlight class="keyword">dynamic_cast&lt;</highlight><highlight class="normal">Cylinder*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(it-&gt;get()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Line__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Line_3</ref><sp/>axis<sp/>=<sp/>cyl-&gt;axis();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>FT<sp/>radius<sp/>=<sp/>cyl-&gt;radius();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Cylinder<sp/>with<sp/>axis<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>axis<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>radius<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>radius<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>the<sp/>parameters<sp/>of<sp/>the<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>function<sp/>is<sp/>available<sp/>for<sp/>any<sp/>type<sp/>of<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(*it)-&gt;info()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Proceed<sp/>with<sp/>the<sp/>next<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>it++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1Shape_detection_RANSACExample_with_point_access">
<title>Retrieving Points Assigned To Shapes</title>
<para>This example illustrates how to access the points assigned to each shape and compute the mean error. A timer measures the running performance.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2efficient_RANSAC_with_point_access_8cpp-example" kindref="compound">Shape_detection/efficient_RANSAC_with_point_access.cpp</ref> <programlisting filename="Shape_detection/efficient_RANSAC_with_point_access.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;fstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Timer.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/number_utils.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/property_map.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/read_points.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Efficient__RANSAC_8h" kindref="compound">CGAL/Shape_detection/Efficient_RANSAC.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Type<sp/>declarations.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref><sp/><sp/><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Kernel::FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::pair&lt;Kernel::Point_3,<sp/>Kernel::Vector_3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Point_with_normal;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::vector&lt;Point_with_normal&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pwn_vector;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/><sp/>Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>Normal_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC_traits</ref></highlight></codeline>
<codeline><highlight class="normal">&lt;<ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref>,<sp/>Pwn_vector,<sp/>Point_map,<sp/>Normal_map&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC" kindref="compound">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</ref><sp/>Efficient_ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Plane" kindref="compound">CGAL::Shape_detection::Plane&lt;Traits&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Plane;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Points<sp/>with<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Pwn_vector<sp/>points;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>point<sp/>set<sp/>from<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgPointSetProcessing3IO_1ga8fac388459c5cf96bf11ce3b4e0459c1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_processing_3.tag">CGAL::IO::read_points</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((argc<sp/>&gt;<sp/>1)<sp/>?<sp/>argv[1]<sp/>:<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/cube.pwn&quot;</highlight><highlight class="normal">)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::back_inserter(points),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CGAL::parameters::point_map(Point_map()).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normal_map(Normal_map())))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>read<sp/>file<sp/>cube.pwn!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Instantiate<sp/>shape<sp/>detection<sp/>engine.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac<sp/>ransac;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Provide<sp/>input<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.set_input(points);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>detection<sp/>of<sp/>planes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.add_shape_factory&lt;Plane&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Measure<sp/>time<sp/>before<sp/>setting<sp/>up<sp/>the<sp/>shape<sp/>detection.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Timer<sp/>time;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>time.start();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Build<sp/>internal<sp/>data<sp/>structures.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ransac.preprocess();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Measure<sp/>time<sp/>after<sp/>preprocessing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>time.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;preprocessing<sp/>took:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>time.time()<sp/>*<sp/>1000<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ms&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>detection<sp/>several<sp/>times<sp/>and<sp/>choose<sp/>result<sp/>with<sp/>the<sp/>highest<sp/>coverage.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Shape_range<sp/>shapes<sp/>=<sp/>ransac.shapes();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>best_coverage<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reset<sp/>timer.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>time.reset();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>time.start();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Detect<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ransac.detect();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Measure<sp/>time<sp/>after<sp/>detection.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>time.stop();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>coverage,<sp/>i.e.<sp/>ratio<sp/>of<sp/>the<sp/>points<sp/>assigned<sp/>to<sp/>a<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>coverage<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT(points.size()<sp/>-<sp/>ransac.number_of_unassigned_points())<sp/>/<sp/>FT(points.size());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>number<sp/>of<sp/>assigned<sp/>shapes<sp/>and<sp/>unassigned<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;time:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>time.time()<sp/>*<sp/>1000<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ms&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>ransac.shapes().end()<sp/>-<sp/>ransac.shapes().begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>primitives,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>coverage<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>coverage&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Choose<sp/>result<sp/>with<sp/>the<sp/>highest<sp/>coverage.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(coverage<sp/>&gt;<sp/>best_coverage)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>best_coverage<sp/>=<sp/>coverage;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Efficient_ransac::shapes()<sp/>provides</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>iterator<sp/>range<sp/>to<sp/>the<sp/>detected<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>shapes<sp/>=<sp/>ransac.shapes();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Efficient_ransac::Shape_range::iterator<sp/>it<sp/>=<sp/>shapes.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>shapes.end())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::shared_ptr&lt;Efficient_ransac::Shape&gt;<sp/>shape<sp/>=<sp/>*it;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>Shape_base::info()<sp/>to<sp/>print<sp/>the<sp/>parameters<sp/>of<sp/>the<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>(*it)-&gt;info();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Sums<sp/>distances<sp/>of<sp/>points<sp/>to<sp/>the<sp/>detected<sp/>shapes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>sum_distances<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Iterate<sp/>through<sp/>point<sp/>indices<sp/>assigned<sp/>to<sp/>each<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::size_t&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>index_it<sp/>=<sp/>(*it)-&gt;indices_of_assigned_points().begin();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(index_it<sp/>!=<sp/>(*it)-&gt;indices_of_assigned_points().end())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Retrieve<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point_with_normal&amp;<sp/>p<sp/>=<sp/>*(points.begin()<sp/>+<sp/>(*index_it));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Adds<sp/>Euclidean<sp/>distance<sp/>between<sp/>point<sp/>and<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>sum_distances<sp/>+=<sp/><ref refid="group__PkgAlgebraicFoundationsRef_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::sqrt</ref>((*it)-&gt;squared_distance(p.first));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Proceed<sp/>with<sp/>the<sp/>next<sp/>point.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>index_it++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>and<sp/>print<sp/>the<sp/>average<sp/>distance.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>average_distance<sp/>=<sp/>sum_distances<sp/>/<sp/>shape-&gt;indices_of_assigned_points().size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>average<sp/>distance:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>average_distance<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Proceed<sp/>with<sp/>the<sp/>next<sp/>detected<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>it++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1Shape_detection_RANSACExample_with_custom_shapes">
<title>Custom Shapes</title>
<para>Other shape types can be detected by implementing a shape class derived from the class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base" kindref="compound">Shape_detection::Shape_base</ref></computeroutput> and registering it to the shape detection factory of the Efficient RANSAC object. This class must provide the following functions: construct a shape from a small set of given points, compute the squared distance from a query point to the shape, and compute the normal deviation between a query point with the normal and the normal to the shape at the closest point from the query. The used shape parameters are added as members to the derived class.</para>
<para>Note that the RANSAC approach is efficient for shapes that are uniquely defined by a small number of points, denoted by the number of required samples. The algorithm aims at detecting the largest shape via many random samples, and the combinatorial complexity of possible samples increases rapidly with the number of required samples.</para>
<para>More specifically, the functions to be implemented are defined in the base class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base" kindref="compound">Shape_detection::Shape_base</ref></computeroutput>:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1afba75428e79da4371347314858440a41" kindref="member">Shape_detection::Shape_base::minimum_sample_size()</ref></computeroutput> const: Returns the minimum number of required samples.</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a4f4e29f440b04dccebd9597f98bb3b2e" kindref="member">Shape_detection::Shape_base::create_shape</ref>(const std::vector&lt;size_t&gt;&amp; indices)</computeroutput>: The randomly generated samples are provided via a vector of indices. <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a06b467e120347afe63016a0cc951b370" kindref="member">Shape_detection::Shape_base::point</ref></computeroutput><computeroutput>(std::size_t index)</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a0e27838859722e7cf42bdce04942b53d" kindref="member">Shape_detection::Shape_base::normal</ref></computeroutput><computeroutput>(std::size_t index)</computeroutput> are used to retrieve the actual points and normals (see the example below). The provided number of samples might actually be larger than the above minimum number of required samples, depending on the other shape types. If the provided samples are not sufficient to define a unique shape, for example in a degenerated case, the shape is considered invalid.</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1ab04f03619adb9bee6112f074ba2508ff" kindref="member">Shape_detection::Shape_base::squared_distance</ref></computeroutput><computeroutput>(const Point&amp; point)</computeroutput> const: This function computes the squared distance from a query point to the shape. It is used for traversing the hierarchical spatial data structure.</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1ab04f03619adb9bee6112f074ba2508ff" kindref="member">Shape_detection::Shape_base::squared_distance</ref>(std::vector&lt;FT&gt;&amp; distances, const std::vector&lt;size_t&gt;&amp; indices)</computeroutput> and</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a07f487f782693af3fa42a29f9ad14a97" kindref="member">Shape_detection::Shape_base::cos_to_normal</ref></computeroutput><computeroutput>(const std::vector&lt;size_t&gt;&amp; indices, std::vector&lt;FT&gt;&amp; angles)</computeroutput> const.</para>
</listitem></itemizedlist>
</para>
<para>The last two functions are used to determine the number of inlier points to the shape. They compute respectively the squared distance from a set of points to the shape, and the dot product between the point normals and the normals at the shape for the closest points on the shape.</para>
<para>The access to the actual point and normal data is carried out via <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a06b467e120347afe63016a0cc951b370" kindref="member">Shape_detection::Shape_base::point</ref></computeroutput><computeroutput>(std::size_t index)</computeroutput> and <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a0e27838859722e7cf42bdce04942b53d" kindref="member">Shape_detection::Shape_base::normal</ref></computeroutput><computeroutput>(std::size_t index)</computeroutput> (see the example below). The resulting squared distance/dot product is stored in the vector provided as the first argument.</para>
<para>By default, the connected component is detected via the neighbor graph as mentioned above. However, for shapes that admit a faster approach to detect a connected component, the user can provide his/her own implementation to extract the connected component via:<itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1a48186a53453c9a0c11cfebc8dcd399eb" kindref="member">Shape_detection::Shape_base::connected_component</ref></computeroutput><computeroutput>(std::vector&lt;std::size_t&gt;&amp; indices, FT cluster_epsilon)</computeroutput>: The indices of all supporting points are stored in the vector <computeroutput>indices</computeroutput>. All points that do not belong to the largest cluster of points are removed from the vector <computeroutput>indices</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>Another optional method can be implemented to provide a helper function providing the shape parameters written to a string:<itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base_1ac1bbd0a749fbc118fe266039fcb88b09" kindref="member">Shape_detection::Shape_base::info</ref></computeroutput><computeroutput>()</computeroutput>: This function returns a string suitable for printing the shape parameters into a log/console. The default solution provides an empty string.</para>
</listitem></itemizedlist>
</para>
<para>The property maps are used to map the indices to the corresponding points and normals. The following header shows an implementation of a planar shape primitive, which is used by the example <ref refid="Shape_detection_2efficient_RANSAC_with_custom_shape_8cpp-example" kindref="compound">Shape_detection/efficient_RANSAC_with_custom_shape.cpp</ref>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2include_2efficient_RANSAC_with_custom_shape_8h-example" kindref="compound">Shape_detection/include/efficient_RANSAC_with_custom_shape.h</ref> <programlisting filename="Shape_detection/include/efficient_RANSAC_with_custom_shape.h"><codeline><highlight class="preprocessor">#ifndef<sp/>MY_PLANE_SHAPE_H</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MY_PLANE_SHAPE_H</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/number_utils.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Efficient__RANSAC_8h" kindref="compound">CGAL/Shape_detection/Efficient_RANSAC.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>My_Plane<sp/>is<sp/>derived<sp/>from<sp/>Shape_base.<sp/>The<sp/>plane<sp/>is<sp/>represented<sp/>by</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>its<sp/>normal<sp/>vector<sp/>and<sp/>distance<sp/>to<sp/>the<sp/>origin.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Traits&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">My_Plane<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Shape__detection_1_1Shape__base" kindref="compound">CGAL::Shape_detection::Shape_base</ref>&lt;Traits&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits::FT<sp/>FT;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>number<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits::Point_3<sp/>Point;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>point<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Traits::Vector_3<sp/>Vector;<sp/></highlight><highlight class="comment">//<sp/>vector<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>My_Plane()<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespaceCGAL" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL</ref>::Shape_detection::Shape_base&lt;Traits&gt;()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>squared<sp/>Euclidean<sp/>distance<sp/>from<sp/>query<sp/>point<sp/>to<sp/>the<sp/>shape.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>FT<sp/>squared_distance(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point&amp;<sp/>p)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>sd<sp/>=<sp/>(this-&gt;constr_vec(m_point_on_primitive,<sp/>p))<sp/>*<sp/>m_normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sd<sp/>*<sp/>sd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vector<sp/>plane_normal()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>d()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_d;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Return<sp/>a<sp/>string<sp/>with<sp/>shape<sp/>parameters.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>std::string<sp/>info()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::stringstream<sp/>sstr;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sstr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Type:<sp/>plane<sp/>(&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>this-&gt;get_x(m_normal)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>this-&gt;get_y(m_normal)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>this-&gt;get_z(m_normal)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;)x<sp/>-<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_d<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>0&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>#Pts:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>this-&gt;m_indices.size();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sstr.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Construct<sp/>shape<sp/>base<sp/>on<sp/>a<sp/>minimal<sp/>set<sp/>of<sp/>samples<sp/>from<sp/>the<sp/>input<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>create_shape(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::size_t&gt;&amp;<sp/>indices)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>p1<sp/>=<sp/>this-&gt;point(indices[0]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>p2<sp/>=<sp/>this-&gt;point(indices[1]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Point<sp/>p3<sp/>=<sp/>this-&gt;point(indices[2]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_normal<sp/>=<sp/>this-&gt;cross_pdct(p1<sp/>-<sp/>p2,<sp/>p1<sp/>-<sp/>p3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_normal<sp/>=<sp/>m_normal<sp/>*<sp/>(1.0<sp/>/<sp/><ref refid="group__PkgAlgebraicFoundationsRef_1gab922269072ee9ee99ba8c541418b2e11" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">sqrt</ref>(this-&gt;sqlen(m_normal)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_d<sp/>=<sp/>-(p1[0]<sp/>*<sp/>m_normal[0]<sp/>+<sp/>p1[1]<sp/>*<sp/>m_normal[1]<sp/>+<sp/>p1[2]<sp/>*<sp/>m_normal[2]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_point_on_primitive<sp/>=<sp/>p1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>this-&gt;m_is_valid<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>squared<sp/>Euclidean<sp/>distance<sp/>from<sp/>a<sp/>set<sp/>of<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group__squared__distance__grp_1ga1ff73525660a052564d33fbdd61a4f71" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">squared_distance</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::size_t&gt;&amp;<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;FT&gt;&amp;<sp/>dists)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>indices.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>sd<sp/>=<sp/>(this-&gt;point(indices[i])<sp/>-<sp/>m_point_on_primitive)<sp/>*<sp/>m_normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dists[i]<sp/>=<sp/>sd<sp/>*<sp/>sd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>normal<sp/>deviation<sp/>between<sp/>a<sp/>shape<sp/>and</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>set<sp/>of<sp/>points<sp/>with<sp/>normals.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>cos_to_normal(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::size_t&gt;&amp;<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;FT&gt;&amp;<sp/>angles)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>indices.size();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>angles[i]<sp/>=<sp/><ref refid="group__PkgAlgebraicFoundationsRef_1ga1d5106cf8be16adb4c4dc8b1ec3a5a92" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Algebraic_foundations.tag">CGAL::abs</ref>(this-&gt;<ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref>(indices[i])<sp/>*<sp/>m_normal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>required<sp/>samples<sp/>for<sp/>construction.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>std::size_t<sp/>minimum_sample_size()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point<sp/><sp/>m_point_on_primitive;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Vector<sp/>m_normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/><sp/><sp/><sp/><sp/>m_d;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>MY_PLANE_SHAPE_H</highlight><highlight class="normal"></highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="index_1Shape_detection_RANSACPerformance">
<title>Performance</title>
<para>The running time and detection performance of the Efficient RANSAC depend on the chosen parameters. A selective error tolerance parameter leads to higher running time and fewer shapes, as many shape candidates are generated to find the largest shape. We plot the detection performance against the <computeroutput>epsilon</computeroutput> error tolerance parameter for detecting planes in a complex scene with 5M points (see Figure <ref refid="index_1fig__Efficient_RANSAC_performance_epsilon" kindref="member">fig__Efficient_RANSAC_performance_epsilon</ref>). The <computeroutput>probability</computeroutput> parameter controls the endurance when searching for the largest candidate at each iteration. It barely impacts the number of detected shapes, has a moderate impact on the size of the detected shapes, and increases the running time. We plot the performance against the <computeroutput>probability</computeroutput> parameter (see Figure <ref refid="index_1fig__Efficient_RANSAC_performance_probability" kindref="member">fig__Efficient_RANSAC_performance_probability</ref>).</para>
<para><anchor id="index_1fig__Efficient_RANSAC_performance_epsilon"/> <image type="html" name="epsilon_graph.png"></image>
 <image type="latex" name="epsilon_graph.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Efficient_RANSAC_performance_epsilon" kindref="member">fig__Efficient_RANSAC_performance_epsilon</ref> The graph depicts the number of detected shapes (purple) and the coverage (green), that is the ratio assignedPoints / totalPoints, against the <computeroutput>epsilon</computeroutput> tolerance parameter. A higher value for <computeroutput>epsilon</computeroutput>, that is a more tolerant error, leads to fewer but larger shapes and shorter running times. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para><anchor id="index_1fig__Efficient_RANSAC_performance_probability"/> <image type="html" name="prob_graph.png"></image>
 <image type="latex" name="prob_graph.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Efficient_RANSAC_performance_probability" kindref="member">fig__Efficient_RANSAC_performance_probability</ref> The graph depicts the runtime, coverage, and the number of detected primitives against the search endurance parameter, that is <computeroutput>probability</computeroutput> to miss the largest shape at each iteration. The number of shapes is stable and the coverage increases when the <computeroutput>probability</computeroutput> is lowered. The running time increases significantly as many more candidates are generated during each iteration of the algorithm. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="index_1Shape_detection_RegionGrowing">
<title>Region Growing</title>
<para>This shape detection component is based on the region growing algorithm applied to a set of user-specified items. Shapes are detected by growing regions from seed items, where each region is created as follows:</para>
<para><orderedlist>
<listitem><para>Pick the next available item;</para>
</listitem><listitem><para>Find its neighbors in the data set;</para>
</listitem><listitem><para>Include those neighbors, which satisfy the region requirements;</para>
</listitem><listitem><para>Repeat the procedure for all included neighbors;</para>
</listitem><listitem><para>If no further neighbor satisfies the requirements, start a new region.</para>
</listitem></orderedlist>
</para>
<para>Together with the generic algorithm&apos;s implementation <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput>, five particular instances of this algorithm are provided:</para>
<para><itemizedlist>
<listitem><para>Line and circle detection in a <ref refid="index_1Shape_detection_RegionGrowingPoints" kindref="member">2D point set</ref>;</para>
</listitem><listitem><para>Line detection in a <ref refid="index_1Shape_detection_RegionGrowingSegments" kindref="member">2D/3D segment set</ref>;</para>
</listitem><listitem><para>Plane, sphere, and cylinder detection in a <ref refid="index_1Shape_detection_RegionGrowingPoints" kindref="member">3D point set</ref>;</para>
</listitem><listitem><para>Plane detection on a <ref refid="index_1Shape_detection_RegionGrowingMesh" kindref="member">polygon mesh</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Other instances can be easily added by the user, as explained below.</para>
<sect2 id="index_1Shape_detection_RegionGrowingFramework">
<title>Framework</title>
<para>The class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput> provides an implementation of the region growing algorithm. This algorithm can detect geometric primitives among a set of input geometric objects. Each such geometric object is identified using an <emphasis>item</emphasis>. The item is, in general but not necessarily, a lightweight class that uniquely identify a geometric object like an iterator over a container of geometric object, an integer pointing to the cell of a vector, a <computeroutput>face_descriptor</computeroutput> representing a face in a model of <computeroutput><ref refid="classFaceGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">FaceGraph</ref></computeroutput>,... The geometric object is retrieved using a property map with the item as key type and the geometric object as value type. The class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput> is constructed by providing an input range with each element being converted to an item thanks to another property map passed to the constructor. For most cases the default is fine and conveniences alias and functions are provided for the <computeroutput><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3</ref></computeroutput> class (see <ref refid="group__PkgShapeDetectionRGOnPointSet3" kindref="compound">Convenience Aliases and Functions for Point_set_3</ref>).</para>
<para>The algorithm provided by <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput> works using two classes that are respectively models of the following concepts:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput>: responsible for providing the neighbors of an item;</para>
</listitem><listitem><para><computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput>: responsible for the definition of a region from a list of items as well as for validating the addition of an item to an already defined region;</para>
</listitem></itemizedlist>
</para>
<para>Additionally, a range of items can be provided as input seeds when constructing the <computeroutput>Region_growing</computeroutput> class. It defines the seeding order of items that is which items are used first to grow regions from. Such items are referred to as <emphasis>seed</emphasis> items. When not provided, the order used is that of the input range. Also note that the seed range may not contain all items of the <computeroutput>input_range</computeroutput>. In such case, items not provided and not reached by the region growing algorithm will have not region assigned.</para>
<para>Using this generic framework, users can grow any type of regions on a set of arbitrary items with their own propagation and seeding conditions (see <ref refid="index_1Shape_detection_RegionGrowingFramework_examples" kindref="member">an example</ref>).</para>
<sect3 id="index_1Shape_detection_RegionGrowingFramework_examples">
<title>Examples</title>
<para>This toy example shows how to define a custom models of<computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> and <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> concept, which are used to parameterize the <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput>.</para>
<para>We choose a simple custom object item. We define three such objects, where for each object, we manually provide the iterators to its neighbors. The operator <computeroutput><ref refid="classNeighborQuery_1ab67a0e853f18f69295c9c2b30fca1f6b" kindref="member">NeighborQuery::operator()()</ref></computeroutput> does nothing but accessing those neighbors. The <computeroutput>Region_type</computeroutput> class defines the necessary types and functions:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Region_type::Primitive</computeroutput> This type represents the parameters of the primitive, e.g., in case of a sphere it could be a struct containing a <computeroutput><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref></computeroutput> for the center and a floating point number for the radius.</para>
</listitem><listitem><para><computeroutput>Region_type::Item</computeroutput> - a <computeroutput>const_iterator</computeroutput> of <computeroutput>std::vector&lt;<ref refid="classCGAL_1_1Object" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Object</ref>&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>Region_type::Region_index_map</computeroutput> - an unordered map from <computeroutput>Region_type::Item</computeroutput> to <computeroutput>std::size_t</computeroutput> encapsuled in a <computeroutput>boost::associative_property_map</computeroutput>.</para>
</listitem><listitem><para><computeroutput>Region_type::Primitive</computeroutput> - a <computeroutput>std::size_t</computeroutput></para>
</listitem><listitem><para><computeroutput>Region_type::is_part_of_region()</computeroutput> - <computeroutput>true</computeroutput> if the first and second objects are neighbors,</para>
</listitem><listitem><para><computeroutput>Region_type::is_valid_region()</computeroutput> - always <computeroutput>true</computeroutput> after the first call to the function <computeroutput>update()</computeroutput>,</para>
</listitem><listitem><para><computeroutput>Region_type::update()</computeroutput> - updates the internal flag from the default <computeroutput>false</computeroutput> to <computeroutput>true</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>The result of using these classes with the region growing main class is that the first two objects form the first region, the third object forms the second region.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_with_custom_classes_8cpp-example" kindref="compound">Shape_detection/region_growing_with_custom_classes.cpp</ref> <programlisting filename="Shape_detection/region_growing_with_custom_classes.cpp"><codeline><highlight class="comment">//<sp/>STL<sp/>includes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unordered_map&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;list&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iterator&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>CGAL<sp/>includes.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Custom<sp/>Neighbor_query<sp/>and<sp/>Region_type<sp/>classes<sp/>for<sp/>region<sp/>growing.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">Custom<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>An<sp/>object<sp/>that<sp/>stores<sp/>indices<sp/>of<sp/>all<sp/>its<sp/>neighbors.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Object</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::vector&lt;Object&gt;::const_iterator&gt;<sp/>neighbors;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Object" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">Object</ref>&amp;<sp/>obj)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>neighbors<sp/>==<sp/>obj.neighbors;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>A<sp/>range<sp/>of<sp/>objects.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Objects<sp/>=<sp/>std::vector&lt;Object&gt;;<sp/></highlight><highlight class="comment">//<sp/>std::list&lt;Object&gt;<sp/>works<sp/>as<sp/>well</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>Neighbor_query<sp/>functor<sp/>that<sp/>accesses<sp/>neighbors<sp/>stored<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>object<sp/>struct<sp/>above.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Neighbor_query<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Objects&amp;<sp/>m_objects;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Item<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Objects::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region<sp/>=<sp/>std::vector&lt;Item&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Neighbor_query(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Objects&amp;<sp/>objects)<sp/>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>m_objects(objects)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Item<sp/>&amp;query,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;Item&gt;&amp;<sp/>neighbors)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>m_objects.begin();<sp/>it<sp/>!=<sp/>m_objects.end();<sp/>it++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>==<sp/>query)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>neighbors<sp/>=<sp/>query-&gt;neighbors;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>Region_type<sp/>class,<sp/>where<sp/>the<sp/>function<sp/>is_part_of_region()<sp/>verifies</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>very<sp/>specific<sp/>condition<sp/>that<sp/>the<sp/>first<sp/>and<sp/>second<sp/>objects<sp/>in<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>range<sp/>are<sp/>in<sp/>fact<sp/>neighbors;<sp/>is_valid_region()<sp/>function<sp/>always</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>returns<sp/>true<sp/>after<sp/>the<sp/>first<sp/>call<sp/>to<sp/>the<sp/>update()<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>These<sp/>are<sp/>the<sp/>only<sp/>functions<sp/>that<sp/>have<sp/>to<sp/>be<sp/>defined.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Region_type<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_is_valid<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Object&gt;&amp;<sp/>m_input;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Region_type(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;Object&gt;<sp/>&amp;input)<sp/>:<sp/>m_input(input)<sp/>{<sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Primitive<sp/>=<sp/>std::size_t;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Item<sp/>=<sp/>std::vector&lt;Object&gt;::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region<sp/>=<sp/>std::vector&lt;Item&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">hash_item<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::size_t<sp/>operator()(Item<sp/>i)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceboost_1ab1bbf571245852cdd36800608738fddb" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">boost::hash_value</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespaceboost_1ab1bbf571245852cdd36800608738fddb" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">boost::hash_value</ref>(i.operator-&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_unordered_map<sp/>=<sp/>std::unordered_map&lt;Item,<sp/>std::size_t,<sp/>hash_item<sp/>&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_index_map<sp/>=<sp/>boost::associative_property_map&lt;Region_unordered_map&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Region_index_map<sp/>region_index_map()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Region_index_map<sp/>index_map(m_region_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_part_of_region(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Item<sp/>query,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Region&amp;<sp/>region)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(region.size()<sp/>==<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>m_input.begin();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(query<sp/>==<sp/>it<sp/>||<sp/>query<sp/>==<sp/>(it<sp/>+<sp/>1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_valid_region(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Region&amp;)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_is_valid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Primitive<sp/>primitive()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Primitive();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>update(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Region&amp;)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>m_is_valid<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_is_valid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Region_unordered_map<sp/>m_region_map;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>Custom</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Object<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Custom::Object;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Objects<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Custom::Objects;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/>Custom::Neighbor_query;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/>Custom::Region_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>a<sp/>range<sp/>of<sp/>objects,<sp/>where<sp/>the<sp/>first<sp/>two<sp/>objects<sp/>form</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>first<sp/>region,<sp/>while<sp/>the<sp/>third<sp/>object<sp/>forms<sp/>the<sp/>second<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>Objects<sp/>is<sp/>a<sp/>random<sp/>access<sp/>container<sp/>here,<sp/>however<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>same<sp/>algorithm/example<sp/>can<sp/>work<sp/>with<sp/>other<sp/>containers,<sp/>e.g.<sp/>std::list.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Objects<sp/>objects(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>objects.begin();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Region<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>objects[0].neighbors.push_back(it+1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>objects[1].neighbors.push_back(it);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>single<sp/>third<sp/>object<sp/>constitutes<sp/>the<sp/>second<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>objects:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>objects.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(objects.size()<sp/>==<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query<sp/>=<sp/>Neighbor_query(objects);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/><sp/><sp/><sp/>region_type<sp/><sp/><sp/><sp/>=<sp/>Region_type(objects);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>objects,<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>Region_growing::Primitive_and_region&gt;<sp/>regions;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(std::back_inserter(regions));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>regions:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>regions.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(regions.size()<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
</sect2>
<sect2 id="index_1Shape_detection_RegionGrowingPoints">
<title>Point Set</title>
<para>If one wants to detect lines (see <ref refid="index_1Shape_detection_RegionGrowingPoints_examples" kindref="member">2D Example</ref>)</para>
<para><anchor id="index_1fig__Region_growing_on_point_set_2"/> <image type="html" name="region_growing_on_point_set_2.png"></image>
 <image type="latex" name="region_growing_on_point_set_2.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Region_growing_on_point_set_2" kindref="member">fig__Region_growing_on_point_set_2</ref> A 2D point set depicted with one color per detected line. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>or planes (see <ref refid="index_1Shape_detection_RegionGrowingPoints_examples" kindref="member">3D Example</ref>)</para>
<para><anchor id="index_1fig__Region_growing_on_point_set_3"/> <image type="html" name="region_growing_on_point_set_3.png"></image>
 <image type="latex" name="region_growing_on_point_set_3.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Region_growing_on_point_set_3" kindref="member">fig__Region_growing_on_point_set_3</ref> A 3D point set depicted with one color per detected plane. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>in a 2D or 3D point set respectively, this CGAL component provides the corresponding models of the concepts <computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> and <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput>. In particular, it provides two different ways to define neighbors of a point:</para>
<para><itemizedlist>
<listitem><para>Fuzzy sphere neighbors search via <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query" kindref="compound">CGAL::Shape_detection::Point_set::Sphere_neighbor_query</ref></computeroutput>. This class creates a circle (in 2D case) or a sphere (in 3D case) centered at the query point with a user-specified sphere radius. All points, which belong to the sphere, will be treated as neighbors of the query point;</para>
</listitem><listitem><para>Nearest neighbors search via <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1K__neighbor__query" kindref="compound">CGAL::Shape_detection::Point_set::K_neighbor_query</ref></computeroutput>. This class finds K (specified by the user) nearest neighbors of the query point either 2D or 3D.</para>
</listitem></itemizedlist>
</para>
<para>The component also provides</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_line_fit_region</ref></computeroutput> - least squares line fit type of region for 2D points</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__circle__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_circle_fit_region</ref></computeroutput> - least squares circle fit type of region for 2D points</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region</ref></computeroutput> - least squares plane fit type of region for 3D points</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__sphere__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_sphere_fit_region</ref></computeroutput> - least squares sphere fit type of region for 3D points</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__cylinder__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_cylinder_fit_region</ref></computeroutput> - least squares cylinder fit type of region for 3D points</para>
</listitem></itemizedlist>
</para>
<para>The program associates all points from a region to the best-fit object (2D line, 2D circle, 3D plane, 3D sphere, etc.) and controls the quality of this fit.</para>
<para>The quality of region growing in a point set (2D or 3D) can be improved by slightly increasing the running time. To achieve this, one can sort the input points with respect to some quality criteria. These quality criteria can be included through the seed range (see <ref refid="index_1Shape_detection_RegionGrowingFramework" kindref="member">Framework</ref> for more details). We provide a quality sorting both for 2D and 3D points:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__sorting" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_line_fit_sorting</ref></computeroutput> - the 2D input points are sorted with respect to the quality of the least squares line fit applied to the neighbors of each point;</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__circle__fit__sorting" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_circle_fit_sorting</ref></computeroutput> - the 2D input points are sorted with respect to the quality of the least squares circle fit applied to the neighbors of each point;</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__sorting" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_sorting</ref></computeroutput> - the 3D input points are sorted with respect to the quality of the least squares plane fit applied to the neighbors of each point.</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__sphere__fit__sorting" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_sphere_fit_sorting</ref></computeroutput> - the 3D input points are sorted with respect to the quality of the least squares sphere fit applied to the neighbors of each point.</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__cylinder__fit__sorting" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_cylinder_fit_sorting</ref></computeroutput> - the 3D input points are sorted with respect to the quality of the least squares cylinder fit applied to the neighbors of each point.</para>
</listitem></itemizedlist>
</para>
<sect3 id="index_1Shape_detection_RegionGrowingPoints_parameters">
<title>Parameters</title>
<para>The classes in Section <ref refid="index_1Shape_detection_RegionGrowingPoints" kindref="member">Region Growing On Point Set</ref> depend on a few parameters that should be defined by the user. They also have default values, but these values do not necessarily guarantee to produce pleasant results. All parameter values can be specified using <ref refid="group__bgl__namedparameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">Named Parameters</ref>.</para>
<para>The <computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> related classes depend on the parameters:</para>
<para><itemizedlist>
<listitem><para><computeroutput>sphere_radius</computeroutput> in the class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query" kindref="compound">CGAL::Shape_detection::Point_set::Sphere_neighbor_query</ref></computeroutput>, defines the radius of the fuzzy search sphere centered at the query point;</para>
</listitem><listitem><para><computeroutput>k_neighbors</computeroutput> in the class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1K__neighbor__query" kindref="compound">CGAL::Shape_detection::Point_set::K_neighbor_query</ref></computeroutput>, defines the number K of nearest neighbors of the query point.</para>
</listitem></itemizedlist>
</para>
<para>The right choice of the parameters above plays an important role in producing a good result. For example, if we consider the fuzzy sphere neighborhood, when <computeroutput>sphere_radius</computeroutput> is too large, we have fewer regions, and the details are not clearly separated. Meanwhile, if <computeroutput>sphere_radius</computeroutput> is too small, we produce more regions, and the point set may be over-segmented. Consider a 2D map of an intersection of streets in a city as in Figure <ref refid="index_1fig__Region_growing_parameter_sphere_radius_variation" kindref="member">fig__Region_growing_parameter_sphere_radius_variation</ref>. Each region is painted with a unique color. As <computeroutput>sphere_radius</computeroutput> increases, the details become less clear. When <computeroutput>sphere_radius</computeroutput> = 0.3 (c), the best visual result is produced.</para>
<para><anchor id="index_1fig__Region_growing_parameter_sphere_radius_variation"/> <image type="html" name="sphere_radius_parameter_2D.png"></image>
 <image type="latex" name="sphere_radius_parameter_2D.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Region_growing_parameter_sphere_radius_variation" kindref="member">fig__Region_growing_parameter_sphere_radius_variation</ref> (a) Input 2D point set; (b) 17 regions are found when <computeroutput>sphere_radius</computeroutput> = 0.1; (c) 8 regions are found when <computeroutput>sphere_radius</computeroutput> = 0.3; (d) 4 regions are found when <computeroutput>sphere_radius</computeroutput> = 1.2. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> related classes depend on the following parameters:</para>
<para><itemizedlist>
<listitem><para><computeroutput>maximum_distance</computeroutput> - the maximum distance from a point to a line/plane;</para>
</listitem><listitem><para><computeroutput>maximum_angle</computeroutput> - the maximum angle in degrees between the normal associated with a point and the normal of a line/plane;</para>
</listitem><listitem><para><computeroutput>minimum_region_size</computeroutput> - the minimum number of points a region must have.</para>
</listitem></itemizedlist>
</para>
<para>The first two parameters are used by the functions <computeroutput><ref refid="classRegionType_1a0173bafb2511e535ff6a94c48a043866" kindref="member">RegionType::is_part_of_region()</ref></computeroutput> and <computeroutput><ref refid="classRegionType_1a97466cd48f6e4cf714efbc803401f86a" kindref="member">RegionType::update()</ref></computeroutput>, while the third parameter is used by the function <computeroutput><ref refid="classRegionType_1ae71ecdb4caee8830b8baecd5c05d9484" kindref="member">RegionType::is_valid_region()</ref></computeroutput> from the <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> concept.</para>
<para>The right choice of <computeroutput>maximum_distance</computeroutput> and <computeroutput>maximum_angle</computeroutput> parameters is also very important. For example, Figure <ref refid="index_1fig__Region_growing_parameter_max_angle_variation" kindref="member">fig__Region_growing_parameter_max_angle_variation</ref> shows that the roof top of the house can be distinguished as two planes (painted in blue and dark red) when <computeroutput>maximum_angle</computeroutput> is strict enough (c), or it can be recognized as only one plane (painted in pale yellow) in the other case (b).</para>
<para><anchor id="index_1fig__Region_growing_parameter_max_angle_variation"/> <image type="html" name="max_angle_parameter_3D.png"></image>
 <image type="latex" name="max_angle_parameter_3D.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Region_growing_parameter_max_angle_variation" kindref="member">fig__Region_growing_parameter_max_angle_variation</ref> (a) Input 3D point cloud; (b) Result when <computeroutput>maximum_angle</computeroutput> = 60 degrees; (c) Result when <computeroutput>maximum_angle</computeroutput> = 25 degrees. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect3>
<sect3 id="index_1Shape_detection_RegionGrowingPoints_examples">
<title>Examples</title>
<sect4 id="index_1Shape_detection_RegionGrowingPoints_example_2D_lines">
<title>Detecting 2D Lines</title>
<para>Typical usage of the Region Growing component consists of five steps:</para>
<para><orderedlist>
<listitem><para>Define an input range with points;</para>
</listitem><listitem><para>Create instances of the classes <computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> and <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> with the proper parameters;</para>
</listitem><listitem><para>Create an instance of the class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing</ref></computeroutput>;</para>
</listitem><listitem><para>Detect;</para>
</listitem><listitem><para>Postprocess.</para>
</listitem></orderedlist>
</para>
<para>Given a 2D point set, we detect 2D lines using the fuzzy sphere neighborhood. We then color all points from the found regions and save them in a file (see Figure <ref refid="index_1fig__Region_growing_on_point_set_2" kindref="member">fig__Region_growing_on_point_set_2</ref>). A point set with normals is stored in <computeroutput>std::vector</computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_lines_on_point_set_2_8cpp-example" kindref="compound">Shape_detection/region_growing_lines_on_point_set_2.cpp</ref> <programlisting filename="Shape_detection/region_growing_lines_on_point_set_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Point__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Point_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/range/irange.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_2</ref><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_with_normal<sp/>=<sp/>std::pair&lt;Point_2,<sp/>Vector_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_set_2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::vector&lt;Point_with_normal&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>use<sp/>Compose_property_map<sp/>as<sp/>the<sp/>property<sp/>maps<sp/>are<sp/>expected<sp/>to<sp/>operate<sp/>on<sp/>the<sp/>item<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>std::size_t<sp/>passed<sp/>as<sp/>parameter<sp/>to<sp/>Sphere_neighbor_query<sp/>and<sp/>Least_squares_line_fit_region</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Compose__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Compose_property_map&lt;CGAL::Random_access_property_map&lt;Point_set_2&gt;</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1First__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Normal_map<sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Compose__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Compose_property_map&lt;CGAL::Random_access_property_map&lt;Point_set_2&gt;</ref>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Second__of__pair__property__map" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Property_map.tag">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</ref><sp/>&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query" kindref="compound">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, std::size_t, Point_map&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__region" kindref="compound">CGAL::Shape_detection::Point_set::Least_squares_line_fit_region&lt;Kernel, std::size_t, Point_map, Normal_map&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>xyz<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/buildings_outline.xyz&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>a,<sp/>b,<sp/>c,<sp/>d,<sp/>e,<sp/>f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set_2<sp/>point_set_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(in<sp/>&gt;&gt;<sp/>a<sp/>&gt;&gt;<sp/>b<sp/>&gt;&gt;<sp/>c<sp/>&gt;&gt;<sp/>d<sp/>&gt;&gt;<sp/>e<sp/>&gt;&gt;<sp/>f)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2.push_back(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::make_pair(<ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(a,<sp/>b),<sp/><ref refid="classKernel_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_2</ref>(d,<sp/>e)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>point_set_2.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>point_set_2.size()<sp/>==<sp/>3634);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>buildings_outline.xyz.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sphere_radius<sp/><sp/><sp/>=<sp/>FT(5);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(45)<sp/>/<sp/>FT(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(45);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_map<sp/>point_map(CGAL::make_random_access_property_map(point_set_2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Normal_map<sp/>normal_map(CGAL::make_random_access_property_map(point_set_2));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::irange&lt;std::size_t&gt;(0,point_set_2.size()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>CGAL::parameters::sphere_radius(sphere_radius)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.point_map(point_map));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>normal_map(normal_map).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_map(point_map));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::irange&lt;std::size_t&gt;(0,point_set_2.size()),<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>Region_growing::Primitive_and_region&gt;<sp/>regions;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(std::back_inserter(regions));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>lines:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>regions.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>regions.size()<sp/>==<sp/>72);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>fullpath<sp/>=<sp/>(argc<sp/>&gt;<sp/>2<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;lines_point_set_2.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>utils::save_point_regions_2&lt;Kernel,<sp/>std::vector&lt;typename<sp/>Region_growing::Primitive_and_region&gt;,<sp/>Point_map&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>regions,<sp/>fullpath,<sp/>point_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1Shape_detection_RegionGrowingPoints_example_2D_circles">
<title>Detecting 2D Circles</title>
<para>The following example shows a similar example, this time detecting circles instead of lines. In that case, we also preprocess points so that they are sorted according to their likelihood of belonging to a circle:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_circles_on_point_set_2_8cpp-example" kindref="compound">Shape_detection/region_growing_circles_on_point_set_2.cpp</ref> <programlisting filename="Shape_detection/region_growing_circles_on_point_set_2.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Point__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Point_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/function_output_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_2</ref><sp/>=<sp/><ref refid="classKernel_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_2</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref><sp/>=<sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_set_2<sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_2, Vector_2&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">Point_set_3</ref><sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/>=<sp/>Point_set_2::Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Normal_map<sp/>=<sp/>Point_set_2::Vector_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::K_neighbor_query_for_point_set&lt;Point_set_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_circle_fit_region_for_point_set&lt;Point_set_2&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Sorting<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_circle_fit_sorting_for_point_set&lt;Point_set_2,<sp/>Neighbor_query&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>ply<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/circles.ply&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set_3<sp/>point_set_3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>point_set_3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>point_set_3.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>point_set_3.size()<sp/>==<sp/>1101);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(point_set_3.has_normal_map());<sp/></highlight><highlight class="comment">//<sp/>input<sp/>should<sp/>have<sp/>normals</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>2D<sp/>point<sp/>set.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set_2<sp/>point_set_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>point_set_2.add_normal_map();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>idx<sp/>:<sp/>point_set_3)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&amp;<sp/>point<sp/>=<sp/>point_set_3.point(idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref>&amp;<sp/><ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref><sp/>=<sp/>point_set_3.normal(idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2.insert(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Point__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_2</ref>(point.x(),<sp/>point.y()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classKernel_1_1Vector__2" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_2</ref>(<ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref>.x(),<sp/><ref refid="group__normal__grp_1gafe43c91d0ec7130cb673402cf8227dff" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">normal</ref>.y()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>circles.ply.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>k<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(1)<sp/>/<sp/>FT(100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>20;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_k_neighbor_query(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2,<sp/>CGAL::parameters::k_neighbors(k));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_circle_fit_region(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Sort<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sorting<sp/>sorting<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_circle_fit_sorting(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2,<sp/>neighbor_query,<sp/>CGAL::parameters::k_neighbors(k));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sorting.sort();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set_2,<sp/>sorting.ordered(),<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>maps<sp/>to<sp/>get<sp/>a<sp/>colored<sp/>output.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set_2::Property_map&lt;unsigned<sp/>char&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/><sp/><sp/>=<sp/>point_set_2.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal"><sp/><sp/>,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>point_set_2.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/><sp/>=<sp/>point_set_2.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal"><sp/>,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>random;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>num_circles<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_function_output_iterator(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;<sp/>Region_type::Primitive,<sp/>typename<sp/>Region_growing::Region<sp/>&gt;&amp;<sp/>region)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Assign<sp/>a<sp/>random<sp/>color<sp/>to<sp/>each<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>r<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>g<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>b<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>item<sp/>:<sp/>region.second)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>red[item]<sp/>=<sp/>r;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>green[item]<sp/>=<sp/>g;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blue[item]<sp/>=<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++num_circles;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>circles:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_circles<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>num_circles<sp/>==<sp/>10);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;circles_point_set_2.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>point_set_2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1Shape_detection_RegionGrowingPoints_example_3D_planes">
<title>Detecting 3D Planes</title>
<para>If we are given a 3D point set, then the example below shows how to detect 3D planes using the K nearest neighbors search. We color all points from the found regions and save them in a file (see Figure <ref refid="index_1fig__Region_growing_on_point_set_3" kindref="member">fig__Region_growing_on_point_set_3</ref>). The example also shows how to retrieve all points, which are not assigned to any region, and how to use a custom output iterator. A point set with normals is stored in <computeroutput><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3</ref></computeroutput>.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_planes_on_point_set_3_8cpp-example" kindref="compound">Shape_detection/region_growing_planes_on_point_set_3.cpp</ref> <programlisting filename="Shape_detection/region_growing_planes_on_point_set_3.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Point__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Point_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/function_output_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_set<sp/><sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Output_range<sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Normal_map<sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Vector_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::K_neighbor_query_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Sorting<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_plane_fit_sorting_for_point_set&lt;Point_set,<sp/>Neighbor_query&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_inserter<sp/>=<sp/>utils::Insert_point_colored_by_region_index&lt;Point_set::Index,<sp/>Output_range,<sp/>Point_map,<sp/>Kernel::Plane_3&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>xyz<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/building.xyz&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>with_normal_map<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>point_set(with_normal_map);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>point_set.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>point_set.size()<sp/>==<sp/>8075);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>building.xyz.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>k<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>12;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(20);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>50;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_k_neighbor_query(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,<sp/>CGAL::parameters::k_neighbors(k));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sorting<sp/>sorting<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_plane_fit_sorting(point_set,<sp/>neighbor_query);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sorting.sort();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_plane_fit_region(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,<sp/>sorting.ordered(),<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Output_range<sp/>output_range;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>number_of_regions<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_inserter<sp/>inserter(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set.point_map(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output_range,<sp/>number_of_regions);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_function_output_iterator(inserter));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>planes:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>number_of_regions<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>number_of_regions<sp/>==<sp/>7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>fullpath<sp/>=<sp/>(argc<sp/>&gt;<sp/>2<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;planes_point_set_3.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(fullpath);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>output_range;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out.close();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>all<sp/>unassigned<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Region_type::Item&gt;<sp/>unassigned_items;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.unassigned_items(point_set,<sp/>std::back_inserter(unassigned_items));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>unassigned<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>unassigned_items.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>unassigned_items.size()<sp/>==<sp/>538);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Store<sp/>all<sp/>unassigned<sp/>points.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;Point_3&gt;<sp/>unassigned_points;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unassigned_points.reserve(unassigned_items.size());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Region_type::Item<sp/>&amp;item<sp/>:<sp/>unassigned_items)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref>&amp;<sp/>point<sp/>=<sp/>get(point_set.point_map(),<sp/>item);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unassigned_points.push_back(point);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1Shape_detection_RegionGrowingPoints_example_3D_spheres">
<title>Detecting 3D Spheres</title>
<para>The following example shows a similar example, this time detecting spheres instead of planes.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_spheres_on_point_set_3_8cpp-example" kindref="compound">Shape_detection/region_growing_spheres_on_point_set_3.cpp</ref> <programlisting filename="Shape_detection/region_growing_spheres_on_point_set_3.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Point__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Point_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/function_output_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref><sp/>=<sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_set<sp/><sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Normal_map<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Vector_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::K_neighbor_query_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_sphere_fit_region_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>ply<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/spheres.ply&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>point_set.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>point_set.size()<sp/>==<sp/>5969);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(point_set.has_normal_map());<sp/></highlight><highlight class="comment">//<sp/>input<sp/>should<sp/>have<sp/>normals</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>spheres.ply.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>k<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>12;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(1)<sp/>/<sp/>FT(100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>50;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_k_neighbor_query(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,<sp/>CGAL::parameters::k_neighbors(k));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_sphere_fit_region(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>maps<sp/>to<sp/>get<sp/>a<sp/>colored<sp/>output.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set::Property_map&lt;unsigned<sp/>char&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/><sp/><sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal"><sp/><sp/>,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/><sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal"><sp/>,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>num_spheres<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_function_output_iterator(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;<sp/>Region_type::Primitive,<sp/>typename<sp/>Region_growing::Region&gt;&amp;<sp/>region)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Assign<sp/>a<sp/>random<sp/>color<sp/>to<sp/>each<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>r<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(CGAL::get_default_random().get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>g<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(CGAL::get_default_random().get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>b<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(CGAL::get_default_random().get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>item<sp/>:<sp/>region.second)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>red[item]<sp/><sp/><sp/>=<sp/>r;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>green[item]<sp/>=<sp/>g;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blue[item]<sp/><sp/>=<sp/>b;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++num_spheres;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>spheres:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_spheres<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>num_spheres<sp/>==<sp/>10);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;spheres_point_set_3.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
<sect4 id="index_1Shape_detection_RegionGrowingPoints_example_3D_cylinders">
<title>Detecting 3D Cylinders</title>
<para>The following example shows another similar example, this time detecting (infinite) cylinders.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_cylinders_on_point_set_3_8cpp-example" kindref="compound">Shape_detection/region_growing_cylinders_on_point_set_3.cpp</ref> <programlisting filename="Shape_detection/region_growing_cylinders_on_point_set_3.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Point_set_3/IO.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Point__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Point_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;boost/iterator/function_output_iterator.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/><sp/>=<sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Vector_3</ref><sp/>=<sp/><ref refid="classKernel_1_1Vector__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Vector_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_set<sp/><sp/>=<sp/><ref refid="classCGAL_1_1Point__set__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Point_set_3.tag">CGAL::Point_set_3&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Point_map<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Point_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Normal_map<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Point_set::Vector_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::K_neighbor_query_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/>CGAL::Shape_detection::Point_set::Least_squares_cylinder_fit_region_for_point_set&lt;Point_set&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>ply<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;points_3/cylinders.ply&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!in)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in<sp/>&gt;&gt;<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>in.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>points:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>point_set.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>point_set.size()<sp/>==<sp/>1813);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(point_set.has_normal_map());<sp/></highlight><highlight class="comment">//<sp/>input<sp/>should<sp/>have<sp/>normals</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>cuble.pwn.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>k<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>20;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(1)<sp/>/<sp/>FT(10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(25);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>20;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_k_neighbor_query(point_set,<sp/>CGAL::parameters::k_neighbors(k));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type<sp/>=<sp/>CGAL::Shape_detection::Point_set::make_least_squares_cylinder_fit_region(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>point_set,<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>maps<sp/>to<sp/>get<sp/>a<sp/>colored<sp/>output.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Point_set::Property_map&lt;unsigned<sp/>char&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>red<sp/><sp/><sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;red&quot;</highlight><highlight class="normal"><sp/><sp/>,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>green<sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;green&quot;</highlight><highlight class="normal">,<sp/>0).first,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>blue<sp/><sp/>=<sp/>point_set.add_property_map&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">&gt;(</highlight><highlight class="stringliteral">&quot;blue&quot;</highlight><highlight class="normal"><sp/>,<sp/>0).first;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CGAL::Random<sp/>random;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>num_cylinders<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::make_function_output_iterator(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;<sp/>Region_type::Primitive,<sp/>std::vector&lt;typename<sp/>Point_set::Index&gt;<sp/>&gt;&amp;<sp/>region)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Assign<sp/>a<sp/>random<sp/>color<sp/>to<sp/>each<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>r<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>g<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>b<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(random.get_int(64,<sp/>192));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>:<sp/>region.second)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>put(red,<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>put(green,<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>g);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>put(blue,<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>b);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++num_cylinders;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>cylinders:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_cylinders<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>num_cylinders<sp/>==<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ofstream<sp/>out(</highlight><highlight class="stringliteral">&quot;cylinders_point_set_3.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(out);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>out<sp/>&lt;&lt;<sp/>point_set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect4>
</sect3>
<sect3 id="index_1Shape_detection_RegionGrowingPoints_performance">
<title>Performance</title>
<para>The main parameter that affects the region growing algorithm on a point set is the neighborhood size at each retrieval (see <computeroutput>sphere_radius</computeroutput> or <computeroutput>k_neighbors</computeroutput>). Larger neighbor lists are often followed by a smaller number of regions, larger coverage (the ratio between the number of points assigned to regions and the total number of input points), and longer running time. For example, for a test of about 70k 2D points with the fuzzy sphere neighborhood, the following table is produced:</para>
<para><table rows="5" cols="4"><row>
<entry thead="yes" align='center'><para><computeroutput>sphere_radius</computeroutput> </para>
</entry><entry thead="yes" align='center'><para>Time (in seconds) </para>
</entry><entry thead="yes" align='center'><para>Number of regions </para>
</entry><entry thead="yes" align='center'><para>Number of assigned points  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1.0 </para>
</entry><entry thead="no" align='center'><para>0.138831 </para>
</entry><entry thead="no" align='center'><para>794 </para>
</entry><entry thead="no" align='center'><para>4483  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>3.0 </para>
</entry><entry thead="no" align='center'><para>0.069098 </para>
</entry><entry thead="no" align='center'><para>3063 </para>
</entry><entry thead="no" align='center'><para>63038  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>6.0 </para>
</entry><entry thead="no" align='center'><para>0.077703 </para>
</entry><entry thead="no" align='center'><para>2508 </para>
</entry><entry thead="no" align='center'><para>64906  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>9.0 </para>
</entry><entry thead="no" align='center'><para>0.093415 </para>
</entry><entry thead="no" align='center'><para>2302 </para>
</entry><entry thead="no" align='center'><para>65334  </para>
</entry></row>
</table>
</para>
<para>If the neighborhood size is set too low, some points might be isolated, the region size would not reach a critical mass and so will be discarded. This does not only cause the latency in the program, but also reduces the coverage value, as can be seen when the <computeroutput>sphere_radius = 1.0</computeroutput>. A typical runtime measure for a 3D point set with the K nearest neighborhood and well-defined parameters can be found in the following table:</para>
<para><table rows="5" cols="2"><row>
<entry thead="yes" align='center'><para><computeroutput>Number of points</computeroutput>  </para>
</entry><entry thead="yes" align='center'><para>Time (in seconds)  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>300k </para>
</entry><entry thead="no" align='center'><para>0.761617  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>600k </para>
</entry><entry thead="no" align='center'><para>1.68735  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>900k </para>
</entry><entry thead="no" align='center'><para>2.80346  </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1200k </para>
</entry><entry thead="no" align='center'><para>4.06246  </para>
</entry></row>
</table>
</para>
</sect3>
</sect2>
<sect2 id="index_1Shape_detection_RegionGrowingMesh">
<title>Polygon Mesh</title>
<para>If one wants to detect planes on a polygon mesh, this CGAL component provides the corresponding models of the concepts <computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> and <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput>. In particular, it provides</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query" kindref="compound">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query</ref></computeroutput> class that retrieves all edge-adjacent faces of a face, and</para>
</listitem><listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region</ref></computeroutput> class that fits a 3D plane to the vertices of all mesh faces, which have been added to the region so far, and controls the quality of this fit.</para>
</listitem></itemizedlist>
</para>
<para>This component accepts any model of the concept <computeroutput><ref refid="classFaceListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">FaceListGraph</ref></computeroutput> as a polygon mesh. Figure <ref refid="index_1fig__Region_growing_on_surface_mesh" kindref="member">fig__Region_growing_on_surface_mesh</ref> gives an <ref refid="index_1Shape_detection_RegionGrowingMesh_examples" kindref="member">example</ref> of the region growing algorithm for detecting 3D planes on <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh</ref></computeroutput>.</para>
<para><anchor id="index_1fig__Region_growing_on_surface_mesh"/> <image type="html" name="region_growing_on_polygon_mesh.png"></image>
 <image type="latex" name="region_growing_on_polygon_mesh.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Region_growing_on_surface_mesh" kindref="member">fig__Region_growing_on_surface_mesh</ref> A surface mesh depicted with one color per detected plane. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
<para>The quality of region growing on a polygon mesh can be improved by slightly increasing the running time. To achieve this, one can sort the input faces with respect to some quality criteria. These quality criteria can be included in region growing through the seed range (see <ref refid="index_1Shape_detection_RegionGrowingFramework" kindref="member">Framework</ref> for more details). We provide such a quality sorting:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting</ref></computeroutput> - the input faces are sorted with respect to the quality of the least squares plane fit applied to the neighbors of each face.</para>
</listitem></itemizedlist>
</para>
<sect3 id="index_1Shape_detection_RegionGrowingMesh_parameters">
<title>Parameters</title>
<para>The <computeroutput><ref refid="classNeighborQuery" kindref="compound">NeighborQuery</ref></computeroutput> related class does not require any parameters, because edge-adjacent faces are found using the internal face graph connectivity, while the <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> related class depends on three parameters:</para>
<para><itemizedlist>
<listitem><para><computeroutput>maximum_distance</computeroutput> - the maximum distance from the furthest face vertex to a plane;</para>
</listitem><listitem><para><computeroutput>maximum_angle</computeroutput> - the maximum angle in degrees between the face normal and the normal of a plane;</para>
</listitem><listitem><para><computeroutput>minimum_region_size</computeroutput> - the minimum number of mesh faces a region must have.</para>
</listitem></itemizedlist>
</para>
<para>The first two parameters are used by the functions <computeroutput><ref refid="classRegionType_1a0173bafb2511e535ff6a94c48a043866" kindref="member">RegionType::is_part_of_region()</ref></computeroutput> and <computeroutput><ref refid="classRegionType_1a97466cd48f6e4cf714efbc803401f86a" kindref="member">RegionType::update()</ref></computeroutput>, while the third parameter is used by the function <computeroutput><ref refid="classRegionType_1ae71ecdb4caee8830b8baecd5c05d9484" kindref="member">RegionType::is_valid_region()</ref></computeroutput>. The right choice of these parameters is as important as the one explained in Section <ref refid="index_1Shape_detection_RegionGrowingPoints_parameters" kindref="member">Parameters For Region Growing On Point Set</ref>.</para>
</sect3>
<sect3 id="index_1Shape_detection_RegionGrowingMesh_examples">
<title>Examples</title>
<para>In the example below, we show how to use region growing to detect planes on a polygon mesh that can be either stored as <computeroutput><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh</ref></computeroutput> or <computeroutput><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3</ref></computeroutput>.</para>
<para>We can improve the quality of region growing by providing a different seeding order (analogously to <ref refid="index_1Shape_detection_RegionGrowingPoints" kindref="member">Point Sets</ref>) that is why in this example we also sort the input faces using the <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting</ref></computeroutput> and only then detect regions.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_planes_on_polygon_mesh_8cpp-example" kindref="compound">Shape_detection/region_growing_planes_on_polygon_mesh.cpp</ref> <programlisting filename="Shape_detection/region_growing_planes_on_polygon_mesh.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>USE_POLYHEDRON</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Polyhedron_3.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Polygon__mesh_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Polygon_mesh.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/polygon_mesh_io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>USE_POLYHEDRON</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Polygon_mesh<sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Polyhedron__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Polyhedron.tag">CGAL::Polyhedron_3&lt;Kernel&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Polygon_mesh<sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Neighbor_query<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query" kindref="compound">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query&lt;Polygon_mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_type<sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region&lt;Kernel, Polygon_mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Sorting<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting&lt;Kernel, Polygon_mesh, Neighbor_query&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Region_growing<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Neighbor_query, Region_type&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>filename<sp/>=<sp/>is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/building.off&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::ifstream<sp/>in(filename);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="group__PkgStreamSupportRef_1ga7d51c854b865a7eb367e21fc43bd37b8" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Stream_support.tag">CGAL::IO::set_ascii_mode</ref>(in);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polygon_mesh<sp/>polygon_mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgBGLIOFct_1ga49f5b5e6fbfcbfaaac7604c88e10915c" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">CGAL::IO::read_polygon_mesh</ref>(filename,<sp/>polygon_mesh))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>face_range<sp/>=<sp/>faces(polygon_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>faces:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>face_range.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>face_range.size()<sp/>==<sp/>32245);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>parameter<sp/>values<sp/>for<sp/>the<sp/>data<sp/>file<sp/>building.off.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_distance<sp/><sp/><sp/><sp/>=<sp/>FT(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_angle<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>FT(45);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>min_region_size<sp/>=<sp/>5;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>instances<sp/>of<sp/>the<sp/>classes<sp/>Neighbor_query<sp/>and<sp/>Region_type.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Neighbor_query<sp/>neighbor_query(polygon_mesh);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_type<sp/>region_type(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>polygon_mesh,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespaceCGAL_1_1parameters" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/STL_Extension.tag">CGAL::parameters</ref>::</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_distance(max_distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>maximum_angle(max_angle).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>minimum_region_size(min_region_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Sort<sp/>face<sp/>indices.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Sorting<sp/>sorting(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>polygon_mesh,<sp/>neighbor_query);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sorting.sort();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>instance<sp/>of<sp/>the<sp/>region<sp/>growing<sp/>class.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Region_growing<sp/>region_growing(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>face_range,<sp/>sorting.ordered(),<sp/>neighbor_query,<sp/>region_type);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>Region_growing::Primitive_and_region&gt;<sp/>regions;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.detect(std::back_inserter(regions));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>planes:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>regions.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>regions.size()<sp/>==<sp/>365);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Region_growing::Region_map&amp;<sp/>map<sp/>=<sp/>region_growing.region_map();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>regions.size();<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>item<sp/>:<sp/>regions[i].second)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>!=<sp/>get(map,<sp/>item))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Region<sp/>map<sp/>incorrect&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>Region_growing::Item&gt;<sp/>unassigned;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>region_growing.unassigned_items(face_range,<sp/>std::back_inserter(unassigned));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>item<sp/>:<sp/>unassigned)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(std::size_t(-1)<sp/>!=<sp/>get(map,<sp/>item))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Region<sp/>map<sp/>for<sp/>unassigned<sp/>incorrect&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Save<sp/>regions<sp/>to<sp/>a<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>fullpath<sp/>=<sp/>(argc<sp/>&gt;<sp/>2<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;planes_polygon_mesh.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>utils::save_polygon_mesh_regions(polygon_mesh,<sp/>regions,<sp/>fullpath);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1Shape_detection_RegionGrowingMesh_performance">
<title>Performance</title>
<para>Since accessing neighbors of a face in a polygon mesh is fast, performance of the region growing on a polygon mesh mostly depends on the <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput> model&apos;s implementation, which is usually fast, too.</para>
</sect3>
</sect2>
<sect2 id="index_1Shape_detection_RegionGrowingSegments">
<title>Segment Set</title>
<para>If one wants to detect lines in a segment set, this CGAL component provides the corresponding models of the concept <computeroutput><ref refid="classRegionType" kindref="compound">RegionType</ref></computeroutput>. In particular, it provides</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Segment__set_1_1Least__squares__line__fit__region" kindref="compound">CGAL::Shape_detection::Segment_set::Least_squares_line_fit_region</ref></computeroutput> class that fits a 2D or 3D line to the chunks of 2D or 3D segments, respectively, and controls the quality of this fit.</para>
</listitem></itemizedlist>
</para>
<para>The quality of region growing in a segment set (2D or 3D) can be improved by slightly increasing the running time. To achieve this, one can sort the input segments with respect to some quality criteria. These quality criteria can be included through the seed range (see <ref refid="index_1Shape_detection_RegionGrowingFramework" kindref="member">Framework</ref> for more details). We provide such a quality sorting:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Segment__set_1_1Least__squares__line__fit__sorting" kindref="compound">CGAL::Shape_detection::Segment_set::Least_squares_line_fit_sorting</ref></computeroutput> - the input segments are sorted with respect to the quality of the least squares line fit applied to the neighbors of each segment.</para>
</listitem></itemizedlist>
</para>
<para>If the user&apos;s input is a polygon mesh defined as a <computeroutput><ref refid="classFaceListGraph" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">FaceListGraph</ref></computeroutput>, it is also possible to filter out all graph edges, which split this polygon mesh into a set of regions. To achieve that, one first needs to apply the region growing on a polygon mesh and extract a set of such regions and then provide these regions to the class <computeroutput><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Polyline__graph" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Polyline_graph</ref></computeroutput> that returns a range of the corresponding edges, which can later be split into a set of linear regions, as shown in the example below.</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Shape_detection_2region_growing_lines_on_segment_set_8cpp-example" kindref="compound">Shape_detection/region_growing_lines_on_segment_set.cpp</ref> <programlisting filename="Shape_detection/region_growing_lines_on_segment_set.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/PLY.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Surface_mesh.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Segment__set_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Segment_set.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="Polygon__mesh_8h" kindref="compound">CGAL/Shape_detection/Region_growing/Polygon_mesh.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/IO/polygon_mesh_io.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;include/utils.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Typedefs.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Exact__predicates__inexact__constructions__kernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Exact_predicates_inexact_constructions_kernel</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Point_3</ref><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classKernel_1_1Point__3" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel::Point_3</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref><sp/>=<sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">CGAL::Surface_mesh&lt;Point_3&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Face_range<sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh_1a7b883dec85f78bd7db1dee08ffb343e1" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh::Face_range</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Edge_range<sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Surface__mesh_1aea5cd1027cca955472f6c7cb6fc6ffcb" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh::Edge_range</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">One_ring_query<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query" kindref="compound">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query&lt;Surface_mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Plane_region<sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region&lt;Kernel, Surface_mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">RG_planes<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;One_ring_query, Plane_region&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Polyline_graph<sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Polyline__graph" kindref="compound">CGAL::Shape_detection::Polygon_mesh::Polyline_graph&lt;Surface_mesh&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Segment_range<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Polyline_graph::Segment_range;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Segment_map<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Polyline_graph::Segment_map;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Line_region<sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Segment__set_1_1Least__squares__line__fit__region" kindref="compound">CGAL::Shape_detection::Segment_set::Least_squares_line_fit_region&lt;Kernel, Surface_mesh::Edge_index, Segment_map&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Line_sorting<sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Segment__set_1_1Least__squares__line__fit__sorting" kindref="compound">CGAL::Shape_detection::Segment_set::Least_squares_line_fit_sorting&lt;Kernel, Surface_mesh::Edge_index, Polyline_graph, Segment_map&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">RG_lines<sp/><sp/><sp/><sp/><sp/>=<sp/><ref refid="classCGAL_1_1Shape__detection_1_1Region__growing" kindref="compound">CGAL::Shape_detection::Region_growing&lt;Polyline_graph, Line_region&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Load<sp/>data<sp/>either<sp/>from<sp/>a<sp/>local<sp/>folder<sp/>or<sp/>a<sp/>user-provided<sp/>file.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>is_default_input<sp/>=<sp/>argc<sp/>&gt;<sp/>1<sp/>?<sp/>false<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>filename<sp/>=<sp/>is_default_input<sp/>?<sp/><ref refid="namespaceCGAL_1acdae9a147ad2a3998cc21f88bc292dac" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL::data_file_path</ref>(</highlight><highlight class="stringliteral">&quot;meshes/am.off&quot;</highlight><highlight class="normal">)<sp/>:<sp/>argv[1];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Surface__mesh" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Surface_mesh.tag">Surface_mesh</ref><sp/>surface_mesh;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="group__PkgBGLIOFct_1ga49f5b5e6fbfcbfaaac7604c88e10915c" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/BGL.tag">CGAL::IO::read_polygon_mesh</ref>(filename,<sp/>surface_mesh))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ERROR:<sp/>cannot<sp/>read<sp/>the<sp/>input<sp/>file!&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Face_range<sp/>face_range<sp/>=<sp/>faces(surface_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Edge_range<sp/>edge_range<sp/>=<sp/>edges(surface_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>faces:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>face_range.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>input<sp/>edges:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>edge_range.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>face_range.size()<sp/>==<sp/>7320);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>edge_range.size()<sp/>==<sp/>10980);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>planar<sp/>regions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>One_ring_query<sp/>one_ring_query(surface_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Plane_region<sp/>plane_region(surface_mesh);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RG_planes<sp/>rg_planes(face_range,<sp/>one_ring_query,<sp/>plane_region);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>RG_planes::Primitive_and_region&gt;<sp/>regions;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rg_planes.detect(std::back_inserter(regions));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>planar<sp/>regions:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>regions.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>regions.size()<sp/>==<sp/>9);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>fullpath<sp/>=<sp/>(argc<sp/>&gt;<sp/>2<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;regions_sm.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>utils::save_polygon_mesh_regions(surface_mesh,<sp/>regions,<sp/>fullpath);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>linear<sp/>regions.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Polyline_graph<sp/>pgraph(surface_mesh,<sp/>rg_planes.region_map());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>segment_range<sp/>=<sp/>pgraph.segment_range();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>extracted<sp/>segments:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>segment_range.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Line_region<sp/>line_region(CGAL::parameters::segment_map(pgraph.segment_map()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Line_sorting<sp/>line_sorting(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segment_range,<sp/>pgraph,<sp/>CGAL::parameters::segment_map(pgraph.segment_map()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>line_sorting.sort();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RG_lines<sp/>rg_lines(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>segment_range,<sp/>line_sorting.ordered(),<sp/>pgraph,<sp/>line_region);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;typename<sp/>RG_lines::Primitive_and_region&gt;<sp/>subregions;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rg_lines.detect(std::back_inserter(subregions));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*<sp/>number<sp/>of<sp/>found<sp/>linear<sp/>regions:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>subregions.size()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assert(!is_default_input<sp/>||<sp/>subregions.size()<sp/>==<sp/>21);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fullpath<sp/>=<sp/>(argc<sp/>&gt;<sp/>2<sp/>?<sp/>argv[2]<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;subregions_sm.ply&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>utils::save_segment_regions_3&lt;Kernel,<sp/>std::vector&lt;typename<sp/>RG_lines::Primitive_and_region&gt;,<sp/>Segment_map&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subregions,<sp/>fullpath,<sp/>pgraph.segment_map());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<sect3 id="index_1Shape_detection_RegionGrowingSegments_parameters">
<title>Parameters</title>
<para>The line fitting class above depends on three parameters:</para>
<para><itemizedlist>
<listitem><para><computeroutput>maximum_distance</computeroutput> - the maximum distance from the furthest segment vertex to a line;</para>
</listitem><listitem><para><computeroutput>maximum_angle</computeroutput> - the maximum angle in degrees between the segment direction and the direction of a line;</para>
</listitem><listitem><para><computeroutput>minimum_region_size</computeroutput> - the minimum number of segments a region must have.</para>
</listitem></itemizedlist>
</para>
<para>The right choice of these parameters is important for producing the good results.</para>
</sect3>
</sect2>
</sect1>
<sect1 id="index_1Shape_detection_Comparison">
<title>Comparison</title>
<para>The Efficient RANSAC algorithm is very quick, however, since it is not deterministic, some small shapes might be missed in the detection process.</para>
<para>Instead, the region growing algorithm usually takes longer to complete, but it may provide better quality output in the presence of large scenes with numerous small details. Since it iterates throughout all items of the scene, there are fewer chances to miss a shape. In addition, it is deterministic (for a given input and a given set of parameters, it always returns the same output, whereas the Efficient RANSAC algorithm is randomized and so the output may vary at each run), see Figure <ref refid="index_1fig__Shape_detection_comparison" kindref="member">fig__Shape_detection_comparison</ref>.</para>
<para><anchor id="index_1fig__Shape_detection_comparison"/> <image type="html" name="comparison.png"></image>
 <image type="latex" name="comparison.png" width="15cm"></image>
 <htmlonly block="yes"> &lt;div class=&quot;cgal_figure_caption&quot;&gt; </htmlonly>  <ref refid="index_1fig__Shape_detection_comparison" kindref="member">fig__Shape_detection_comparison</ref> Comparison of the Efficient RANSAC and region growing algorithms. Top: the input point set. Bottom left: the output of the Efficient RANSAC, <formula id="3">$78\%$</formula> of the shapes are correctly detected in 8 seconds. Bottom right: the output of the region growing, <formula id="4">$100\%$</formula> of the shapes detected in 15 seconds. Unassigned points are in black in both output images. <htmlonly block="yes"> &lt;/div&gt; </htmlonly> <linebreak/>
</para>
</sect1>
<sect1 id="index_1Shape_detection_History">
<title>History</title>
<para>The Efficient RANSAC component was developed by Sven Oesau based on the prototype version created by Yannick Verdie, with the help of Cl√©ment Jamin and under the supervision of Pierre Alliez.</para>
<para>The region growing algorithm on a 3D point set was first implemented by Simon Giraudot based on the prototype version developed by Florent Lafarge and then generalized to arbitrary items including versions for a 2D point set, a 3D point set, and a polygon mesh by Thien Hoang during the Google Summer of Code 2018 under the supervision of Dmitry Anisimov. The version for segments was added later by Dmitry Anisimov.</para>
</sect1>
<sect1 id="index_1Shape_detection_Acknowledgments">
<title>Acknowledgments</title>
<para>The authors wish to thank our reviewers Andreas Fabri, S√©bastien Loriot, and Simon Giraudot for helpful comments and discussions. </para>
</sect1>
    </detaileddescription>
    <location file="Shape_detection.txt"/>
  </compounddef>
</doxygen>
