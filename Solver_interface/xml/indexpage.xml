<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>User Manual</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1Chapter_CGAL_and_Solvers"/><anchor id="index_1chapterSolvers"/><htmlonly block="yes"> &lt;div id=&quot;autotoc&quot; class=&quot;toc&quot;&gt;&lt;/div&gt; </htmlonly> <simplesect kind="authors"><para>Simon Giraudot, Pierre Alliez, Frédéric Cazals, Gaël Guennebaud, Bruno Lévy, Marc Pouget, Laurent Saboret, and Liangliang Nan</para>
</simplesect>
Several CGAL packages have to solve linear systems with dense or sparse matrices, linear integer programs, and quadratic programs. This package provides concepts and models for that purpose.</para>
<para>For linear systems, we generally provide models using the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library. Wrappers for the Eigen classes <computeroutput><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref></computeroutput> and <computeroutput><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref></computeroutput> are also provided when needed. It is straightforward to develop equivalent models for other solvers, for example those found in the <ulink url="https://software.intel.com/en-us/mkl">Intel Math Kernel Library (MKL)</ulink>.</para>
<para>For mixed integer programs (either constrained or unconstrained), we provide models using the <ref refid="thirdparty_1thirdpartySCIP" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">SCIP</ref> and <ref refid="thirdparty_1thirdpartyGLPK" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">GLPK</ref> libraries.</para>
<para>For linear and quadratic programs, CGAL provides the built-in <ref refid="packages_1PkgQPSolver" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">CGAL Linear and Quadratic Programming Solver</ref> and we also provide a model using the <ref refid="thirdparty_1thirdpartyOSQP" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">OSQP</ref> library.</para>
<sect1 id="index_1SectionSolverDiagonalize">
<title>Matrix Diagonalization</title>
<para>The concept <computeroutput><ref refid="classDiagonalizeTraits" kindref="compound">DiagonalizeTraits</ref>&lt;T, dim&gt;</computeroutput> defines an interface for the diagonalization and computation of eigenvectors and eigenvalues of a symmetric matrix. <computeroutput>T</computeroutput> is the number type and <computeroutput>dim</computeroutput> is the dimension of the matrices and vector (set to 3 by default). We provide the model <computeroutput><ref refid="classCGAL_1_1Eigen__diagonalize__traits" kindref="compound">Eigen_diagonalize_traits</ref>&lt;T, dim&gt;</computeroutput> that uses the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library.</para>
<para>This is an example of an eigen decomposition of a matrix using this class:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Solver_interface_2diagonalize_matrix_8cpp-example" kindref="compound">Solver_interface/diagonalize_matrix.cpp</ref> <programlisting filename="Solver_interface/diagonalize_matrix.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_diagonalize_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::array&lt;FT,<sp/>6&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::array&lt;FT,<sp/>3&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::array&lt;FT,<sp/>9&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Eigen_three_vectors;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__diagonalize__traits" kindref="compound">CGAL::Eigen_diagonalize_traits&lt;FT, 3&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Diagonalize_traits;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref><sp/>covariance<sp/>=<sp/>{{<sp/>0.,<sp/>0.,<sp/>0.,<sp/>0.,<sp/>0.,<sp/>0.<sp/>}};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Fill<sp/>matrix<sp/>with<sp/>random<sp/>numbers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;6;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>covariance[i]<sp/>=<sp/>rand();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Eigen_vector<sp/>eigenvalues;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Eigen_three_vectors<sp/>eigenvectors;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!(Diagonalize_traits::diagonalize_selfadjoint_covariance_matrix(covariance,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eigenvalues,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eigenvectors)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>cannot<sp/>diagonalize<sp/>matrix&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;3;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Eigenvalue<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i+1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>eigenvalues[i]<sp/>&lt;&lt;<sp/>std::endl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>with<sp/>eigenvector<sp/>[<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>j=0;<sp/>j&lt;3;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>eigenvectors[3*i<sp/>+<sp/>j]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1SectionSolverSVD">
<title>Singular Value Decomposition</title>
<para>The concept <computeroutput><ref refid="classSvdTraits" kindref="compound">SvdTraits</ref></computeroutput> defines an interface for solving in the least square sense a linear system with a singular value decomposition. The field type is <computeroutput>double</computeroutput>. We provide the model <computeroutput><ref refid="classCGAL_1_1Eigen__svd" kindref="compound">Eigen_svd</ref></computeroutput> that uses the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library.</para>
<para>Here is a simple example that shows how to handle matrices, vectors, and this solver:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Solver_interface_2singular_value_decomposition_8cpp-example" kindref="compound">Solver_interface/singular_value_decomposition.cpp</ref> <programlisting filename="Solver_interface/singular_value_decomposition.cpp"><codeline><highlight class="preprocessor">#ifdef<sp/>CGAL_EIGEN3_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_matrix.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_vector.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_svd.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__svd" kindref="compound">CGAL::Eigen_svd</ref><sp/>Svd;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Svd::FT<sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Svd::Vector<sp/><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Svd::Matrix<sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>degree<sp/>=<sp/>3;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref><sp/>B(degree);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref><sp/>M(degree,<sp/>degree);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Fill<sp/>B<sp/>and<sp/>M<sp/>with<sp/>random<sp/>numbers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;degree;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>B.set(i,<sp/>rand());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>degree;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>M.set(i,<sp/>j,<sp/>rand());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Solve<sp/>MX=B</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>Svd::solve(M,<sp/>B)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Print<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Solution<sp/>of<sp/>SVD<sp/>=<sp/>[<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;degree;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>B.vector()[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1SectionSolverSparse">
<title>Sparse Solvers</title>
<para>We define 3 concepts for sparse linear algebra:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="classSparseLinearAlgebraTraits__d" kindref="compound">SparseLinearAlgebraTraits_d</ref></computeroutput></para>
</listitem><listitem><para><computeroutput><ref refid="classSparseLinearAlgebraWithFactorTraits__d" kindref="compound">SparseLinearAlgebraWithFactorTraits_d</ref></computeroutput></para>
</listitem><listitem><para><computeroutput><ref refid="classNormalEquationSparseLinearAlgebraTraits__d" kindref="compound">NormalEquationSparseLinearAlgebraTraits_d</ref></computeroutput></para>
</listitem></itemizedlist>
</para>
<para>An interface to the sparse solvers from the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library is provided as a model for these 3 concepts through the class <computeroutput><ref refid="classCGAL_1_1Eigen__solver__traits" kindref="compound">Eigen_solver_traits</ref>&lt;T&gt;</computeroutput>. This solver traits class can be used for an iterative or a direct, symmetric or general sparse solvers. The specific solver to be used must be given as template parameter.</para>
<para>Each CGAL package using a sparse solver specifies which type of matrix and solver is required:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structCGAL_1_1Eigen__sparse__matrix_1a4b43cacc467d285c11a39f4eef7a55ae" kindref="member">CGAL::Eigen_sparse_matrix&lt;double&gt;::EigenType</ref><sp/>EigenMatrix;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>iterative<sp/>general<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__solver__traits" kindref="compound">CGAL::Eigen_solver_traits&lt; Eigen::BiCGSTAB&lt;EigenMatrix&gt;</ref><sp/>&gt;<sp/>Iterative_general_solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>iterative<sp/>symmetric<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__solver__traits" kindref="compound">CGAL::Eigen_solver_traits&lt; Eigen::ConjugateGradient&lt;EigenMatrix&gt;</ref><sp/>&gt;<sp/>Iterative_symmetric_solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>direct<sp/>symmetric<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__solver__traits" kindref="compound">CGAL::Eigen_solver_traits&lt; Eigen::SimplicialCholesky&lt;EigenMatrix&gt;</ref><sp/>&gt;<sp/>Direct_symmetric_solver;</highlight></codeline>
</programlisting></para>
<para>Here is an example that shows how to fill the sparse matrix and call the solver:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Solver_interface_2sparse_solvers_8cpp-example" kindref="compound">Solver_interface/sparse_solvers.cpp</ref> <programlisting filename="Solver_interface/sparse_solvers.cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_solver_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Eigen_matrix.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1Eigen__solver__traits" kindref="compound">CGAL::Eigen_solver_traits&lt;&gt;</ref><sp/>Eigen_solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Eigen_solver::NT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Eigen_solver::Matrix<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>Eigen_solver::Vector<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>srand(</highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(time<sp/>(</highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>degree<sp/>=<sp/>3000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>nb_nonzero_coef<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1Eigen__vector" kindref="compound">Eigen_vector</ref><sp/>B(degree);<sp/></highlight><highlight class="comment">//<sp/>Zero<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structCGAL_1_1Eigen__matrix" kindref="compound">Eigen_matrix</ref><sp/>A(degree);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Randomly<sp/>make<sp/>some<sp/>coefficients<sp/>of<sp/>the<sp/>matrix<sp/>non-zero</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::size_t<sp/>i=0;<sp/>i&lt;nb_nonzero_coef;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>rand()<sp/>%<sp/>degree;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>y<sp/>=<sp/>rand()<sp/>%<sp/>degree;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FT<sp/>value<sp/>=<sp/>rand()<sp/>/<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">FT</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(RAND_MAX);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>A.add_coef(x,<sp/>y,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>A.add_coef(y,<sp/>x,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Eigen_vector<sp/>X(degree);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FT<sp/>d;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Eigen_solver<sp/>solver;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!(solver.linear_solver(A,<sp/>B,<sp/>X,<sp/>d)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>linear<sp/>solver<sp/>failed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Linear<sp/>solve<sp/>succeeded&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1SectionMIPSolver">
<title>Mixed Integer Program Solvers</title>
<para>The concept <computeroutput><ref refid="classMixedIntegerProgramTraits" kindref="compound">MixedIntegerProgramTraits</ref></computeroutput> defines an interface for formulating and solving (constrained or unconstrained) mixed integer programs. It can also be used for general linear programs.</para>
<para>The field type is <computeroutput>double</computeroutput>. We provide two models of this concept: <computeroutput><ref refid="classCGAL_1_1GLPK__mixed__integer__program__traits" kindref="compound">CGAL::GLPK_mixed_integer_program_traits</ref></computeroutput> using <ref refid="thirdparty_1thirdpartyGLPK" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">GLPK</ref> and <computeroutput><ref refid="classCGAL_1_1SCIP__mixed__integer__program__traits" kindref="compound">CGAL::SCIP_mixed_integer_program_traits</ref></computeroutput> using <ref refid="thirdparty_1thirdpartySCIP" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">SCIP</ref>.</para>
<para>Here is an example that shows how to formulate and solve a simple mixed integer program using this solver:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Solver_interface_2mixed_integer_program_8cpp-example" kindref="compound">Solver_interface/mixed_integer_program.cpp</ref> <programlisting filename="Solver_interface/mixed_integer_program.cpp"><codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment">*<sp/>This<sp/>example<sp/>shows<sp/>how<sp/>to<sp/>formulate<sp/>and<sp/>solve<sp/>the<sp/>following<sp/>MIP<sp/>problem:</highlight></codeline>
<codeline><highlight class="comment">*</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maximize</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Objective:<sp/>x1<sp/>+<sp/>2<sp/>x2<sp/>+<sp/>3<sp/>x3<sp/>+<sp/>x4</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Subject<sp/>to</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1:<sp/>-<sp/>x1<sp/>+<sp/><sp/><sp/>x2<sp/>+<sp/>x3<sp/>+<sp/><sp/>10<sp/>x4<sp/>&lt;=<sp/>20</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c2:<sp/><sp/><sp/>x1<sp/>-<sp/>3<sp/>x2<sp/>+<sp/>x3<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;=<sp/>30</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c3:<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x2<sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>3.5<sp/>x4<sp/><sp/>=<sp/><sp/>0</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Bounds</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0<sp/>&lt;=<sp/>x1<sp/>&lt;=<sp/>40</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2<sp/>&lt;=<sp/>x4<sp/>&lt;=<sp/>3</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>General</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x4<sp/>is<sp/>integer</highlight></codeline>
<codeline><highlight class="comment">*</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Expected<sp/>results:<sp/>x1=40;<sp/>x2=10.5;<sp/>x3=19.5;<sp/>x4=3;</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>CGAL_USE_SCIP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/SCIP_mixed_integer_program_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1SCIP__mixed__integer__program__traits" kindref="compound">CGAL::SCIP_mixed_integer_program_traits&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MIP_Solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(CGAL_USE_GLPK)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/GLPK_mixed_integer_program_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="classCGAL_1_1GLPK__mixed__integer__program__traits" kindref="compound">CGAL::GLPK_mixed_integer_program_traits&lt;double&gt;</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MIP_Solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>MIP_Solver::Variable<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Variable" kindref="compound">Variable</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>MIP_Solver::Linear_objective<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__objective" kindref="compound">Linear_objective</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>MIP_Solver::Linear_constraint<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__constraint" kindref="compound">Linear_constraint</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MIP_Solver<sp/>solver;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Variable<sp/>x1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Variable" kindref="compound">Variable</ref>*<sp/>x1<sp/>=<sp/>solver.create_variable(Variable::CONTINUOUS,<sp/>0,<sp/>40,<sp/></highlight><highlight class="stringliteral">&quot;x1&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Variable<sp/>x2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>can<sp/>create<sp/>first<sp/>(using<sp/>default<sp/>parameters)<sp/>and<sp/>then<sp/>assign<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Variable" kindref="compound">Variable</ref>*<sp/>x2<sp/>=<sp/>solver.create_variable();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x2-&gt;set_name(</highlight><highlight class="stringliteral">&quot;x2&quot;</highlight><highlight class="normal">);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>optional<sp/>(a<sp/>default<sp/>will<sp/>be<sp/>given)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Variable<sp/>x3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Variable" kindref="compound">Variable</ref>*<sp/>x3<sp/>=<sp/>solver.create_variable();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Uses<sp/>all<sp/>default<sp/>parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x3-&gt;set_name(</highlight><highlight class="stringliteral">&quot;x3&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Variable<sp/>x4</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Variable" kindref="compound">Variable</ref>*<sp/>x4<sp/>=<sp/>solver.create_variable(Variable::INTEGER,<sp/>2,<sp/>3,<sp/></highlight><highlight class="stringliteral">&quot;x4&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Objective.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Be<sp/>careful<sp/>this<sp/>is<sp/>&quot;MAXIMIZE&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__objective" kindref="compound">Linear_objective</ref><sp/>*<sp/>obj<sp/>=<sp/>solver.create_objective(Linear_objective::MAXIMIZE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>obj-&gt;add_coefficient(x1,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>obj-&gt;add_coefficient(x2,<sp/>2.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>obj-&gt;add_coefficient(x3,<sp/>3.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>obj-&gt;add_coefficient(x4,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Constraint<sp/>c1:<sp/>-x1<sp/>+<sp/>x2<sp/>+<sp/>x3<sp/>+<sp/>10<sp/>x4<sp/>&lt;=<sp/>20</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__constraint" kindref="compound">Linear_constraint</ref>*<sp/>c1<sp/>=<sp/>solver.create_constraint(-Linear_constraint::infinity(),<sp/>20,<sp/></highlight><highlight class="stringliteral">&quot;c1&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1-&gt;add_coefficient(x1,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1-&gt;add_coefficient(x2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1-&gt;add_coefficient(x3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1-&gt;add_coefficient(x4,<sp/>10);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Constraint<sp/>c2:<sp/>x1<sp/>-<sp/>3<sp/>x2<sp/>+<sp/>x3<sp/>&lt;=<sp/>30</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__constraint" kindref="compound">Linear_constraint</ref>*<sp/>c2<sp/>=<sp/>solver.create_constraint(-Linear_constraint::infinity(),<sp/>30,<sp/></highlight><highlight class="stringliteral">&quot;c2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c2-&gt;add_coefficient(x1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c2-&gt;add_coefficient(x2,<sp/>-3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c2-&gt;add_coefficient(x3,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Constraint<sp/>c3:<sp/><sp/>x2<sp/>-<sp/>3.5<sp/>x4<sp/>=<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classCGAL_1_1Linear__constraint" kindref="compound">Linear_constraint</ref>*<sp/>c3<sp/>=<sp/>solver.create_constraint(0,<sp/>0,<sp/></highlight><highlight class="stringliteral">&quot;c3&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c3-&gt;add_coefficient(x2,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c3-&gt;add_coefficient(x4,<sp/>-3.5);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Solve</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(solver.solve())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;result:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;double&gt;&amp;<sp/>results<sp/>=<sp/>solver.solution();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>results.size();<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\tx&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>+<sp/>1<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>results[i]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_SUCCESS;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;solving<sp/>problem<sp/>failed&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1SectionQPSolver">
<title>Quadratic Program Solvers</title>
<para>The concept <computeroutput><ref refid="classQuadraticProgramTraits" kindref="compound">QuadraticProgramTraits</ref></computeroutput> defines an interface for quadratic programs (QP) whereas a similar concept <computeroutput><ref refid="classLinearProgramTraits" kindref="compound">LinearProgramTraits</ref></computeroutput> gives an interface for linear programs (LP). The model <computeroutput><ref refid="classCGAL_1_1OSQP__quadratic__program__traits" kindref="compound">CGAL::OSQP_quadratic_program_traits</ref></computeroutput> provides a way to solve convex quadratic programs with the dense or sparse interface.</para>
<para>Here is an example that shows how to formulate and solve a simple convex quadratic program using the latter solver:</para>
<para><linebreak/>
<bold>File</bold> <ref refid="Solver_interface_2osqp_quadratic_program_8cpp-example" kindref="compound">Solver_interface/osqp_quadratic_program.cpp</ref> <programlisting filename="Solver_interface/osqp_quadratic_program.cpp"><codeline><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment">*<sp/>This<sp/>example<sp/>shows<sp/>how<sp/>to<sp/>formulate<sp/>and<sp/>solve<sp/>the<sp/>following<sp/>QP<sp/>problem:</highlight></codeline>
<codeline><highlight class="comment">*<sp/>https://osqp.org/docs/examples/setup-and-solve.html</highlight></codeline>
<codeline><highlight class="comment">*</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Minimize</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Objective:</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>1/2(4x1^2<sp/>+<sp/>2x1x2<sp/>+<sp/>2x2^2)<sp/>+<sp/>(x1<sp/>+<sp/>x2)<sp/>+<sp/>0<sp/>or<sp/>in<sp/>the<sp/>matrix<sp/>form</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>1/2<sp/>x^T|4<sp/>1|x<sp/>+<sp/>|1|^Tx<sp/>+<sp/>0</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|1<sp/>2|<sp/><sp/><sp/><sp/>|1|</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Subject<sp/>to</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>1<sp/>&lt;=<sp/>x1<sp/>+<sp/>x2<sp/>&lt;=<sp/>1</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>0<sp/>&lt;=<sp/>x1<sp/><sp/><sp/><sp/><sp/><sp/>&lt;=<sp/>0.7</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>0<sp/>&lt;=<sp/><sp/><sp/><sp/><sp/><sp/>x2<sp/>&lt;=<sp/>0.7<sp/>or<sp/>in<sp/>the<sp/>matrix<sp/>form</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>|1|<sp/><sp/><sp/><sp/>|1<sp/>1|<sp/><sp/><sp/><sp/><sp/>|1.0|</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>|0|<sp/>&lt;=<sp/>|1<sp/>0|x<sp/>&lt;=<sp/>|0.7|</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/><sp/><sp/>|0|<sp/><sp/><sp/><sp/>|0<sp/>1|<sp/><sp/><sp/><sp/><sp/>|0.7|</highlight></codeline>
<codeline><highlight class="comment">*</highlight></codeline>
<codeline><highlight class="comment">*<sp/><sp/><sp/>Expected<sp/>results:<sp/>x1<sp/>=<sp/>0.3;<sp/>x2<sp/>=<sp/>0.7;</highlight></codeline>
<codeline><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/Simple_cartesian.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;CGAL/OSQP_quadratic_program_traits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal"><ref refid="namespaceKernel" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">Kernel</ref><sp/>=<sp/><ref refid="structCGAL_1_1Simple__cartesian" kindref="compound" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Kernel_23.tag">CGAL::Simple_cartesian&lt;double&gt;</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">FT<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Kernel::FT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>n<sp/>=<sp/>2;<sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>variables</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::size_t<sp/>m<sp/>=<sp/>3;<sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>constraints</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classCGAL_1_1OSQP__quadratic__program__traits" kindref="compound">CGAL::OSQP_quadratic_program_traits&lt;FT&gt;</ref><sp/>osqp(n,<sp/>m);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_P(0,<sp/>0,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_P(0,<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_P(1,<sp/>1,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_q(0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_q(1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_r(0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_A(0,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_A(0,<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_A(1,<sp/>0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_A(2,<sp/>1,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_l(0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_l(1,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_l(2,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_u(0,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_u(1,<sp/>0.7);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.set_u(2,<sp/>0.7);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::vector&lt;FT&gt;<sp/>x;<sp/>x.reserve(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>osqp.solve(std::back_inserter(x));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;solution<sp/>(x1<sp/>x2):<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FT<sp/>value<sp/>:<sp/>x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>value<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;;<sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="index_1SolversHistory">
<title>Implementation History</title>
<para>This package is the result of the increasing needs for linear solvers in CGAL. The first packages that introduced the solver concepts were <ref refid="packages_1PkgSurfaceMeshParameterization" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Parameterization</ref>, <ref refid="packages_1PkgPoissonSurfaceReconstruction3" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Poisson Surface Reconstruction</ref> and <ref refid="packages_1PkgJetFitting3" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Estimation of Local Differential Properties of Point-Sampled Surfaces</ref>. At that time, these packages were relying on TAUCS, LAPACK, BLAS and OpenNL. Gaël Guennebaud then introduced new models using the <ref refid="thirdparty_1thirdpartyEigen" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Eigen</ref> library that became the only supported models by CGAL. Later on the packages <ref refid="packages_1PkgSurfaceMeshSkeletonization" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Skeletonization</ref> and <ref refid="packages_1PkgSurfaceMeshDeformation" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Triangulated Surface Mesh Deformation</ref> extended the existing concepts. Liangliang Nan introduced the concept <computeroutput><ref refid="classMixedIntegerProgramTraits" kindref="compound">MixedIntegerProgramTraits</ref></computeroutput> and two models for solving mixed integer programs when implementing the <ref refid="packages_1PkgPolygonalSurfaceReconstruction" kindref="member" external="/home/runner/work/cgal-cn/cgal-cn/build_doc/doc_tags/Manual.tag">Polygonal Surface Reconstruction</ref> package. The concepts and models for solving linear and quadratic programs were later introduced by Dmitry Anisimov and Mael Rouxel-Labbé.</para>
<para>Simon Giraudot was responsible for gathering all concepts and classes, and also wrote this user manual with the help of Andreas Fabri. </para>
</sect1>
    </detaileddescription>
    <location file="Solver_interface.txt"/>
  </compounddef>
</doxygen>
